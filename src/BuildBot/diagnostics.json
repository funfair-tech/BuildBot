{
  "$schema": "http://json.schemastore.org/sarif-2.1.0",
  "version": "2.1.0",
  "runs": [
    {
      "results": [
        {
          "ruleId": "MA0109",
          "ruleIndex": 653,
          "level": "error",
          "message": {
            "text": "Consider adding an overload with a Span<T> or Memory<T>"
          },
          "suppressions": [
            {
              "kind": "inSource",
              "justification": "Won't work here",
              "properties": {
                "suppressionType": "SuppressMessageAttribute"
              }
            }
          ],
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///home/markr/work/funfair/BuildBot/src/BuildBot/Program.cs"
                },
                "region": {
                  "startLine": 14,
                  "startColumn": 30,
                  "endLine": 14,
                  "endColumn": 34
                }
              }
            }
          ]
        },
        {
          "ruleId": "CC0061",
          "ruleIndex": 359,
          "level": "note",
          "message": {
            "text": "Change method name to MainAsync"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///home/markr/work/funfair/BuildBot/src/BuildBot/Program.cs"
                },
                "region": {
                  "startLine": 14,
                  "startColumn": 30,
                  "endLine": 14,
                  "endColumn": 34
                }
              }
            }
          ],
          "properties": {
            "warningLevel": 1
          }
        },
        {
          "ruleId": "NX0001",
          "ruleIndex": 686,
          "level": "note",
          "message": {
            "text": "Instance of NullForgiving operator without justification detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///home/markr/work/funfair/BuildBot/src/BuildBot/Helpers/VersionDetection.cs"
                },
                "region": {
                  "startLine": 41,
                  "startColumn": 46,
                  "endLine": 41,
                  "endColumn": 47
                }
              }
            }
          ],
          "properties": {
            "warningLevel": 1
          }
        },
        {
          "ruleId": "RCS1192",
          "ruleIndex": 908,
          "level": "note",
          "message": {
            "text": "Unnecessary usage of verbatim string literal."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///home/markr/work/funfair/BuildBot/src/BuildBot/Helpers/ApplicationConfigLocator.cs"
                },
                "region": {
                  "startLine": 37,
                  "startColumn": 59,
                  "endLine": 37,
                  "endColumn": 60
                }
              }
            }
          ],
          "properties": {
            "warningLevel": 1
          }
        },
        {
          "ruleId": "CSE006",
          "ruleIndex": 398,
          "level": "note",
          "message": {
            "text": "Try to simplify expression by extracting method invocation results to separated variables"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///home/markr/work/funfair/BuildBot/src/BuildBot/Helpers/ApplicationConfigLocator.cs"
                },
                "region": {
                  "startLine": 37,
                  "startColumn": 19,
                  "endLine": 37,
                  "endColumn": 25
                }
              }
            }
          ],
          "properties": {
            "warningLevel": 1
          }
        },
        {
          "ruleId": "CSE005",
          "ruleIndex": 397,
          "level": "note",
          "message": {
            "text": "Use the return value or discard it explicitly"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///home/markr/work/funfair/BuildBot/src/BuildBot/Helpers/ServerStartup.cs"
                },
                "region": {
                  "startLine": 23,
                  "startColumn": 13,
                  "endLine": 23,
                  "endColumn": 99
                }
              }
            }
          ],
          "properties": {
            "warningLevel": 1
          }
        },
        {
          "ruleId": "CSE005",
          "ruleIndex": 397,
          "level": "note",
          "message": {
            "text": "Use the return value or discard it explicitly"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///home/markr/work/funfair/BuildBot/src/BuildBot/Helpers/ServerStartup.cs"
                },
                "region": {
                  "startLine": 28,
                  "startColumn": 13,
                  "endLine": 28,
                  "endColumn": 95
                }
              }
            }
          ],
          "properties": {
            "warningLevel": 1
          }
        },
        {
          "ruleId": "CSE005",
          "ruleIndex": 397,
          "level": "note",
          "message": {
            "text": "Use the return value or discard it explicitly"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///home/markr/work/funfair/BuildBot/src/BuildBot/Helpers/ServerStartup.cs"
                },
                "region": {
                  "startLine": 33,
                  "startColumn": 13,
                  "endLine": 33,
                  "endColumn": 98
                }
              }
            }
          ],
          "properties": {
            "warningLevel": 1
          }
        },
        {
          "ruleId": "CSE005",
          "ruleIndex": 397,
          "level": "note",
          "message": {
            "text": "Use the return value or discard it explicitly"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///home/markr/work/funfair/BuildBot/src/BuildBot/Helpers/ServerStartup.cs"
                },
                "region": {
                  "startLine": 99,
                  "startColumn": 13,
                  "endLine": 99,
                  "endColumn": 37
                }
              }
            }
          ],
          "properties": {
            "warningLevel": 1
          }
        },
        {
          "ruleId": "CSE005",
          "ruleIndex": 397,
          "level": "note",
          "message": {
            "text": "Use the return value or discard it explicitly"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///home/markr/work/funfair/BuildBot/src/BuildBot/Helpers/ServerStartup.cs"
                },
                "region": {
                  "startLine": 105,
                  "startColumn": 13,
                  "endLine": 105,
                  "endColumn": 55
                }
              }
            }
          ],
          "properties": {
            "warningLevel": 1
          }
        },
        {
          "ruleId": "RCS1192",
          "ruleIndex": 908,
          "level": "note",
          "message": {
            "text": "Unnecessary usage of verbatim string literal."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///home/markr/work/funfair/BuildBot/src/BuildBot/Startup.cs"
                },
                "region": {
                  "startLine": 122,
                  "startColumn": 41,
                  "endLine": 122,
                  "endColumn": 42
                }
              }
            }
          ],
          "properties": {
            "warningLevel": 1
          }
        },
        {
          "ruleId": "RCS1192",
          "ruleIndex": 908,
          "level": "note",
          "message": {
            "text": "Unnecessary usage of verbatim string literal."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///home/markr/work/funfair/BuildBot/src/BuildBot/Startup.cs"
                },
                "region": {
                  "startLine": 123,
                  "startColumn": 44,
                  "endLine": 123,
                  "endColumn": 45
                }
              }
            }
          ],
          "properties": {
            "warningLevel": 1
          }
        },
        {
          "ruleId": "CC0091",
          "ruleIndex": 380,
          "level": "error",
          "message": {
            "text": "Make 'Configure' method static."
          },
          "suppressions": [
            {
              "kind": "inSource",
              "justification": "Called by the runtime",
              "properties": {
                "suppressionType": "SuppressMessageAttribute"
              }
            }
          ],
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///home/markr/work/funfair/BuildBot/src/BuildBot/Startup.cs"
                },
                "region": {
                  "startLine": 142,
                  "startColumn": 17,
                  "endLine": 142,
                  "endColumn": 26
                }
              }
            }
          ]
        },
        {
          "ruleId": "RCS1205",
          "ruleIndex": 921,
          "level": "note",
          "message": {
            "text": "Order named arguments according to the order of parameters."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///home/markr/work/funfair/BuildBot/src/BuildBot/Startup.cs"
                },
                "region": {
                  "startLine": 132,
                  "startColumn": 20,
                  "endLine": 135,
                  "endColumn": 79
                }
              }
            }
          ],
          "properties": {
            "warningLevel": 1
          }
        },
        {
          "ruleId": "RCS1192",
          "ruleIndex": 908,
          "level": "note",
          "message": {
            "text": "Unnecessary usage of verbatim string literal."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///home/markr/work/funfair/BuildBot/src/BuildBot/Startup.cs"
                },
                "region": {
                  "startLine": 132,
                  "startColumn": 47,
                  "endLine": 132,
                  "endColumn": 48
                }
              }
            }
          ],
          "properties": {
            "warningLevel": 1
          }
        },
        {
          "ruleId": "RCS1192",
          "ruleIndex": 908,
          "level": "note",
          "message": {
            "text": "Unnecessary usage of verbatim string literal."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///home/markr/work/funfair/BuildBot/src/BuildBot/Startup.cs"
                },
                "region": {
                  "startLine": 133,
                  "startColumn": 48,
                  "endLine": 133,
                  "endColumn": 49
                }
              }
            }
          ],
          "properties": {
            "warningLevel": 1
          }
        },
        {
          "ruleId": "RCS1192",
          "ruleIndex": 908,
          "level": "note",
          "message": {
            "text": "Unnecessary usage of verbatim string literal."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///home/markr/work/funfair/BuildBot/src/BuildBot/Startup.cs"
                },
                "region": {
                  "startLine": 134,
                  "startColumn": 55,
                  "endLine": 134,
                  "endColumn": 56
                }
              }
            }
          ],
          "properties": {
            "warningLevel": 1
          }
        },
        {
          "ruleId": "RCS1192",
          "ruleIndex": 908,
          "level": "note",
          "message": {
            "text": "Unnecessary usage of verbatim string literal."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///home/markr/work/funfair/BuildBot/src/BuildBot/Startup.cs"
                },
                "region": {
                  "startLine": 135,
                  "startColumn": 46,
                  "endLine": 135,
                  "endColumn": 47
                }
              }
            }
          ],
          "properties": {
            "warningLevel": 1
          }
        },
        {
          "ruleId": "CSE005",
          "ruleIndex": 397,
          "level": "note",
          "message": {
            "text": "Use the return value or discard it explicitly"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///home/markr/work/funfair/BuildBot/src/BuildBot/Helpers/ServerStartup.cs"
                },
                "region": {
                  "startLine": 73,
                  "startColumn": 50,
                  "endLine": 80,
                  "endColumn": 121
                }
              }
            }
          ],
          "properties": {
            "warningLevel": 1
          }
        },
        {
          "ruleId": "CSE005",
          "ruleIndex": 397,
          "level": "note",
          "message": {
            "text": "Use the return value or discard it explicitly"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///home/markr/work/funfair/BuildBot/src/BuildBot/Startup.cs"
                },
                "region": {
                  "startLine": 144,
                  "startColumn": 9,
                  "endLine": 144,
                  "endColumn": 35
                }
              }
            }
          ],
          "properties": {
            "warningLevel": 1
          }
        },
        {
          "ruleId": "CSE007",
          "ruleIndex": 399,
          "level": "error",
          "message": {
            "text": "Handle disposal correctly"
          },
          "suppressions": [
            {
              "kind": "inSource",
              "justification": "Called by the runtime",
              "properties": {
                "suppressionType": "SuppressMessageAttribute"
              }
            }
          ],
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///home/markr/work/funfair/BuildBot/src/BuildBot/Startup.cs"
                },
                "region": {
                  "startLine": 144,
                  "startColumn": 9,
                  "endLine": 144,
                  "endColumn": 35
                }
              }
            }
          ]
        },
        {
          "ruleId": "CSE005",
          "ruleIndex": 397,
          "level": "note",
          "message": {
            "text": "Use the return value or discard it explicitly"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///home/markr/work/funfair/BuildBot/src/BuildBot/Startup.cs"
                },
                "region": {
                  "startLine": 145,
                  "startColumn": 9,
                  "endLine": 145,
                  "endColumn": 76
                }
              }
            }
          ],
          "properties": {
            "warningLevel": 1
          }
        },
        {
          "ruleId": "CSE007",
          "ruleIndex": 399,
          "level": "error",
          "message": {
            "text": "Handle disposal correctly"
          },
          "suppressions": [
            {
              "kind": "inSource",
              "justification": "Called by the runtime",
              "properties": {
                "suppressionType": "SuppressMessageAttribute"
              }
            }
          ],
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///home/markr/work/funfair/BuildBot/src/BuildBot/Startup.cs"
                },
                "region": {
                  "startLine": 145,
                  "startColumn": 9,
                  "endLine": 145,
                  "endColumn": 76
                }
              }
            }
          ]
        },
        {
          "ruleId": "CSE005",
          "ruleIndex": 397,
          "level": "note",
          "message": {
            "text": "Use the return value or discard it explicitly"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///home/markr/work/funfair/BuildBot/src/BuildBot/Startup.cs"
                },
                "region": {
                  "startLine": 147,
                  "startColumn": 9,
                  "endLine": 147,
                  "endColumn": 29
                }
              }
            }
          ],
          "properties": {
            "warningLevel": 1
          }
        },
        {
          "ruleId": "CSE005",
          "ruleIndex": 397,
          "level": "note",
          "message": {
            "text": "Use the return value or discard it explicitly"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///home/markr/work/funfair/BuildBot/src/BuildBot/Startup.cs"
                },
                "region": {
                  "startLine": 149,
                  "startColumn": 9,
                  "endLine": 152,
                  "endColumn": 77
                }
              }
            }
          ],
          "properties": {
            "warningLevel": 1
          }
        },
        {
          "ruleId": "CSE005",
          "ruleIndex": 397,
          "level": "note",
          "message": {
            "text": "Use the return value or discard it explicitly"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///home/markr/work/funfair/BuildBot/src/BuildBot/Startup.cs"
                },
                "region": {
                  "startLine": 78,
                  "startColumn": 9,
                  "endLine": 117,
                  "endColumn": 111
                }
              }
            }
          ],
          "properties": {
            "warningLevel": 1
          }
        }
      ],
      "tool": {
        "driver": {
          "name": "Microsoft (R) Visual C# Compiler",
          "version": "4.5.2-3.23171.7 (d17f7415)",
          "dottedQuadFileVersion": "4.5.0.0",
          "semanticVersion": "4.5.0",
          "language": "",
          "rules": [
            {
              "id": "API1000",
              "shortDescription": {
                "text": "Action returns undeclared status code"
              },
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "API1001",
              "shortDescription": {
                "text": "Action returns undeclared success result"
              },
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "API1002",
              "shortDescription": {
                "text": "Action documents status code that is not returned"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "API1003",
              "shortDescription": {
                "text": "Action methods on ApiController instances do not require explicit model validation check"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Usage",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "ASP0000",
              "shortDescription": {
                "text": "Do not call 'IServiceCollection.BuildServiceProvider' in 'ConfigureServices'"
              },
              "helpUri": "https://aka.ms/AA5k895",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "ASP0001",
              "shortDescription": {
                "text": "Authorization middleware is incorrectly configured"
              },
              "helpUri": "https://aka.ms/AA64fv1",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "ASP0003",
              "shortDescription": {
                "text": "Do not use model binding attributes with route handlers"
              },
              "helpUri": "https://aka.ms/aspnet/analyzers",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "ASP0004",
              "shortDescription": {
                "text": "Do not use action results with route handlers"
              },
              "helpUri": "https://aka.ms/aspnet/analyzers",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "ASP0005",
              "shortDescription": {
                "text": "Do not place attribute on method called by route handler lambda"
              },
              "helpUri": "https://aka.ms/aspnet/analyzers",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "ASP0006",
              "shortDescription": {
                "text": "Do not use non-literal sequence numbers"
              },
              "helpUri": "https://aka.ms/aspnet/analyzers",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "ASP0007",
              "shortDescription": {
                "text": "Route parameter and argument optionality is mismatched"
              },
              "helpUri": "https://aka.ms/aspnet/analyzers",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "ASP0008",
              "shortDescription": {
                "text": "Do not use ConfigureWebHost with WebApplicationBuilder.Host"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "helpUri": "https://aka.ms/aspnet/analyzers",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "ASP0009",
              "shortDescription": {
                "text": "Do not use Configure with WebApplicationBuilder.WebHost"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "helpUri": "https://aka.ms/aspnet/analyzers",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "ASP0010",
              "shortDescription": {
                "text": "Do not use UseStartup with WebApplicationBuilder.WebHost"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "helpUri": "https://aka.ms/aspnet/analyzers",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "ASP0011",
              "shortDescription": {
                "text": "Suggest using builder.Logging over Host.ConfigureLogging or WebHost.ConfigureLogging"
              },
              "helpUri": "https://aka.ms/aspnet/analyzers",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "ASP0012",
              "shortDescription": {
                "text": "Suggest using builder.Services over Host.ConfigureServices or WebHost.ConfigureServices"
              },
              "helpUri": "https://aka.ms/aspnet/analyzers",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "ASP0013",
              "shortDescription": {
                "text": "Suggest switching from using Configure methods to WebApplicationBuilder.Configuration"
              },
              "helpUri": "https://aka.ms/aspnet/analyzers",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "ASP0014",
              "shortDescription": {
                "text": "Suggest using top level route registrations"
              },
              "helpUri": "https://aka.ms/aspnet/analyzers",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "AsyncFixer01",
              "shortDescription": {
                "text": "Unnecessary async/await usage"
              },
              "fullDescription": {
                "text": "Await is the last statement of the method so you can return Task and await in the caller method."
              },
              "helpUri": "https://github.com/semihokur/AsyncFixer",
              "properties": {
                "category": "AsyncUsage",
                "tags": [
                  "Telemetry"
                ]
              }
            },
            {
              "id": "AsyncFixer02",
              "shortDescription": {
                "text": "Long-running or blocking operations inside an async method"
              },
              "helpUri": "https://github.com/semihokur/AsyncFixer",
              "properties": {
                "category": "AsyncUsage",
                "tags": [
                  "Telemetry"
                ]
              }
            },
            {
              "id": "AsyncFixer03",
              "shortDescription": {
                "text": "Fire-and-forget async-void methods or delegates"
              },
              "helpUri": "https://github.com/semihokur/AsyncFixer",
              "properties": {
                "category": "AsyncUsage",
                "tags": [
                  "Telemetry"
                ]
              }
            },
            {
              "id": "AsyncFixer04",
              "shortDescription": {
                "text": "Fire-and-forget async call inside a using block"
              },
              "helpUri": "https://github.com/semihokur/AsyncFixer",
              "properties": {
                "category": "AsyncUsage",
                "tags": [
                  "Telemetry"
                ]
              }
            },
            {
              "id": "AsyncFixer05",
              "shortDescription": {
                "text": "Downcasting from a nested task to an outer task."
              },
              "helpUri": "https://github.com/semihokur/AsyncFixer",
              "properties": {
                "category": "AsyncUsage",
                "tags": [
                  "Telemetry"
                ]
              }
            },
            {
              "id": "BL0001",
              "shortDescription": {
                "text": "Component parameter should have public setters."
              },
              "fullDescription": {
                "text": "Component parameters should have public setters."
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Encapsulation"
              }
            },
            {
              "id": "BL0002",
              "shortDescription": {
                "text": "Component has multiple CaptureUnmatchedValues parameters"
              },
              "fullDescription": {
                "text": "Components may only define a single parameter with CaptureUnmatchedValues."
              },
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "BL0003",
              "shortDescription": {
                "text": "Component parameter with CaptureUnmatchedValues has the wrong type"
              },
              "fullDescription": {
                "text": "Component parameters with CaptureUnmatchedValues must be a correct type."
              },
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "BL0004",
              "shortDescription": {
                "text": "Component parameter should be public."
              },
              "fullDescription": {
                "text": "Component parameters should be public."
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Encapsulation"
              }
            },
            {
              "id": "BL0005",
              "shortDescription": {
                "text": "Component parameter should not be set outside of its component."
              },
              "fullDescription": {
                "text": "Component parameters should not be set outside of their declared component. Doing so may result in unexpected behavior at runtime."
              },
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "BL0006",
              "shortDescription": {
                "text": "Do not use RenderTree types"
              },
              "fullDescription": {
                "text": "The types in 'Microsoft.AspNetCore.Components.RenderTree' are not recommended for use outside of the Blazor framework. These  type definitions will change in future releases."
              },
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "BL0007",
              "shortDescription": {
                "text": "Component parameters should be auto properties"
              },
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "CA1000",
              "shortDescription": {
                "text": "Do not declare static members on generic types"
              },
              "fullDescription": {
                "text": "When a static member of a generic type is called, the type argument must be specified for the type. When a generic instance member that does not support inference is called, the type argument must be specified for the member. In these two cases, the syntax for specifying the type argument is different and easily confused."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1000",
              "properties": {
                "category": "Design",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1001",
              "shortDescription": {
                "text": "Types that own disposable fields should be disposable"
              },
              "fullDescription": {
                "text": "A class declares and implements an instance field that is a System.IDisposable type, and the class does not implement IDisposable. A class that declares an IDisposable field indirectly owns an unmanaged resource and should implement the IDisposable interface."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1001",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1002",
              "shortDescription": {
                "text": "Do not expose generic lists"
              },
              "fullDescription": {
                "text": "System.Collections.Generic.List<T> is a generic collection that's designed for performance and not inheritance. List<T> does not contain virtual members that make it easier to change the behavior of an inherited class."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1002",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1003",
              "shortDescription": {
                "text": "Use generic event handler instances"
              },
              "fullDescription": {
                "text": "A type contains a delegate that returns void, whose signature contains two parameters (the first an object and the second a type that is assignable to EventArgs), and the containing assembly targets Microsoft .NET Framework?2.0."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1003",
              "properties": {
                "category": "Design",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1005",
              "shortDescription": {
                "text": "Avoid excessive parameters on generic types"
              },
              "fullDescription": {
                "text": "The more type parameters a generic type contains, the more difficult it is to know and remember what each type parameter represents."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1005",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry"
                ]
              }
            },
            {
              "id": "CA1008",
              "shortDescription": {
                "text": "Enums should have zero value"
              },
              "fullDescription": {
                "text": "The default value of an uninitialized enumeration, just as other value types, is zero. A nonflags-attributed enumeration should define a member by using the value of zero so that the default value is a valid value of the enumeration. If an enumeration that has the FlagsAttribute attribute applied defines a zero-valued member, its name should be \"\"None\"\" to indicate that no values have been set in the enumeration."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1008",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "RuleRename"
                ]
              }
            },
            {
              "id": "CA1010",
              "shortDescription": {
                "text": "Generic interface should also be implemented"
              },
              "fullDescription": {
                "text": "To broaden the usability of a type, implement one of the generic interfaces. This is especially true for collections as they can then be used to populate generic collection types."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1010",
              "properties": {
                "category": "Design",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1012",
              "shortDescription": {
                "text": "Abstract types should not have public constructors"
              },
              "fullDescription": {
                "text": "Constructors on abstract types can be called only by derived types. Because public constructors create instances of a type, and you cannot create instances of an abstract type, an abstract type that has a public constructor is incorrectly designed."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1012",
              "properties": {
                "category": "Design",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1014",
              "shortDescription": {
                "text": "Mark assemblies with CLSCompliant"
              },
              "fullDescription": {
                "text": "The Common Language Specification (CLS) defines naming restrictions, data types, and rules to which assemblies must conform if they will be used across programming languages. Good design dictates that all assemblies explicitly indicate CLS compliance by using CLSCompliantAttribute . If this attribute is not present on an assembly, the assembly is not compliant."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1014",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA1016",
              "shortDescription": {
                "text": "Mark assemblies with assembly version"
              },
              "fullDescription": {
                "text": "The .NET Framework uses the version number to uniquely identify an assembly, and to bind to types in strongly named assemblies. The version number is used together with version and publisher policy. By default, applications run only with the assembly version with which they were built."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1016",
              "properties": {
                "category": "Design",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA1017",
              "shortDescription": {
                "text": "Mark assemblies with ComVisible"
              },
              "fullDescription": {
                "text": "ComVisibleAttribute determines how COM clients access managed code. Good design dictates that assemblies explicitly indicate COM visibility. COM visibility can be set for the whole assembly and then overridden for individual types and type members. If this attribute is not present, the contents of the assembly are visible to COM clients."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1017",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA1018",
              "shortDescription": {
                "text": "Mark attributes with AttributeUsageAttribute"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1018",
              "properties": {
                "category": "Design",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1019",
              "shortDescription": {
                "text": "Define accessors for attribute arguments"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1019",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1021",
              "shortDescription": {
                "text": "Avoid out parameters"
              },
              "fullDescription": {
                "text": "Passing types by reference (using 'out' or 'ref') requires experience with pointers, understanding how value types and reference types differ, and handling methods with multiple return values. Also, the difference between 'out' and 'ref' parameters is not widely understood."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1021",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry"
                ]
              }
            },
            {
              "id": "CA1024",
              "shortDescription": {
                "text": "Use properties where appropriate"
              },
              "fullDescription": {
                "text": "A public or protected method has a name that starts with \"\"Get\"\", takes no parameters, and returns a value that is not an array. The method might be a good candidate to become a property."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1024",
              "properties": {
                "category": "Design",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1027",
              "shortDescription": {
                "text": "Mark enums with FlagsAttribute"
              },
              "fullDescription": {
                "text": "An enumeration is a value type that defines a set of related named constants. Apply FlagsAttribute to an enumeration when its named constants can be meaningfully combined."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1027",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1028",
              "shortDescription": {
                "text": "Enum Storage should be Int32"
              },
              "fullDescription": {
                "text": "An enumeration is a value type that defines a set of related named constants. By default, the System.Int32 data type is used to store the constant value. Although you can change this underlying type, it is not required or recommended for most scenarios."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1028",
              "properties": {
                "category": "Design",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1030",
              "shortDescription": {
                "text": "Use events where appropriate"
              },
              "fullDescription": {
                "text": "This rule detects methods that have names that ordinarily would be used for events. If a method is called in response to a clearly defined state change, the method should be invoked by an event handler. Objects that call the method should raise events instead of calling the method directly."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1030",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1031",
              "shortDescription": {
                "text": "Do not catch general exception types"
              },
              "fullDescription": {
                "text": "A general exception such as System.Exception or System.SystemException or a disallowed exception type is caught in a catch statement, or a general catch clause is used. General and disallowed exceptions should not be caught."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1031",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1032",
              "shortDescription": {
                "text": "Implement standard exception constructors"
              },
              "fullDescription": {
                "text": "Failure to provide the full set of constructors can make it difficult to correctly handle exceptions."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1032",
              "properties": {
                "category": "Design",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1033",
              "shortDescription": {
                "text": "Interface methods should be callable by child types"
              },
              "fullDescription": {
                "text": "An unsealed externally visible type provides an explicit method implementation of a public interface and does not provide an alternative externally visible method that has the same name."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1033",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1034",
              "shortDescription": {
                "text": "Nested types should not be visible"
              },
              "fullDescription": {
                "text": "A nested type is a type that is declared in the scope of another type. Nested types are useful to encapsulate private implementation details of the containing type. Used for this purpose, nested types should not be externally visible."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1034",
              "properties": {
                "category": "Design",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1036",
              "shortDescription": {
                "text": "Override methods on comparable types"
              },
              "fullDescription": {
                "text": "A public or protected type implements the System.IComparable interface. It does not override Object.Equals nor does it overload the language-specific operator for equality, inequality, less than, less than or equal, greater than or greater than or equal."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1036",
              "properties": {
                "category": "Design",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1040",
              "shortDescription": {
                "text": "Avoid empty interfaces"
              },
              "fullDescription": {
                "text": "Interfaces define members that provide a behavior or usage contract. The functionality that is described by the interface can be adopted by any type, regardless of where the type appears in the inheritance hierarchy. A type implements an interface by providing implementations for the members of the interface. An empty interface does not define any members; therefore, it does not define a contract that can be implemented."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1040",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1041",
              "shortDescription": {
                "text": "Provide ObsoleteAttribute message"
              },
              "fullDescription": {
                "text": "A type or member is marked by using a System.ObsoleteAttribute attribute that does not have its ObsoleteAttribute.Message property specified. When a type or member that is marked by using ObsoleteAttribute is compiled, the Message property of the attribute is displayed. This gives the user information about the obsolete type or member."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1041",
              "properties": {
                "category": "Design",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1043",
              "shortDescription": {
                "text": "Use Integral Or String Argument For Indexers"
              },
              "fullDescription": {
                "text": "Indexers, that is, indexed properties, should use integer or string types for the index. These types are typically used for indexing data structures and increase the usability of the library. Use of the Object type should be restricted to those cases where the specific integer or string type cannot be specified at design time. If the design requires other types for the index, reconsider whether the type represents a logical data store. If it does not represent a logical data store, use a method."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1043",
              "properties": {
                "category": "Design",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1044",
              "shortDescription": {
                "text": "Properties should not be write only"
              },
              "fullDescription": {
                "text": "Although it is acceptable and often necessary to have a read-only property, the design guidelines prohibit the use of write-only properties. This is because letting a user set a value, and then preventing the user from viewing that value, does not provide any security. Also, without read access, the state of shared objects cannot be viewed, which limits their usefulness."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1044",
              "properties": {
                "category": "Design",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1045",
              "shortDescription": {
                "text": "Do not pass types by reference"
              },
              "fullDescription": {
                "text": "Passing types by reference (using out or ref) requires experience with pointers, understanding how value types and reference types differ, and handling methods that have multiple return values. Also, the difference between out and ref parameters is not widely understood."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1045",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry"
                ]
              }
            },
            {
              "id": "CA1046",
              "shortDescription": {
                "text": "Do not overload equality operator on reference types"
              },
              "fullDescription": {
                "text": "For reference types, the default implementation of the equality operator is almost always correct. By default, two references are equal only if they point to the same object. If the operator is providing meaningful value equality, the type should implement the generic 'System.IEquatable' interface."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1046",
              "properties": {
                "category": "Design",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1050",
              "shortDescription": {
                "text": "Declare types in namespaces"
              },
              "fullDescription": {
                "text": "Types are declared in namespaces to prevent name collisions and as a way to organize related types in an object hierarchy."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1050",
              "properties": {
                "category": "Design",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1051",
              "shortDescription": {
                "text": "Do not declare visible instance fields"
              },
              "fullDescription": {
                "text": "The primary use of a field should be as an implementation detail. Fields should be private or internal and should be exposed by using properties."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1051",
              "properties": {
                "category": "Design",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1052",
              "shortDescription": {
                "text": "Static holder types should be Static or NotInheritable"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1052",
              "properties": {
                "category": "Design",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1054",
              "shortDescription": {
                "text": "URI-like parameters should not be strings"
              },
              "fullDescription": {
                "text": "This rule assumes that the parameter represents a Uniform Resource Identifier (URI). A string representation or a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities. 'System.Uri' class provides these services in a safe and secure manner."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1054",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1055",
              "shortDescription": {
                "text": "URI-like return values should not be strings"
              },
              "fullDescription": {
                "text": "This rule assumes that the method returns a URI. A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities. The System.Uri class provides these services in a safe and secure manner."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1055",
              "properties": {
                "category": "Design",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1056",
              "shortDescription": {
                "text": "URI-like properties should not be strings"
              },
              "fullDescription": {
                "text": "This rule assumes that the property represents a Uniform Resource Identifier (URI). A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities. The System.Uri class provides these services in a safe and secure manner."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1056",
              "properties": {
                "category": "Design",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1058",
              "shortDescription": {
                "text": "Types should not extend certain base types"
              },
              "fullDescription": {
                "text": "An externally visible type extends certain base types. Use one of the alternatives."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1058",
              "properties": {
                "category": "Design",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1060",
              "shortDescription": {
                "text": "Move pinvokes to native methods class"
              },
              "fullDescription": {
                "text": "Platform Invocation methods, such as those that are marked by using the System.Runtime.InteropServices.DllImportAttribute attribute, or methods that are defined by using the Declare keyword in Visual Basic, access unmanaged code. These methods should be of the NativeMethods, SafeNativeMethods, or UnsafeNativeMethods class."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1060",
              "properties": {
                "category": "Design",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry"
                ]
              }
            },
            {
              "id": "CA1061",
              "shortDescription": {
                "text": "Do not hide base class methods"
              },
              "fullDescription": {
                "text": "A method in a base type is hidden by an identically named method in a derived type when the parameter signature of the derived method differs only by types that are more weakly derived than the corresponding types in the parameter signature of the base method."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1061",
              "properties": {
                "category": "Design",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1062",
              "shortDescription": {
                "text": "Validate arguments of public methods"
              },
              "fullDescription": {
                "text": "An externally visible method dereferences one of its reference arguments without verifying whether that argument is null (Nothing in Visual Basic). All reference arguments that are passed to externally visible methods should be checked against null. If appropriate, throw an ArgumentNullException when the argument is null or add a Code Contract precondition asserting non-null argument. If the method is designed to be called only by known assemblies, you should make the method internal."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1062",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "PortedFromFxCop",
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1063",
              "shortDescription": {
                "text": "Implement IDisposable Correctly"
              },
              "fullDescription": {
                "text": "All IDisposable types should implement the Dispose pattern correctly."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1063",
              "properties": {
                "category": "Design",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1064",
              "shortDescription": {
                "text": "Exceptions should be public"
              },
              "fullDescription": {
                "text": "An internal exception is visible only inside its own internal scope. After the exception falls outside the internal scope, only the base exception can be used to catch the exception. If the internal exception is inherited from T:System.Exception, T:System.SystemException, or T:System.ApplicationException, the external code will not have sufficient information to know what to do with the exception."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1064",
              "properties": {
                "category": "Design",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1065",
              "shortDescription": {
                "text": "Do not raise exceptions in unexpected locations"
              },
              "fullDescription": {
                "text": "A method that is not expected to throw exceptions throws an exception."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1065",
              "properties": {
                "category": "Design",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1066",
              "shortDescription": {
                "text": "Implement IEquatable when overriding Object.Equals"
              },
              "fullDescription": {
                "text": "When a type T overrides Object.Equals(object), the implementation must cast the object argument to the correct type T before performing the comparison. If the type implements IEquatable<T>, and therefore offers the method T.Equals(T), and if the argument is known at compile time to be of type T, then the compiler can call IEquatable<T>.Equals(T) instead of Object.Equals(object), and no cast is necessary, improving performance."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1066",
              "properties": {
                "category": "Design",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1067",
              "shortDescription": {
                "text": "Override Object.Equals(object) when implementing IEquatable<T>"
              },
              "fullDescription": {
                "text": "When a type T implements the interface IEquatable<T>, it suggests to a user who sees a call to the Equals method in source code that an instance of the type can be equated with an instance of any other type. The user might be confused if their attempt to equate the type with an instance of another type fails to compile. This violates the \"principle of least surprise\"."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1067",
              "properties": {
                "category": "Design",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1068",
              "shortDescription": {
                "text": "CancellationToken parameters must come last"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1068",
              "properties": {
                "category": "Design",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1069",
              "shortDescription": {
                "text": "Enums values should not be duplicated"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1069",
              "properties": {
                "category": "Design",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1070",
              "shortDescription": {
                "text": "Do not declare event fields as virtual"
              },
              "fullDescription": {
                "text": "Do not declare virtual events in a base class. Overridden events in a derived class have undefined behavior. The C# compiler does not handle this correctly and it is unpredictable whether a subscriber to the derived event will actually be subscribing to the base class event."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1070",
              "properties": {
                "category": "Design",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1200",
              "shortDescription": {
                "text": "Avoid using cref tags with a prefix"
              },
              "fullDescription": {
                "text": "Use of cref tags with prefixes should be avoided, since it prevents the compiler from verifying references and the IDE from updating references during refactorings. It is permissible to suppress this error at a single documentation site if the cref must use a prefix because the type being mentioned is not findable by the compiler. For example, if a cref is mentioning a special attribute in the full framework but you're in a file that compiles against the portable framework, or if you want to reference a type at higher layer of Roslyn, you should suppress the error. You should not suppress the error just because you want to take a shortcut and avoid using the full syntax."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1200",
              "properties": {
                "category": "Documentation",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1303",
              "shortDescription": {
                "text": "Do not pass literals as localized parameters"
              },
              "fullDescription": {
                "text": "A method passes a string literal as a parameter to a constructor or method in the .NET Framework class library and that string should be localizable. To fix a violation of this rule, replace the string literal with a string retrieved through an instance of the ResourceManager class."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1303",
              "properties": {
                "category": "Globalization",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "PortedFromFxCop",
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1304",
              "shortDescription": {
                "text": "Specify CultureInfo"
              },
              "fullDescription": {
                "text": "A method or constructor calls a member that has an overload that accepts a System.Globalization.CultureInfo parameter, and the method or constructor does not call the overload that takes the CultureInfo parameter. When a CultureInfo or System.IFormatProvider object is not supplied, the default value that is supplied by the overloaded member might not have the effect that you want in all locales. If the result will be displayed to the user, specify 'CultureInfo.CurrentCulture' as the 'CultureInfo' parameter. Otherwise, if the result will be stored and accessed by software, such as when it is persisted to disk or to a database, specify 'CultureInfo.InvariantCulture'."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1304",
              "properties": {
                "category": "Globalization",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1305",
              "shortDescription": {
                "text": "Specify IFormatProvider"
              },
              "fullDescription": {
                "text": "A method or constructor calls one or more members that have overloads that accept a System.IFormatProvider parameter, and the method or constructor does not call the overload that takes the IFormatProvider parameter. When a System.Globalization.CultureInfo or IFormatProvider object is not supplied, the default value that is supplied by the overloaded member might not have the effect that you want in all locales. If the result will be based on the input from/output displayed to the user, specify 'CultureInfo.CurrentCulture' as the 'IFormatProvider'. Otherwise, if the result will be stored and accessed by software, such as when it is loaded from disk/database and when it is persisted to disk/database, specify 'CultureInfo.InvariantCulture'."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1305",
              "properties": {
                "category": "Globalization",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1307",
              "shortDescription": {
                "text": "Specify StringComparison for clarity"
              },
              "fullDescription": {
                "text": "A string comparison operation uses a method overload that does not set a StringComparison parameter. It is recommended to use the overload with StringComparison parameter for clarity of intent. If the result will be displayed to the user, such as when sorting a list of items for display in a list box, specify 'StringComparison.CurrentCulture' or 'StringComparison.CurrentCultureIgnoreCase' as the 'StringComparison' parameter. If comparing case-insensitive identifiers, such as file paths, environment variables, or registry keys and values, specify 'StringComparison.OrdinalIgnoreCase'. Otherwise, if comparing case-sensitive identifiers, specify 'StringComparison.Ordinal'."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1307",
              "properties": {
                "category": "Globalization",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1308",
              "shortDescription": {
                "text": "Normalize strings to uppercase"
              },
              "fullDescription": {
                "text": "Strings should be normalized to uppercase. A small group of characters cannot make a round trip when they are converted to lowercase. To make a round trip means to convert the characters from one locale to another locale that represents character data differently, and then to accurately retrieve the original characters from the converted characters."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1308",
              "properties": {
                "category": "Globalization",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1309",
              "shortDescription": {
                "text": "Use ordinal string comparison"
              },
              "fullDescription": {
                "text": "A string comparison operation that is nonlinguistic does not set the StringComparison parameter to either Ordinal or OrdinalIgnoreCase. By explicitly setting the parameter to either StringComparison.Ordinal or StringComparison.OrdinalIgnoreCase, your code often gains speed, becomes more correct, and becomes more reliable."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1309",
              "properties": {
                "category": "Globalization",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1310",
              "shortDescription": {
                "text": "Specify StringComparison for correctness"
              },
              "fullDescription": {
                "text": "A string comparison operation uses a method overload that does not set a StringComparison parameter, hence its behavior could vary based on the current user's locale settings. It is strongly recommended to use the overload with StringComparison parameter for correctness and clarity of intent. If the result will be displayed to the user, such as when sorting a list of items for display in a list box, specify 'StringComparison.CurrentCulture' or 'StringComparison.CurrentCultureIgnoreCase' as the 'StringComparison' parameter. If comparing case-insensitive identifiers, such as file paths, environment variables, or registry keys and values, specify 'StringComparison.OrdinalIgnoreCase'. Otherwise, if comparing case-sensitive identifiers, specify 'StringComparison.Ordinal'."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1310",
              "properties": {
                "category": "Globalization",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1311",
              "shortDescription": {
                "text": "Specify a culture or use an invariant version"
              },
              "fullDescription": {
                "text": "Specify culture to help avoid accidental implicit dependency on current culture. Using an invariant version yields consistent results regardless of the culture of an application."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1311",
              "properties": {
                "category": "Globalization",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1401",
              "shortDescription": {
                "text": "P/Invokes should not be visible"
              },
              "fullDescription": {
                "text": "A public or protected method in a public type has the System.Runtime.InteropServices.DllImportAttribute attribute (also implemented by the Declare keyword in Visual Basic). Such methods should not be exposed."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1401",
              "properties": {
                "category": "Interoperability",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1416",
              "shortDescription": {
                "text": "Validate platform compatibility"
              },
              "fullDescription": {
                "text": "Using platform dependent API on a component makes the code no longer work across all platforms."
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1416",
              "properties": {
                "category": "Interoperability",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1417",
              "shortDescription": {
                "text": "Do not use 'OutAttribute' on string parameters for P/Invokes"
              },
              "fullDescription": {
                "text": "String parameters passed by value with the 'OutAttribute' can destabilize the runtime if the string is an interned string."
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1417",
              "properties": {
                "category": "Interoperability",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1418",
              "shortDescription": {
                "text": "Use valid platform string"
              },
              "fullDescription": {
                "text": "Platform compatibility analyzer requires a valid platform name and version."
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1418",
              "properties": {
                "category": "Interoperability",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1419",
              "shortDescription": {
                "text": "Provide a parameterless constructor that is as visible as the containing type for concrete types derived from 'System.Runtime.InteropServices.SafeHandle'"
              },
              "fullDescription": {
                "text": "Providing a parameterless constructor that is as visible as the containing type for a type derived from 'System.Runtime.InteropServices.SafeHandle' enables better performance and usage with source-generated interop solutions."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1419",
              "properties": {
                "category": "Interoperability",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1420",
              "shortDescription": {
                "text": "Property, type, or attribute requires runtime marshalling"
              },
              "fullDescription": {
                "text": "Using features that require runtime marshalling when runtime marshalling is disabled will result in runtime exceptions."
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1420",
              "properties": {
                "category": "Interoperability",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1421",
              "shortDescription": {
                "text": "This method uses runtime marshalling even when the 'DisableRuntimeMarshallingAttribute' is applied"
              },
              "fullDescription": {
                "text": "This method uses runtime marshalling even when runtime marshalling is disabled, which can cause unexpected behavior differences at runtime due to different expectations of a type's native layout."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1421",
              "properties": {
                "category": "Interoperability",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1422",
              "shortDescription": {
                "text": "Validate platform compatibility"
              },
              "fullDescription": {
                "text": "Using platform dependent API on a component makes the code no longer work across all platforms."
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1422",
              "properties": {
                "category": "Interoperability",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1501",
              "shortDescription": {
                "text": "Avoid excessive inheritance"
              },
              "fullDescription": {
                "text": "Deeply nested type hierarchies can be difficult to follow, understand, and maintain. This rule limits analysis to hierarchies in the same module. To fix a violation of this rule, derive the type from a base type that is less deep in the inheritance hierarchy or eliminate some of the intermediate base types."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1501",
              "properties": {
                "category": "Maintainability",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA1502",
              "shortDescription": {
                "text": "Avoid excessive complexity"
              },
              "fullDescription": {
                "text": "Cyclomatic complexity measures the number of linearly independent paths through the method, which is determined by the number and complexity of conditional branches. A low cyclomatic complexity generally indicates a method that is easy to understand, test, and maintain. The cyclomatic complexity is calculated from a control flow graph of the method and is given as follows: `cyclomatic complexity = the number of edges - the number of nodes + 1`, where a node represents a logic branch point and an edge represents a line between nodes."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1502",
              "properties": {
                "category": "Maintainability",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA1505",
              "shortDescription": {
                "text": "Avoid unmaintainable code"
              },
              "fullDescription": {
                "text": "The maintainability index is calculated by using the following metrics: lines of code, program volume, and cyclomatic complexity. Program volume is a measure of the difficulty of understanding of a symbol that is based on the number of operators and operands in the code. Cyclomatic complexity is a measure of the structural complexity of the type or method. A low maintainability index indicates that code is probably difficult to maintain and would be a good candidate to redesign."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1505",
              "properties": {
                "category": "Maintainability",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA1506",
              "shortDescription": {
                "text": "Avoid excessive class coupling"
              },
              "fullDescription": {
                "text": "This rule measures class coupling by counting the number of unique type references that a symbol contains. Symbols that have a high degree of class coupling can be difficult to maintain. It is a good practice to have types and methods that exhibit low coupling and high cohesion. To fix this violation, try to redesign the code to reduce the number of types to which it is coupled."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1506",
              "properties": {
                "category": "Maintainability",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA1507",
              "shortDescription": {
                "text": "Use nameof to express symbol names"
              },
              "fullDescription": {
                "text": "Using nameof helps keep your code valid when refactoring."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1507",
              "properties": {
                "category": "Maintainability",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1508",
              "shortDescription": {
                "text": "Avoid dead conditional code"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1508",
              "properties": {
                "category": "Maintainability",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1509",
              "shortDescription": {
                "text": "Invalid entry in code metrics rule specification file"
              },
              "fullDescription": {
                "text": "Invalid entry in code metrics rule specification file."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1509",
              "properties": {
                "category": "Maintainability",
                "tags": [
                  "Telemetry",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA1700",
              "shortDescription": {
                "text": "Do not name enum values 'Reserved'"
              },
              "fullDescription": {
                "text": "This rule assumes that an enumeration member that has a name that contains \"reserved\" is not currently used but is a placeholder to be renamed or removed in a future version. Renaming or removing a member is a breaking change."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1700",
              "properties": {
                "category": "Naming",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1707",
              "shortDescription": {
                "text": "Identifiers should not contain underscores"
              },
              "fullDescription": {
                "text": "By convention, identifier names do not contain the underscore (_) character. This rule checks namespaces, types, members, and parameters."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1707",
              "properties": {
                "category": "Naming",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1708",
              "shortDescription": {
                "text": "Identifiers should differ by more than case"
              },
              "fullDescription": {
                "text": "Identifiers for namespaces, types, members, and parameters cannot differ only by case because languages that target the common language runtime are not required to be case-sensitive."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1708",
              "properties": {
                "category": "Naming",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1710",
              "shortDescription": {
                "text": "Identifiers should have correct suffix"
              },
              "fullDescription": {
                "text": "By convention, the names of types that extend certain base types or that implement certain interfaces, or types that are derived from these types, have a suffix that is associated with the base type or interface."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1710",
              "properties": {
                "category": "Naming",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1711",
              "shortDescription": {
                "text": "Identifiers should not have incorrect suffix"
              },
              "fullDescription": {
                "text": "By convention, only the names of types that extend certain base types or that implement certain interfaces, or types that are derived from these types, should end with specific reserved suffixes. Other type names should not use these reserved suffixes."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1711",
              "properties": {
                "category": "Naming",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1712",
              "shortDescription": {
                "text": "Do not prefix enum values with type name"
              },
              "fullDescription": {
                "text": "An enumeration's values should not start with the type name of the enumeration."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1712",
              "properties": {
                "category": "Naming",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1713",
              "shortDescription": {
                "text": "Events should not have 'Before' or 'After' prefix"
              },
              "fullDescription": {
                "text": "Event names should describe the action that raises the event. To name related events that are raised in a specific sequence, use the present or past tense to indicate the relative position in the sequence of actions. For example, when naming a pair of events that is raised when closing a resource, you might name it 'Closing' and 'Closed', instead of 'BeforeClose' and 'AfterClose'."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1713",
              "properties": {
                "category": "Naming",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1715",
              "shortDescription": {
                "text": "Identifiers should have correct prefix"
              },
              "fullDescription": {
                "text": "The name of an externally visible interface does not start with an uppercase \"\"I\"\". The name of a generic type parameter on an externally visible type or method does not start with an uppercase \"\"T\"\"."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1715",
              "properties": {
                "category": "Naming",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1716",
              "shortDescription": {
                "text": "Identifiers should not match keywords"
              },
              "fullDescription": {
                "text": "A namespace name or a type name matches a reserved keyword in a programming language. Identifiers for namespaces and types should not match keywords that are defined by languages that target the common language runtime."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1716",
              "properties": {
                "category": "Naming",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1720",
              "shortDescription": {
                "text": "Identifier contains type name"
              },
              "fullDescription": {
                "text": "Names of parameters and members are better used to communicate their meaning than to describe their type, which is expected to be provided by development tools. For names of members, if a data type name must be used, use a language-independent name instead of a language-specific one."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1720",
              "properties": {
                "category": "Naming",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1721",
              "shortDescription": {
                "text": "Property names should not match get methods"
              },
              "fullDescription": {
                "text": "The name of a public or protected member starts with \"\"Get\"\" and otherwise matches the name of a public or protected property. \"\"Get\"\" methods and properties should have names that clearly distinguish their function."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1721",
              "properties": {
                "category": "Naming",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1724",
              "shortDescription": {
                "text": "Type names should not match namespaces"
              },
              "fullDescription": {
                "text": "Type names should not match the names of namespaces that are defined in the .NET Framework class library. Violating this rule can reduce the usability of the library."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1724",
              "properties": {
                "category": "Naming",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA1725",
              "shortDescription": {
                "text": "Parameter names should match base declaration"
              },
              "fullDescription": {
                "text": "Consistent naming of parameters in an override hierarchy increases the usability of the method overrides. A parameter name in a derived method that differs from the name in the base declaration can cause confusion about whether the method is an override of the base method or a new overload of the method."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1725",
              "properties": {
                "category": "Naming",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1727",
              "shortDescription": {
                "text": "Use PascalCase for named placeholders"
              },
              "fullDescription": {
                "text": "Use PascalCase for named placeholders in the logging message template."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1727",
              "properties": {
                "category": "Naming",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1802",
              "shortDescription": {
                "text": "Use literals where appropriate"
              },
              "fullDescription": {
                "text": "A field is declared static and read-only (Shared and ReadOnly in Visual Basic), and is initialized by using a value that is computable at compile time. Because the value that is assigned to the targeted field is computable at compile time, change the declaration to a const (Const in Visual Basic) field so that the value is computed at compile time instead of at run?time."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1802",
              "properties": {
                "category": "Performance",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1805",
              "shortDescription": {
                "text": "Do not initialize unnecessarily"
              },
              "fullDescription": {
                "text": "The .NET runtime initializes all fields of reference types to their default values before running the constructor. In most cases, explicitly initializing a field to its default value in a constructor is redundant, adding maintenance costs and potentially degrading performance (such as with increased assembly size), and the explicit initialization can be removed.  In some cases, such as with static readonly fields that permanently retain their default value, consider instead changing them to be constants or properties."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1805",
              "properties": {
                "category": "Performance",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1806",
              "shortDescription": {
                "text": "Do not ignore method results"
              },
              "fullDescription": {
                "text": "A new object is created but never used; or a method that creates and returns a new string is called and the new string is never used; or a COM or P/Invoke method returns an HRESULT or error code that is never used."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1806",
              "properties": {
                "category": "Performance",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1810",
              "shortDescription": {
                "text": "Initialize reference type static fields inline"
              },
              "fullDescription": {
                "text": "A reference type declares an explicit static constructor. To fix a violation of this rule, initialize all static data when it is declared and remove the static constructor."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1810",
              "properties": {
                "category": "Performance",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1812",
              "shortDescription": {
                "text": "Avoid uninstantiated internal classes"
              },
              "fullDescription": {
                "text": "An instance of an assembly-level type is not created by code in the assembly."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1812",
              "properties": {
                "category": "Performance",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA1813",
              "shortDescription": {
                "text": "Avoid unsealed attributes"
              },
              "fullDescription": {
                "text": "The .NET Framework class library provides methods for retrieving custom attributes. By default, these methods search the attribute inheritance hierarchy. Sealing the attribute eliminates the search through the inheritance hierarchy and can improve performance."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1813",
              "properties": {
                "category": "Performance",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1814",
              "shortDescription": {
                "text": "Prefer jagged arrays over multidimensional"
              },
              "fullDescription": {
                "text": "A jagged array is an array whose elements are arrays. The arrays that make up the elements can be of different sizes, leading to less wasted space for some sets of data."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1814",
              "properties": {
                "category": "Performance",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1815",
              "shortDescription": {
                "text": "Override equals and operator equals on value types"
              },
              "fullDescription": {
                "text": "For value types, the inherited implementation of Equals uses the Reflection library and compares the contents of all fields. Reflection is computationally expensive, and comparing every field for equality might be unnecessary. If you expect users to compare or sort instances, or to use instances as hash table keys, your value type should implement Equals."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1815",
              "properties": {
                "category": "Performance",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1816",
              "shortDescription": {
                "text": "Dispose methods should call SuppressFinalize"
              },
              "fullDescription": {
                "text": "A method that is an implementation of Dispose does not call GC.SuppressFinalize; or a method that is not an implementation of Dispose calls GC.SuppressFinalize; or a method calls GC.SuppressFinalize and passes something other than this (Me in Visual Basic)."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1816",
              "properties": {
                "category": "Usage",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1819",
              "shortDescription": {
                "text": "Properties should not return arrays"
              },
              "fullDescription": {
                "text": "Arrays that are returned by properties are not write-protected, even when the property is read-only. To keep the array tamper-proof, the property must return a copy of the array. Typically, users will not understand the adverse performance implications of calling such a property."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1819",
              "properties": {
                "category": "Performance",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1820",
              "shortDescription": {
                "text": "Test for empty strings using string length"
              },
              "fullDescription": {
                "text": "Comparing strings by using the String.Length property or the String.IsNullOrEmpty method is significantly faster than using Equals."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1820",
              "properties": {
                "category": "Performance",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1821",
              "shortDescription": {
                "text": "Remove empty Finalizers"
              },
              "fullDescription": {
                "text": "Finalizers should be avoided where possible, to avoid the additional performance overhead involved in tracking object lifetime."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1821",
              "properties": {
                "category": "Performance",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1822",
              "shortDescription": {
                "text": "Mark members as static"
              },
              "fullDescription": {
                "text": "Members that do not access instance data or call instance methods can be marked as static. After you mark the methods as static, the compiler will emit nonvirtual call sites to these members. This can give you a measurable performance gain for performance-sensitive code."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1822",
              "properties": {
                "category": "Performance",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1823",
              "shortDescription": {
                "text": "Avoid unused private fields"
              },
              "fullDescription": {
                "text": "Private fields were detected that do not appear to be accessed in the assembly."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1823",
              "properties": {
                "category": "Performance",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1824",
              "shortDescription": {
                "text": "Mark assemblies with NeutralResourcesLanguageAttribute"
              },
              "fullDescription": {
                "text": "The NeutralResourcesLanguage attribute informs the ResourceManager of the language that was used to display the resources of a neutral culture for an assembly. This improves lookup performance for the first resource that you load and can reduce your working set."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1824",
              "properties": {
                "category": "Performance",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA1825",
              "shortDescription": {
                "text": "Avoid zero-length array allocations"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1825",
              "properties": {
                "category": "Performance",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1826",
              "shortDescription": {
                "text": "Do not use Enumerable methods on indexable collections"
              },
              "fullDescription": {
                "text": "This collection is directly indexable. Going through LINQ here causes unnecessary allocations and CPU work."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1826",
              "properties": {
                "category": "Performance",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1827",
              "shortDescription": {
                "text": "Do not use Count() or LongCount() when Any() can be used"
              },
              "fullDescription": {
                "text": "For non-empty collections, Count() and LongCount() enumerate the entire sequence, while Any() stops at the first item or the first item that satisfies a condition."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1827",
              "properties": {
                "category": "Performance",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1828",
              "shortDescription": {
                "text": "Do not use CountAsync() or LongCountAsync() when AnyAsync() can be used"
              },
              "fullDescription": {
                "text": "For non-empty collections, CountAsync() and LongCountAsync() enumerate the entire sequence, while AnyAsync() stops at the first item or the first item that satisfies a condition."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1828",
              "properties": {
                "category": "Performance",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1829",
              "shortDescription": {
                "text": "Use Length/Count property instead of Count() when available"
              },
              "fullDescription": {
                "text": "Enumerable.Count() potentially enumerates the sequence while a Length/Count property is a direct access."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1829",
              "properties": {
                "category": "Performance",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1830",
              "shortDescription": {
                "text": "Prefer strongly-typed Append and Insert method overloads on StringBuilder"
              },
              "fullDescription": {
                "text": "StringBuilder.Append and StringBuilder.Insert provide overloads for multiple types beyond System.String.  When possible, prefer the strongly-typed overloads over using ToString() and the string-based overload."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1830",
              "properties": {
                "category": "Performance",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1831",
              "shortDescription": {
                "text": "Use AsSpan or AsMemory instead of Range-based indexers when appropriate"
              },
              "fullDescription": {
                "text": "The Range-based indexer on string values produces a copy of requested portion of the string. This copy is usually unnecessary when it is implicitly used as a ReadOnlySpan or ReadOnlyMemory value. Use the AsSpan method to avoid the unnecessary copy."
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1831",
              "properties": {
                "category": "Performance",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1832",
              "shortDescription": {
                "text": "Use AsSpan or AsMemory instead of Range-based indexers when appropriate"
              },
              "fullDescription": {
                "text": "The Range-based indexer on array values produces a copy of requested portion of the array. This copy is usually unnecessary when it is implicitly used as a ReadOnlySpan or ReadOnlyMemory value. Use the AsSpan method to avoid the unnecessary copy."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1832",
              "properties": {
                "category": "Performance",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1833",
              "shortDescription": {
                "text": "Use AsSpan or AsMemory instead of Range-based indexers when appropriate"
              },
              "fullDescription": {
                "text": "The Range-based indexer on array values produces a copy of requested portion of the array. This copy is often unwanted when it is implicitly used as a Span or Memory value. Use the AsSpan method to avoid the copy."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1833",
              "properties": {
                "category": "Performance",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1834",
              "shortDescription": {
                "text": "Consider using 'StringBuilder.Append(char)' when applicable"
              },
              "fullDescription": {
                "text": "'StringBuilder.Append(char)' is more efficient than 'StringBuilder.Append(string)' when the string is a single character. When calling 'Append' with a constant, prefer using a constant char rather than a constant string containing one character."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1834",
              "properties": {
                "category": "Performance",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1835",
              "shortDescription": {
                "text": "Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'"
              },
              "fullDescription": {
                "text": "'Stream' has a 'ReadAsync' overload that takes a 'Memory<Byte>' as the first argument, and a 'WriteAsync' overload that takes a 'ReadOnlyMemory<Byte>' as the first argument. Prefer calling the memory based overloads, which are more efficient."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1835",
              "properties": {
                "category": "Performance",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1836",
              "shortDescription": {
                "text": "Prefer IsEmpty over Count"
              },
              "fullDescription": {
                "text": "For determining whether the object contains or not any items, prefer using 'IsEmpty' property rather than retrieving the number of items from the 'Count' property and comparing it to 0 or 1."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1836",
              "properties": {
                "category": "Performance",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1837",
              "shortDescription": {
                "text": "Use 'Environment.ProcessId'"
              },
              "fullDescription": {
                "text": "'Environment.ProcessId' is simpler and faster than 'Process.GetCurrentProcess().Id'."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1837",
              "properties": {
                "category": "Performance",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1838",
              "shortDescription": {
                "text": "Avoid 'StringBuilder' parameters for P/Invokes"
              },
              "fullDescription": {
                "text": "Marshalling of 'StringBuilder' always creates a native buffer copy, resulting in multiple allocations for one marshalling operation."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1838",
              "properties": {
                "category": "Performance",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1839",
              "shortDescription": {
                "text": "Use 'Environment.ProcessPath'"
              },
              "fullDescription": {
                "text": "'Environment.ProcessPath' is simpler and faster than 'Process.GetCurrentProcess().MainModule.FileName'."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1839",
              "properties": {
                "category": "Performance",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1840",
              "shortDescription": {
                "text": "Use 'Environment.CurrentManagedThreadId'"
              },
              "fullDescription": {
                "text": "'Environment.CurrentManagedThreadId' is simpler and faster than 'Thread.CurrentThread.ManagedThreadId'."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1840",
              "properties": {
                "category": "Performance",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1841",
              "shortDescription": {
                "text": "Prefer Dictionary.Contains methods"
              },
              "fullDescription": {
                "text": "'ContainsKey' is usually O(1), while 'Keys.Contains' may be O(n) in some cases. Additionally, many dictionary implementations lazily initialize the Keys collection to cut back on allocations."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1841",
              "properties": {
                "category": "Performance",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1842",
              "shortDescription": {
                "text": "Do not use 'WhenAll' with a single task"
              },
              "fullDescription": {
                "text": "Using 'WhenAll' with a single task may result in performance loss, await or return the task instead."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1842",
              "properties": {
                "category": "Performance",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1843",
              "shortDescription": {
                "text": "Do not use 'WaitAll' with a single task"
              },
              "fullDescription": {
                "text": "Using 'WaitAll' with a single task may result in performance loss, await or return the task instead."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1843",
              "properties": {
                "category": "Performance",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1844",
              "shortDescription": {
                "text": "Provide memory-based overrides of async methods when subclassing 'Stream'"
              },
              "fullDescription": {
                "text": "To improve performance, override the memory-based async methods when subclassing 'Stream'. Then implement the array-based methods in terms of the memory-based methods."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1844",
              "properties": {
                "category": "Performance",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1845",
              "shortDescription": {
                "text": "Use span-based 'string.Concat'"
              },
              "fullDescription": {
                "text": "It is more efficient to use 'AsSpan' and 'string.Concat', instead of 'Substring' and a concatenation operator."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1845",
              "properties": {
                "category": "Performance",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1846",
              "shortDescription": {
                "text": "Prefer 'AsSpan' over 'Substring'"
              },
              "fullDescription": {
                "text": "'AsSpan' is more efficient then 'Substring'. 'Substring' performs an O(n) string copy, while 'AsSpan' does not and has a constant cost."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1846",
              "properties": {
                "category": "Performance",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1847",
              "shortDescription": {
                "text": "Use char literal for a single character lookup"
              },
              "fullDescription": {
                "text": "'string.Contains(char)' is available as a better performing overload for single char lookup."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1847",
              "properties": {
                "category": "Performance",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1848",
              "shortDescription": {
                "text": "Use the LoggerMessage delegates"
              },
              "fullDescription": {
                "text": "For improved performance, use the LoggerMessage delegates."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1848",
              "properties": {
                "category": "Performance",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1849",
              "shortDescription": {
                "text": "Call async methods when in an async method"
              },
              "fullDescription": {
                "text": "When inside a Task-returning method, use the async version of methods, if they exist."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1849",
              "properties": {
                "category": "Performance",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1850",
              "shortDescription": {
                "text": "Prefer static 'HashData' method over 'ComputeHash'"
              },
              "fullDescription": {
                "text": "It is more efficient to use the static 'HashData' method over creating and managing a HashAlgorithm instance to call 'ComputeHash'."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1850",
              "properties": {
                "category": "Performance",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1851",
              "shortDescription": {
                "text": "Possible multiple enumerations of 'IEnumerable' collection"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1851",
              "properties": {
                "category": "Performance",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1852",
              "shortDescription": {
                "text": "Seal internal types"
              },
              "fullDescription": {
                "text": "When a type is not accessible outside its assembly and has no subtypes within its containing assembly, it can be safely sealed. Sealing types can improve performance."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1852",
              "properties": {
                "category": "Performance",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA1853",
              "shortDescription": {
                "text": "Unnecessary call to 'Dictionary.ContainsKey(key)'"
              },
              "fullDescription": {
                "text": "Do not guard 'Dictionary.Remove(key)' with 'Dictionary.ContainsKey(key)'. The former already checks whether the key exists, and will not throw if it does not."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1853",
              "properties": {
                "category": "Performance",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1854",
              "shortDescription": {
                "text": "Prefer the 'IDictionary.TryGetValue(TKey, out TValue)' method"
              },
              "fullDescription": {
                "text": "Prefer a 'TryGetValue' call over a Dictionary indexer access guarded by a 'ContainsKey' check. 'ContainsKey' and the indexer both would lookup the key under the hood, so using 'TryGetValue' removes the extra lookup."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1854",
              "properties": {
                "category": "Performance",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1855",
              "shortDescription": {
                "text": "Prefer 'Clear' over 'Fill'"
              },
              "fullDescription": {
                "text": "It is more efficient to use 'Clear', instead of 'Fill' with default value."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1855",
              "properties": {
                "category": "Performance",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2000",
              "shortDescription": {
                "text": "Dispose objects before losing scope"
              },
              "fullDescription": {
                "text": "If a disposable object is not explicitly disposed before all references to it are out of scope, the object will be disposed at some indeterminate time when the garbage collector runs the finalizer of the object. Because an exceptional event might occur that will prevent the finalizer of the object from running, the object should be explicitly disposed instead."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2000",
              "properties": {
                "category": "Reliability",
                "tags": [
                  "PortedFromFxCop",
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2002",
              "shortDescription": {
                "text": "Do not lock on objects with weak identity"
              },
              "fullDescription": {
                "text": "An object is said to have a weak identity when it can be directly accessed across application domain boundaries. A thread that tries to acquire a lock on an object that has a weak identity can be blocked by a second thread in a different application domain that has a lock on the same object."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2002",
              "properties": {
                "category": "Reliability",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2007",
              "shortDescription": {
                "text": "Consider calling ConfigureAwait on the awaited task"
              },
              "fullDescription": {
                "text": "When an asynchronous method awaits a Task directly, continuation occurs in the same thread that created the task. Consider calling Task.ConfigureAwait(Boolean) to signal your intention for continuation. Call ConfigureAwait(false) on the task to schedule continuations to the thread pool, thereby avoiding a deadlock on the UI thread. Passing false is a good option for app-independent libraries. Calling ConfigureAwait(true) on the task has the same behavior as not explicitly calling ConfigureAwait. By explicitly calling this method, you're letting readers know you intentionally want to perform the continuation on the original synchronization context."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2007",
              "properties": {
                "category": "Reliability",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2008",
              "shortDescription": {
                "text": "Do not create tasks without passing a TaskScheduler"
              },
              "fullDescription": {
                "text": "Do not create tasks unless you are using one of the overloads that takes a TaskScheduler. The default is to schedule on TaskScheduler.Current, which would lead to deadlocks. Either use TaskScheduler.Default to schedule on the thread pool, or explicitly pass TaskScheduler.Current to make your intentions clear."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2008",
              "properties": {
                "category": "Reliability",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2009",
              "shortDescription": {
                "text": "Do not call ToImmutableCollection on an ImmutableCollection value"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2009",
              "properties": {
                "category": "Reliability",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2011",
              "shortDescription": {
                "text": "Avoid infinite recursion"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2011",
              "properties": {
                "category": "Reliability",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2012",
              "shortDescription": {
                "text": "Use ValueTasks correctly"
              },
              "fullDescription": {
                "text": "ValueTasks returned from member invocations are intended to be directly awaited.  Attempts to consume a ValueTask multiple times or to directly access one's result before it's known to be completed may result in an exception or corruption.  Ignoring such a ValueTask is likely an indication of a functional bug and may degrade performance."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2012",
              "properties": {
                "category": "Reliability",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2013",
              "shortDescription": {
                "text": "Do not use ReferenceEquals with value types"
              },
              "fullDescription": {
                "text": "Value type typed arguments are uniquely boxed for each call to this method, therefore the result is always false."
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2013",
              "properties": {
                "category": "Reliability",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2014",
              "shortDescription": {
                "text": "Do not use stackalloc in loops"
              },
              "fullDescription": {
                "text": "Stack space allocated by a stackalloc is only released at the end of the current method's invocation.  Using it in a loop can result in unbounded stack growth and eventual stack overflow conditions."
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2014",
              "properties": {
                "category": "Reliability",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2015",
              "shortDescription": {
                "text": "Do not define finalizers for types derived from MemoryManager<T>"
              },
              "fullDescription": {
                "text": "Adding a finalizer to a type derived from MemoryManager<T> may permit memory to be freed while it is still in use by a Span<T>."
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2015",
              "properties": {
                "category": "Reliability",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2016",
              "shortDescription": {
                "text": "Forward the 'CancellationToken' parameter to methods"
              },
              "fullDescription": {
                "text": "Forward the 'CancellationToken' parameter to methods to ensure the operation cancellation notifications gets properly propagated, or pass in 'CancellationToken.None' explicitly to indicate intentionally not propagating the token."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2016",
              "properties": {
                "category": "Reliability",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2017",
              "shortDescription": {
                "text": "Parameter count mismatch"
              },
              "fullDescription": {
                "text": "Number of parameters supplied in the logging message template do not match the number of named placeholders."
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2017",
              "properties": {
                "category": "Reliability",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2018",
              "shortDescription": {
                "text": "'Buffer.BlockCopy' expects the number of bytes to be copied for the 'count' argument"
              },
              "fullDescription": {
                "text": "'Buffer.BlockCopy' expects the number of bytes to be copied for the 'count' argument. Using 'Array.Length' may not match the number of bytes that needs to be copied."
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2018",
              "properties": {
                "category": "Reliability",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2019",
              "shortDescription": {
                "text": "Improper 'ThreadStatic' field initialization"
              },
              "fullDescription": {
                "text": "'ThreadStatic' fields should be initialized lazily on use, not with inline initialization nor explicitly in a static constructor, which would only initialize the field on the thread that runs the type's static constructor."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2019",
              "properties": {
                "category": "Reliability",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2020",
              "shortDescription": {
                "text": "Prevent from behavioral change"
              },
              "fullDescription": {
                "text": "Some built in operators added in .NET 7 behave differently than the user defined operatorsi in .NET 6 and below. Some operators that used to throw in unchecked context while overflowing will not throw anymore unless wrapped within checked context, and some operators that not used to throw in checked context now would throw unless wrapped within unchecked context."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2020",
              "properties": {
                "category": "Reliability",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2100",
              "shortDescription": {
                "text": "Review SQL queries for security vulnerabilities"
              },
              "fullDescription": {
                "text": "SQL queries that directly use user input can be vulnerable to SQL injection attacks. Review this SQL query for potential vulnerabilities, and consider using a parameterized SQL query."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2100",
              "properties": {
                "category": "Security",
                "tags": [
                  "PortedFromFxCop",
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2101",
              "shortDescription": {
                "text": "Specify marshaling for P/Invoke string arguments"
              },
              "fullDescription": {
                "text": "A platform invoke member allows partially trusted callers, has a string parameter, and does not explicitly marshal the string. This can cause a potential security vulnerability."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2101",
              "properties": {
                "category": "Globalization",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2109",
              "shortDescription": {
                "text": "Review visible event handlers"
              },
              "fullDescription": {
                "text": "A public or protected event-handling method was detected. Event-handling methods should not be exposed unless absolutely necessary."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2109",
              "properties": {
                "category": "Security",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2119",
              "shortDescription": {
                "text": "Seal methods that satisfy private interfaces"
              },
              "fullDescription": {
                "text": "An inheritable public type provides an overridable method implementation of an internal (Friend in Visual Basic) interface. To fix a violation of this rule, prevent the method from being overridden outside the assembly."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2119",
              "properties": {
                "category": "Security",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2153",
              "shortDescription": {
                "text": "Do Not Catch Corrupted State Exceptions"
              },
              "fullDescription": {
                "text": "Catching corrupted state exceptions could mask errors (such as access violations), resulting in inconsistent state of execution or making it easier for attackers to compromise system. Instead, catch and handle a more specific set of exception type(s) or re-throw the exception."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2153",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2200",
              "shortDescription": {
                "text": "Rethrow to preserve stack details"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2200",
              "properties": {
                "category": "Usage",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2201",
              "shortDescription": {
                "text": "Do not raise reserved exception types"
              },
              "fullDescription": {
                "text": "An exception of type that is not sufficiently specific or reserved by the runtime should never be raised by user code. This makes the original error difficult to detect and debug. If this exception instance might be thrown, use a different exception type."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2201",
              "properties": {
                "category": "Usage",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2207",
              "shortDescription": {
                "text": "Initialize value type static fields inline"
              },
              "fullDescription": {
                "text": "A value type declares an explicit static constructor. To fix a violation of this rule, initialize all static data when it is declared and remove the static constructor."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2207",
              "properties": {
                "category": "Usage",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2208",
              "shortDescription": {
                "text": "Instantiate argument exceptions correctly"
              },
              "fullDescription": {
                "text": "A call is made to the default (parameterless) constructor of an exception type that is or derives from ArgumentException, or an incorrect string argument is passed to a parameterized constructor of an exception type that is or derives from ArgumentException."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2208",
              "properties": {
                "category": "Usage",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2211",
              "shortDescription": {
                "text": "Non-constant fields should not be visible"
              },
              "fullDescription": {
                "text": "Static fields that are neither constants nor read-only are not thread-safe. Access to such a field must be carefully controlled and requires advanced programming techniques to synchronize access to the class object."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2211",
              "properties": {
                "category": "Usage",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2213",
              "shortDescription": {
                "text": "Disposable fields should be disposed"
              },
              "fullDescription": {
                "text": "A type that implements System.IDisposable declares fields that are of types that also implement IDisposable. The Dispose method of the field is not called by the Dispose method of the declaring type. To fix a violation of this rule, call Dispose on fields that are of types that implement IDisposable if you are responsible for allocating and releasing the unmanaged resources held by the field."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2213",
              "properties": {
                "category": "Usage",
                "tags": [
                  "PortedFromFxCop",
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2214",
              "shortDescription": {
                "text": "Do not call overridable methods in constructors"
              },
              "fullDescription": {
                "text": "Virtual methods defined on the class should not be called from constructors. If a derived class has overridden the method, the derived class version will be called (before the derived class constructor is called)."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2214",
              "properties": {
                "category": "Usage",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2215",
              "shortDescription": {
                "text": "Dispose methods should call base class dispose"
              },
              "fullDescription": {
                "text": "A type that implements System.IDisposable inherits from a type that also implements IDisposable. The Dispose method of the inheriting type does not call the Dispose method of the parent type. To fix a violation of this rule, call base.Dispose in your Dispose method."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2215",
              "properties": {
                "category": "Usage",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2216",
              "shortDescription": {
                "text": "Disposable types should declare finalizer"
              },
              "fullDescription": {
                "text": "A type that implements System.IDisposable and has fields that suggest the use of unmanaged resources does not implement a finalizer, as described by Object.Finalize."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2216",
              "properties": {
                "category": "Usage",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2217",
              "shortDescription": {
                "text": "Do not mark enums with FlagsAttribute"
              },
              "fullDescription": {
                "text": "An externally visible enumeration is marked by using FlagsAttribute, and it has one or more values that are not powers of two or a combination of the other defined values on the enumeration."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2217",
              "properties": {
                "category": "Usage",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2219",
              "shortDescription": {
                "text": "Do not raise exceptions in finally clauses"
              },
              "fullDescription": {
                "text": "When an exception is raised in a finally clause, the new exception hides the active exception. This makes the original error difficult to detect and debug."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2219",
              "properties": {
                "category": "Usage",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2225",
              "shortDescription": {
                "text": "Operator overloads have named alternates"
              },
              "fullDescription": {
                "text": "An operator overload was detected, and the expected named alternative method was not found. The named alternative member provides access to the same functionality as the operator and is provided for developers who program in languages that do not support overloaded operators."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2225",
              "properties": {
                "category": "Usage",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2226",
              "shortDescription": {
                "text": "Operators should have symmetrical overloads"
              },
              "fullDescription": {
                "text": "A type implements the equality or inequality operator and does not implement the opposite operator."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2226",
              "properties": {
                "category": "Usage",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2227",
              "shortDescription": {
                "text": "Collection properties should be read only"
              },
              "fullDescription": {
                "text": "A writable collection property allows a user to replace the collection with a different collection. A read-only property stops the collection from being replaced but still allows the individual members to be set."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2227",
              "properties": {
                "category": "Usage",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2229",
              "shortDescription": {
                "text": "Implement serialization constructors"
              },
              "fullDescription": {
                "text": "To fix a violation of this rule, implement the serialization constructor. For a sealed class, make the constructor private; otherwise, make it protected."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2229",
              "properties": {
                "category": "Usage",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2231",
              "shortDescription": {
                "text": "Overload operator equals on overriding value type Equals"
              },
              "fullDescription": {
                "text": "In most programming languages there is no default implementation of the equality operator (==) for value types. If your programming language supports operator overloads, you should consider implementing the equality operator. Its behavior should be identical to that of Equals."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2231",
              "properties": {
                "category": "Usage",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2234",
              "shortDescription": {
                "text": "Pass system uri objects instead of strings"
              },
              "fullDescription": {
                "text": "A call is made to a method that has a string parameter whose name contains \"uri\", \"URI\", \"urn\", \"URN\", \"url\", or \"URL\". The declaring type of the method contains a corresponding method overload that has a System.Uri parameter."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2234",
              "properties": {
                "category": "Usage",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2235",
              "shortDescription": {
                "text": "Mark all non-serializable fields"
              },
              "fullDescription": {
                "text": "An instance field of a type that is not serializable is declared in a type that is serializable."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2235",
              "properties": {
                "category": "Usage",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2237",
              "shortDescription": {
                "text": "Mark ISerializable types with serializable"
              },
              "fullDescription": {
                "text": "To be recognized by the common language runtime as serializable, types must be marked by using the SerializableAttribute attribute even when the type uses a custom serialization routine through implementation of the ISerializable interface."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2237",
              "properties": {
                "category": "Usage",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2241",
              "shortDescription": {
                "text": "Provide correct arguments to formatting methods"
              },
              "fullDescription": {
                "text": "The format argument that is passed to System.String.Format does not contain a format item that corresponds to each object argument, or vice versa."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2241",
              "properties": {
                "category": "Usage",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2242",
              "shortDescription": {
                "text": "Test for NaN correctly"
              },
              "fullDescription": {
                "text": "This expression tests a value against Single.Nan or Double.Nan. Use Single.IsNan(Single) or Double.IsNan(Double) to test the value."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2242",
              "properties": {
                "category": "Usage",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2243",
              "shortDescription": {
                "text": "Attribute string literals should parse correctly"
              },
              "fullDescription": {
                "text": "The string literal parameter of an attribute does not parse correctly for a URL, a GUID, or a version."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2243",
              "properties": {
                "category": "Usage",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2244",
              "shortDescription": {
                "text": "Do not duplicate indexed element initializations"
              },
              "fullDescription": {
                "text": "Indexed elements in objects initializers must initialize unique elements. A duplicate index might overwrite a previous element initialization."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2244",
              "properties": {
                "category": "Usage",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2245",
              "shortDescription": {
                "text": "Do not assign a property to itself"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2245",
              "properties": {
                "category": "Usage",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2246",
              "shortDescription": {
                "text": "Assigning symbol and its member in the same statement"
              },
              "fullDescription": {
                "text": "Assigning to a symbol and its member (field/property) in the same statement is not recommended. It is not clear if the member access was intended to use symbol's old value prior to the assignment or new value from the assignment in this statement. For clarity, consider splitting the assignments into separate statements."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2246",
              "properties": {
                "category": "Usage",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2247",
              "shortDescription": {
                "text": "Argument passed to TaskCompletionSource constructor should be TaskCreationOptions enum instead of TaskContinuationOptions enum"
              },
              "fullDescription": {
                "text": "TaskCompletionSource has constructors that take TaskCreationOptions that control the underlying Task, and constructors that take object state that's stored in the task.  Accidentally passing a TaskContinuationOptions instead of a TaskCreationOptions will result in the call treating the options as state."
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2247",
              "properties": {
                "category": "Usage",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2248",
              "shortDescription": {
                "text": "Provide correct 'enum' argument to 'Enum.HasFlag'"
              },
              "fullDescription": {
                "text": "'Enum.HasFlag' method expects the 'enum' argument to be of the same 'enum' type as the instance on which the method is invoked and that this 'enum' is marked with 'System.FlagsAttribute'. If these are different 'enum' types, an unhandled exception will be thrown at runtime. If the 'enum' type is not marked with 'System.FlagsAttribute' the call will always return 'false' at runtime."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2248",
              "properties": {
                "category": "Usage",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2249",
              "shortDescription": {
                "text": "Consider using 'string.Contains' instead of 'string.IndexOf'"
              },
              "fullDescription": {
                "text": "Calls to 'string.IndexOf' where the result is used to check for the presence/absence of a substring can be replaced by 'string.Contains'."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2249",
              "properties": {
                "category": "Usage",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2250",
              "shortDescription": {
                "text": "Use 'ThrowIfCancellationRequested'"
              },
              "fullDescription": {
                "text": "'ThrowIfCancellationRequested' automatically checks whether the token has been canceled, and throws an 'OperationCanceledException' if it has."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2250",
              "properties": {
                "category": "Usage",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2251",
              "shortDescription": {
                "text": "Use 'string.Equals'"
              },
              "fullDescription": {
                "text": "It is both clearer and likely faster to use 'string.Equals' instead of comparing the result of 'string.Compare' to zero."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2251",
              "properties": {
                "category": "Usage",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2252",
              "shortDescription": {
                "text": "This API requires opting into preview features"
              },
              "fullDescription": {
                "text": "An assembly has to opt into preview features before using them."
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2252",
              "properties": {
                "category": "Usage",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2253",
              "shortDescription": {
                "text": "Named placeholders should not be numeric values"
              },
              "fullDescription": {
                "text": "Named placeholders in the logging message template should not be comprised of only numeric characters."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2253",
              "properties": {
                "category": "Usage",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2254",
              "shortDescription": {
                "text": "Template should be a static expression"
              },
              "fullDescription": {
                "text": "The logging message template should not vary between calls."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2254",
              "properties": {
                "category": "Usage",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2255",
              "shortDescription": {
                "text": "The 'ModuleInitializer' attribute should not be used in libraries"
              },
              "fullDescription": {
                "text": "Module initializers are intended to be used by application code to ensure an application's components are initialized before the application code begins executing. If library code declares a method with the 'ModuleInitializerAttribute', it can interfere with application initialization and also lead to limitations in that application's trimming abilities. Instead of using methods marked with 'ModuleInitializerAttribute', the library should expose methods that can be used to initialize any components within the library and allow the application to invoke the method during application initialization."
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2255",
              "properties": {
                "category": "Usage",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2256",
              "shortDescription": {
                "text": "All members declared in parent interfaces must have an implementation in a DynamicInterfaceCastableImplementation-attributed interface"
              },
              "fullDescription": {
                "text": "Types attributed with 'DynamicInterfaceCastableImplementationAttribute' act as an interface implementation for a type that implements the 'IDynamicInterfaceCastable' type. As a result, it must provide an implementation of all of the members defined in the inherited interfaces, because the type that implements 'IDynamicInterfaceCastable' will not provide them otherwise."
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2256",
              "properties": {
                "category": "Usage",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2257",
              "shortDescription": {
                "text": "Members defined on an interface with the 'DynamicInterfaceCastableImplementationAttribute' should be 'static'"
              },
              "fullDescription": {
                "text": "Since a type that implements 'IDynamicInterfaceCastable' may not implement a dynamic interface in metadata, calls to an instance interface member that is not an explicit implementation defined on this type are likely to fail at runtime. Mark new interface members 'static' to avoid runtime errors."
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2257",
              "properties": {
                "category": "Usage",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2258",
              "shortDescription": {
                "text": "Providing a 'DynamicInterfaceCastableImplementation' interface in Visual Basic is unsupported"
              },
              "fullDescription": {
                "text": "Providing a functional 'DynamicInterfaceCastableImplementationAttribute'-attributed interface requires the Default Interface Members feature, which is unsupported in Visual Basic."
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2258",
              "properties": {
                "category": "Usage",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2259",
              "shortDescription": {
                "text": "'ThreadStatic' only affects static fields"
              },
              "fullDescription": {
                "text": "'ThreadStatic' only affects static fields. When applied to instance fields, it has no impact on behavior."
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2259",
              "properties": {
                "category": "Usage",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2260",
              "shortDescription": {
                "text": "Use correct type parameter"
              },
              "fullDescription": {
                "text": "Generic math interfaces require the derived type itself to be used for the self recurring type parameter."
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2260",
              "properties": {
                "category": "Usage",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2300",
              "shortDescription": {
                "text": "Do not use insecure deserializer BinaryFormatter"
              },
              "fullDescription": {
                "text": "The method '{0}' is insecure when deserializing untrusted data.  If you need to instead detect BinaryFormatter deserialization without a SerializationBinder set, then disable rule CA2300, and enable rules CA2301 and CA2302."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2300",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2301",
              "shortDescription": {
                "text": "Do not call BinaryFormatter.Deserialize without first setting BinaryFormatter.Binder"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2301",
              "properties": {
                "category": "Security",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA2302",
              "shortDescription": {
                "text": "Ensure BinaryFormatter.Binder is set before calling BinaryFormatter.Deserialize"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2302",
              "properties": {
                "category": "Security",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA2305",
              "shortDescription": {
                "text": "Do not use insecure deserializer LosFormatter"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2305",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2310",
              "shortDescription": {
                "text": "Do not use insecure deserializer NetDataContractSerializer"
              },
              "fullDescription": {
                "text": "The method '{0}' is insecure when deserializing untrusted data.  If you need to instead detect NetDataContractSerializer deserialization without a SerializationBinder set, then disable rule CA2310, and enable rules CA2311 and CA2312."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2310",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2311",
              "shortDescription": {
                "text": "Do not deserialize without first setting NetDataContractSerializer.Binder"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2311",
              "properties": {
                "category": "Security",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA2312",
              "shortDescription": {
                "text": "Ensure NetDataContractSerializer.Binder is set before deserializing"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2312",
              "properties": {
                "category": "Security",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA2315",
              "shortDescription": {
                "text": "Do not use insecure deserializer ObjectStateFormatter"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2315",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2321",
              "shortDescription": {
                "text": "Do not deserialize with JavaScriptSerializer using a SimpleTypeResolver"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2321",
              "properties": {
                "category": "Security",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA2322",
              "shortDescription": {
                "text": "Ensure JavaScriptSerializer is not initialized with SimpleTypeResolver before deserializing"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2322",
              "properties": {
                "category": "Security",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA2326",
              "shortDescription": {
                "text": "Do not use TypeNameHandling values other than None"
              },
              "fullDescription": {
                "text": "Deserializing JSON when using a TypeNameHandling value other than None can be insecure.  If you need to instead detect Json.NET deserialization when a SerializationBinder isn't specified, then disable rule CA2326, and enable rules CA2327, CA2328, CA2329, and CA2330."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2326",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2327",
              "shortDescription": {
                "text": "Do not use insecure JsonSerializerSettings"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2327",
              "properties": {
                "category": "Security",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA2328",
              "shortDescription": {
                "text": "Ensure that JsonSerializerSettings are secure"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2328",
              "properties": {
                "category": "Security",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA2329",
              "shortDescription": {
                "text": "Do not deserialize with JsonSerializer using an insecure configuration"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2329",
              "properties": {
                "category": "Security",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA2330",
              "shortDescription": {
                "text": "Ensure that JsonSerializer has a secure configuration when deserializing"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2330",
              "properties": {
                "category": "Security",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA2350",
              "shortDescription": {
                "text": "Do not use DataTable.ReadXml() with untrusted data"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2350",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2351",
              "shortDescription": {
                "text": "Do not use DataSet.ReadXml() with untrusted data"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2351",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2352",
              "shortDescription": {
                "text": "Unsafe DataSet or DataTable in serializable type can be vulnerable to remote code execution attacks"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2352",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2353",
              "shortDescription": {
                "text": "Unsafe DataSet or DataTable in serializable type"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2353",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2354",
              "shortDescription": {
                "text": "Unsafe DataSet or DataTable in deserialized object graph can be vulnerable to remote code execution attacks"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2354",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2355",
              "shortDescription": {
                "text": "Unsafe DataSet or DataTable type found in deserializable object graph"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2355",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2356",
              "shortDescription": {
                "text": "Unsafe DataSet or DataTable type in web deserializable object graph"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2356",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2361",
              "shortDescription": {
                "text": "Ensure auto-generated class containing DataSet.ReadXml() is not used with untrusted data"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2361",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2362",
              "shortDescription": {
                "text": "Unsafe DataSet or DataTable in auto-generated serializable type can be vulnerable to remote code execution attacks"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2362",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA3001",
              "shortDescription": {
                "text": "Review code for SQL injection vulnerabilities"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca3001",
              "properties": {
                "category": "Security",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA3002",
              "shortDescription": {
                "text": "Review code for XSS vulnerabilities"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca3002",
              "properties": {
                "category": "Security",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA3003",
              "shortDescription": {
                "text": "Review code for file path injection vulnerabilities"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca3003",
              "properties": {
                "category": "Security",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA3004",
              "shortDescription": {
                "text": "Review code for information disclosure vulnerabilities"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca3004",
              "properties": {
                "category": "Security",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA3005",
              "shortDescription": {
                "text": "Review code for LDAP injection vulnerabilities"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca3005",
              "properties": {
                "category": "Security",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA3006",
              "shortDescription": {
                "text": "Review code for process command injection vulnerabilities"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca3006",
              "properties": {
                "category": "Security",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA3007",
              "shortDescription": {
                "text": "Review code for open redirect vulnerabilities"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca3007",
              "properties": {
                "category": "Security",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA3008",
              "shortDescription": {
                "text": "Review code for XPath injection vulnerabilities"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca3008",
              "properties": {
                "category": "Security",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA3009",
              "shortDescription": {
                "text": "Review code for XML injection vulnerabilities"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca3009",
              "properties": {
                "category": "Security",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA3010",
              "shortDescription": {
                "text": "Review code for XAML injection vulnerabilities"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca3010",
              "properties": {
                "category": "Security",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA3011",
              "shortDescription": {
                "text": "Review code for DLL injection vulnerabilities"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca3011",
              "properties": {
                "category": "Security",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA3012",
              "shortDescription": {
                "text": "Review code for regex injection vulnerabilities"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca3012",
              "properties": {
                "category": "Security",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA3061",
              "shortDescription": {
                "text": "Do Not Add Schema By URL"
              },
              "fullDescription": {
                "text": "This overload of XmlSchemaCollection.Add method internally enables DTD processing on the XML reader instance used, and uses UrlResolver for resolving external XML entities. The outcome is information disclosure. Content from file system or network shares for the machine processing the XML can be exposed to attacker. In addition, an attacker can use this as a DoS vector."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca3061",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA3075",
              "shortDescription": {
                "text": "Insecure DTD processing in XML"
              },
              "fullDescription": {
                "text": "Using XmlTextReader.Load(), creating an insecure XmlReaderSettings instance when invoking XmlReader.Create(), setting the InnerXml property of the XmlDocument and enabling DTD processing using XmlUrlResolver insecurely can lead to information disclosure. Replace it with a call to the Load() method overload that takes an XmlReader instance, use XmlReader.Create() to accept XmlReaderSettings arguments or consider explicitly setting secure values. The DataViewSettingCollectionString property of DataViewManager should always be assigned from a trusted source, the DtdProcessing property should be set to false, and the XmlResolver property should be changed to XmlSecureResolver or null."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca3075",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA3076",
              "shortDescription": {
                "text": "Insecure XSLT script processing"
              },
              "fullDescription": {
                "text": "Providing an insecure XsltSettings instance and an insecure XmlResolver instance to XslCompiledTransform.Load method is potentially unsafe as it allows processing script within XSL, which on an untrusted XSL input may lead to malicious code execution. Either replace the insecure XsltSettings argument with XsltSettings.Default or an instance that has disabled document function and script execution, or replace the XmlResolver argument with null or an XmlSecureResolver instance. This message may be suppressed if the input is known to be from a trusted source and external resource resolution from locations that are not known in advance must be supported."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca3076",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA3077",
              "shortDescription": {
                "text": "Insecure Processing in API Design, XmlDocument and XmlTextReader"
              },
              "fullDescription": {
                "text": "Enabling DTD processing on all instances derived from XmlTextReader or  XmlDocument and using XmlUrlResolver for resolving external XML entities may lead to information disclosure. Ensure to set the XmlResolver property to null, create an instance of XmlSecureResolver when processing untrusted input, or use XmlReader.Create method with a secure XmlReaderSettings argument. Unless you need to enable it, ensure the DtdProcessing property is set to false."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca3077",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA3147",
              "shortDescription": {
                "text": "Mark Verb Handlers With Validate Antiforgery Token"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca3147",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5350",
              "shortDescription": {
                "text": "Do Not Use Weak Cryptographic Algorithms"
              },
              "fullDescription": {
                "text": "Cryptographic algorithms degrade over time as attacks become for advances to attacker get access to more computation. Depending on the type and application of this cryptographic algorithm, further degradation of the cryptographic strength of it may allow attackers to read enciphered messages, tamper with enciphered  messages, forge digital signatures, tamper with hashed content, or otherwise compromise any cryptosystem based on this algorithm. Replace encryption uses with the AES algorithm (AES-256, AES-192 and AES-128 are acceptable) with a key length greater than or equal to 128 bits. Replace hashing uses with a hashing function in the SHA-2 family, such as SHA-2 512, SHA-2 384, or SHA-2 256."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5350",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5351",
              "shortDescription": {
                "text": "Do Not Use Broken Cryptographic Algorithms"
              },
              "fullDescription": {
                "text": "An attack making it computationally feasible to break this algorithm exists. This allows attackers to break the cryptographic guarantees it is designed to provide. Depending on the type and application of this cryptographic algorithm, this may allow attackers to read enciphered messages, tamper with enciphered  messages, forge digital signatures, tamper with hashed content, or otherwise compromise any cryptosystem based on this algorithm. Replace encryption uses with the AES algorithm (AES-256, AES-192 and AES-128 are acceptable) with a key length greater than or equal to 128 bits. Replace hashing uses with a hashing function in the SHA-2 family, such as SHA512, SHA384, or SHA256. Replace digital signature uses with RSA with a key length greater than or equal to 2048-bits, or ECDSA with a key length greater than or equal to 256 bits."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5351",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5358",
              "shortDescription": {
                "text": "Review cipher mode usage with cryptography experts"
              },
              "fullDescription": {
                "text": "These cipher modes might be vulnerable to attacks. Consider using recommended modes (CBC, CTS)."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5358",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5359",
              "shortDescription": {
                "text": "Do Not Disable Certificate Validation"
              },
              "fullDescription": {
                "text": "A certificate can help authenticate the identity of the server. Clients should validate the server certificate to ensure requests are sent to the intended server. If the ServerCertificateValidationCallback always returns 'true', any certificate will pass validation."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5359",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5360",
              "shortDescription": {
                "text": "Do Not Call Dangerous Methods In Deserialization"
              },
              "fullDescription": {
                "text": "Insecure Deserialization is a vulnerability which occurs when untrusted data is used to abuse the logic of an application, inflict a Denial-of-Service (DoS) attack, or even execute arbitrary code upon it being deserialized. It’s frequently possible for malicious users to abuse these deserialization features when the application is deserializing untrusted data which is under their control. Specifically, invoke dangerous methods in the process of deserialization. Successful insecure deserialization attacks could allow an attacker to carry out attacks such as DoS attacks, authentication bypasses, and remote code execution."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5360",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA5361",
              "shortDescription": {
                "text": "Do Not Disable SChannel Use of Strong Crypto"
              },
              "fullDescription": {
                "text": "Starting with the .NET Framework 4.6, the System.Net.ServicePointManager and System.Net.Security.SslStream classes are recommended to use new protocols. The old ones have protocol weaknesses and are not supported. Setting Switch.System.Net.DontEnableSchUseStrongCrypto with true will use the old weak crypto check and opt out of the protocol migration."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5361",
              "properties": {
                "category": "Security",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5362",
              "shortDescription": {
                "text": "Potential reference cycle in deserialized object graph"
              },
              "fullDescription": {
                "text": "Review code that processes untrusted deserialized data for handling of unexpected reference cycles. An unexpected reference cycle should not cause the code to enter an infinite loop. Otherwise, an unexpected reference cycle can allow an attacker to DOS or exhaust the memory of the process when deserializing untrusted data."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5362",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA5363",
              "shortDescription": {
                "text": "Do Not Disable Request Validation"
              },
              "fullDescription": {
                "text": "Request validation is a feature in ASP.NET that examines HTTP requests and determines whether they contain potentially dangerous content. This check adds protection from markup or code in the URL query string, cookies, or posted form values that might have been added for malicious purposes. So, it is generally desirable and should be left enabled for defense in depth."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5363",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5364",
              "shortDescription": {
                "text": "Do Not Use Deprecated Security Protocols"
              },
              "fullDescription": {
                "text": "Using a deprecated security protocol rather than the system default is risky."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5364",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5365",
              "shortDescription": {
                "text": "Do Not Disable HTTP Header Checking"
              },
              "fullDescription": {
                "text": "HTTP header checking enables encoding of the carriage return and newline characters, \\r and \\n, that are found in response headers. This encoding can help to avoid injection attacks that exploit an application that echoes untrusted data contained by the header."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5365",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5366",
              "shortDescription": {
                "text": "Use XmlReader for 'DataSet.ReadXml()'"
              },
              "fullDescription": {
                "text": "Processing XML from untrusted data may load dangerous external references, which should be restricted by using an XmlReader with a secure resolver or with DTD processing disabled."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5366",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5367",
              "shortDescription": {
                "text": "Do Not Serialize Types With Pointer Fields"
              },
              "fullDescription": {
                "text": "Pointers are not \"type safe\" in the sense that you cannot guarantee the correctness of the memory they point at. So, serializing types with pointer fields is dangerous, as it may allow an attacker to control the pointer."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5367",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA5368",
              "shortDescription": {
                "text": "Set ViewStateUserKey For Classes Derived From Page"
              },
              "fullDescription": {
                "text": "Setting the ViewStateUserKey property can help you prevent attacks on your application by allowing you to assign an identifier to the view-state variable for individual users so that they cannot use the variable to generate an attack. Otherwise, there will be cross-site request forgery vulnerabilities."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5368",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5369",
              "shortDescription": {
                "text": "Use XmlReader for 'XmlSerializer.Deserialize()'"
              },
              "fullDescription": {
                "text": "Processing XML from untrusted data may load dangerous external references, which should be restricted by using an XmlReader with a secure resolver or with DTD processing disabled."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5369",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5370",
              "shortDescription": {
                "text": "Use XmlReader for XmlValidatingReader constructor"
              },
              "fullDescription": {
                "text": "Processing XML from untrusted data may load dangerous external references, which should be restricted by using an XmlReader with a secure resolver or with DTD processing disabled."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5370",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5371",
              "shortDescription": {
                "text": "Use XmlReader for 'XmlSchema.Read()'"
              },
              "fullDescription": {
                "text": "Processing XML from untrusted data may load dangerous external references, which should be restricted by using an XmlReader with a secure resolver or with DTD processing disabled."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5371",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5372",
              "shortDescription": {
                "text": "Use XmlReader for XPathDocument constructor"
              },
              "fullDescription": {
                "text": "Processing XML from untrusted data may load dangerous external references, which should be restricted by using an XmlReader with a secure resolver or with DTD processing disabled."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5372",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5373",
              "shortDescription": {
                "text": "Do not use obsolete key derivation function"
              },
              "fullDescription": {
                "text": "Password-based key derivation should use PBKDF2 with SHA-2. Avoid using PasswordDeriveBytes since it generates a PBKDF1 key. Avoid using Rfc2898DeriveBytes.CryptDeriveKey since it doesn't use the iteration count or salt."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5373",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5374",
              "shortDescription": {
                "text": "Do Not Use XslTransform"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5374",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5375",
              "shortDescription": {
                "text": "Do Not Use Account Shared Access Signature"
              },
              "fullDescription": {
                "text": "Shared Access Signatures(SAS) are a vital part of the security model for any application using Azure Storage, they should provide limited and safe permissions to your storage account to clients that don't have the account key. All of the operations available via a service SAS are also available via an account SAS, that is, account SAS is too powerful. So it is recommended to use Service SAS to delegate access more carefully."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5375",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5376",
              "shortDescription": {
                "text": "Use SharedAccessProtocol HttpsOnly"
              },
              "fullDescription": {
                "text": "HTTPS encrypts network traffic. Use HttpsOnly, rather than HttpOrHttps, to ensure network traffic is always encrypted to help prevent disclosure of sensitive data."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5376",
              "properties": {
                "category": "Security",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5377",
              "shortDescription": {
                "text": "Use Container Level Access Policy"
              },
              "fullDescription": {
                "text": "No access policy identifier is specified, making tokens non-revocable."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5377",
              "properties": {
                "category": "Security",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5378",
              "shortDescription": {
                "text": "Do not disable ServicePointManagerSecurityProtocols"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5378",
              "properties": {
                "category": "Security",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5379",
              "shortDescription": {
                "text": "Ensure Key Derivation Function algorithm is sufficiently strong"
              },
              "fullDescription": {
                "text": "Some implementations of the Rfc2898DeriveBytes class allow for a hash algorithm to be specified in a constructor parameter or overwritten in the HashAlgorithm property. If a hash algorithm is specified, then it should be SHA-256 or higher."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5379",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5380",
              "shortDescription": {
                "text": "Do Not Add Certificates To Root Store"
              },
              "fullDescription": {
                "text": "By default, the Trusted Root Certification Authorities certificate store is configured with a set of public CAs that has met the requirements of the Microsoft Root Certificate Program. Since all trusted root CAs can issue certificates for any domain, an attacker can pick a weak or coercible CA that you install by yourself to target for an attack - and a single vulnerable, malicious or coercible CA undermines the security of the entire system. To make matters worse, these attacks can go unnoticed quite easily."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5380",
              "properties": {
                "category": "Security",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA5381",
              "shortDescription": {
                "text": "Ensure Certificates Are Not Added To Root Store"
              },
              "fullDescription": {
                "text": "By default, the Trusted Root Certification Authorities certificate store is configured with a set of public CAs that has met the requirements of the Microsoft Root Certificate Program. Since all trusted root CAs can issue certificates for any domain, an attacker can pick a weak or coercible CA that you install by yourself to target for an attack - and a single vulnerable, malicious or coercible CA undermines the security of the entire system. To make matters worse, these attacks can go unnoticed quite easily."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5381",
              "properties": {
                "category": "Security",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA5382",
              "shortDescription": {
                "text": "Use Secure Cookies In ASP.NET Core"
              },
              "fullDescription": {
                "text": "Applications available over HTTPS must use secure cookies."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5382",
              "properties": {
                "category": "Security",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA5383",
              "shortDescription": {
                "text": "Ensure Use Secure Cookies In ASP.NET Core"
              },
              "fullDescription": {
                "text": "Applications available over HTTPS must use secure cookies."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5383",
              "properties": {
                "category": "Security",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA5384",
              "shortDescription": {
                "text": "Do Not Use Digital Signature Algorithm (DSA)"
              },
              "fullDescription": {
                "text": "DSA is too weak to use."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5384",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5385",
              "shortDescription": {
                "text": "Use Rivest-Shamir-Adleman (RSA) Algorithm With Sufficient Key Size"
              },
              "fullDescription": {
                "text": "Encryption algorithms are vulnerable to brute force attacks when too small a key size is used."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5385",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5386",
              "shortDescription": {
                "text": "Avoid hardcoding SecurityProtocolType value"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5386",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5387",
              "shortDescription": {
                "text": "Do Not Use Weak Key Derivation Function With Insufficient Iteration Count"
              },
              "fullDescription": {
                "text": "When deriving cryptographic keys from user-provided inputs such as password, use sufficient iteration count (at least 100k)."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5387",
              "properties": {
                "category": "Security",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA5388",
              "shortDescription": {
                "text": "Ensure Sufficient Iteration Count When Using Weak Key Derivation Function"
              },
              "fullDescription": {
                "text": "When deriving cryptographic keys from user-provided inputs such as password, use sufficient iteration count (at least 100k)."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5388",
              "properties": {
                "category": "Security",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA5389",
              "shortDescription": {
                "text": "Do Not Add Archive Item's Path To The Target File System Path"
              },
              "fullDescription": {
                "text": "When extracting files from an archive and using the archive item's path, check if the path is safe. Archive path can be relative and can lead to file system access outside of the expected file system target path, leading to malicious config changes and remote code execution via lay-and-wait technique."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5389",
              "properties": {
                "category": "Security",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5390",
              "shortDescription": {
                "text": "Do not hard-code encryption key"
              },
              "fullDescription": {
                "text": "SymmetricAlgorithm's .Key property, or a method's rgbKey parameter, should never be a hard-coded value."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5390",
              "properties": {
                "category": "Security",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5391",
              "shortDescription": {
                "text": "Use antiforgery tokens in ASP.NET Core MVC controllers"
              },
              "fullDescription": {
                "text": "Handling a POST, PUT, PATCH, or DELETE request without validating an antiforgery token may be vulnerable to cross-site request forgery attacks. A cross-site request forgery attack can send malicious requests from an authenticated user to your ASP.NET Core MVC controller."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5391",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA5392",
              "shortDescription": {
                "text": "Use DefaultDllImportSearchPaths attribute for P/Invokes"
              },
              "fullDescription": {
                "text": "By default, P/Invokes using DllImportAttribute probe a number of directories, including the current working directory for the library to load. This can be a security issue for certain applications, leading to DLL hijacking."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5392",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5393",
              "shortDescription": {
                "text": "Do not use unsafe DllImportSearchPath value"
              },
              "fullDescription": {
                "text": "There could be a malicious DLL in the default DLL search directories. Or, depending on where your application is run from, there could be a malicious DLL in the application's directory. Use a DllImportSearchPath value that specifies an explicit search path instead. The DllImportSearchPath flags that this rule looks for can be configured in .editorconfig."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5393",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5394",
              "shortDescription": {
                "text": "Do not use insecure randomness"
              },
              "fullDescription": {
                "text": "Using a cryptographically weak pseudo-random number generator may allow an attacker to predict what security-sensitive value will be generated. Use a cryptographically strong random number generator if an unpredictable value is required, or ensure that weak pseudo-random numbers aren't used in a security-sensitive manner."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5394",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5395",
              "shortDescription": {
                "text": "Miss HttpVerb attribute for action methods"
              },
              "fullDescription": {
                "text": "All the methods that create, edit, delete, or otherwise modify data do so in the [HttpPost] overload of the method, which needs to be protected with the anti forgery attribute from request forgery. Performing a GET operation should be a safe operation that has no side effects and doesn't modify your persisted data."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5395",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA5396",
              "shortDescription": {
                "text": "Set HttpOnly to true for HttpCookie"
              },
              "fullDescription": {
                "text": "As a defense in depth measure, ensure security sensitive HTTP cookies are marked as HttpOnly. This indicates web browsers should disallow scripts from accessing the cookies. Injected malicious scripts are a common way of stealing cookies."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5396",
              "properties": {
                "category": "Security",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA5397",
              "shortDescription": {
                "text": "Do not use deprecated SslProtocols values"
              },
              "fullDescription": {
                "text": "Older protocol versions of Transport Layer Security (TLS) are less secure than TLS 1.2 and TLS 1.3, and are more likely to have new vulnerabilities. Avoid older protocol versions to minimize risk."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5397",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5398",
              "shortDescription": {
                "text": "Avoid hardcoded SslProtocols values"
              },
              "fullDescription": {
                "text": "Current Transport Layer Security protocol versions may become deprecated if vulnerabilities are found. Avoid hardcoding SslProtocols values to keep your application secure. Use 'None' to let the Operating System choose a version."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5398",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5399",
              "shortDescription": {
                "text": "HttpClients should enable certificate revocation list checks"
              },
              "fullDescription": {
                "text": "Using HttpClient without providing a platform specific handler (WinHttpHandler or CurlHandler or HttpClientHandler) where the CheckCertificateRevocationList property is set to true, will allow revoked certificates to be accepted by the HttpClient as valid."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5399",
              "properties": {
                "category": "Security",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA5400",
              "shortDescription": {
                "text": "Ensure HttpClient certificate revocation list check is not disabled"
              },
              "fullDescription": {
                "text": "Using HttpClient without providing a platform specific handler (WinHttpHandler or CurlHandler or HttpClientHandler) where the CheckCertificateRevocationList property is set to true, will allow revoked certificates to be accepted by the HttpClient as valid."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5400",
              "properties": {
                "category": "Security",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA5401",
              "shortDescription": {
                "text": "Do not use CreateEncryptor with non-default IV"
              },
              "fullDescription": {
                "text": "Symmetric encryption should always use a non-repeatable initialization vector to prevent dictionary attacks."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5401",
              "properties": {
                "category": "Security",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA5402",
              "shortDescription": {
                "text": "Use CreateEncryptor with the default IV "
              },
              "fullDescription": {
                "text": "Symmetric encryption should always use a non-repeatable initialization vector to prevent dictionary attacks."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5402",
              "properties": {
                "category": "Security",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA5403",
              "shortDescription": {
                "text": "Do not hard-code certificate"
              },
              "fullDescription": {
                "text": "Hard-coded certificates in source code are vulnerable to being exploited."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5403",
              "properties": {
                "category": "Security",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5404",
              "shortDescription": {
                "text": "Do not disable token validation checks"
              },
              "fullDescription": {
                "text": "Token validation checks ensure that while validating tokens, all aspects are analyzed and verified. Turning off validation can lead to security holes by allowing untrusted tokens to make it through validation."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5404",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5405",
              "shortDescription": {
                "text": "Do not always skip token validation in delegates"
              },
              "fullDescription": {
                "text": "By setting critical TokenValidationParameter validation delegates to true, important authentication safeguards are disabled which can lead to tokens from any issuer or expired tokens being wrongly validated."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5405",
              "properties": {
                "category": "Security",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CC0001",
              "shortDescription": {
                "text": "You should use 'var' whenever possible."
              },
              "fullDescription": {
                "text": "Usage of an implicit type improve readability of the code.\u000d\u000aCode depending on types for their readability should be refactored with better variable names or by introducing well-named methods."
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0001.html",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "CC0002",
              "shortDescription": {
                "text": "Invalid argument name"
              },
              "fullDescription": {
                "text": "The string passed as the 'paramName' argument of ArgumentException constructor must be the name of one of the method arguments.\u000d\u000aIt can be either specified directly or using the nameof() operator (C#6 only)"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0002.html",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "CC0003",
              "shortDescription": {
                "text": "Your catch should include an Exception"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0003.html",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "CC0004",
              "shortDescription": {
                "text": "Catch block cannot be empty"
              },
              "fullDescription": {
                "text": "An empty catch block suppress all errors and shouldn't be used.\\r\\nIf the error is expected consider logging it or changing the control flow such that it is explicit."
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0004.html",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "CC0005",
              "shortDescription": {
                "text": "Empty Object Initializer"
              },
              "fullDescription": {
                "text": "An object initializer without any arguments can be replaced with the standard constructor syntax."
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0005.html",
              "properties": {
                "category": "Style",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "CC0006",
              "shortDescription": {
                "text": "Use foreach"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0006.html",
              "properties": {
                "category": "Style"
              }
            },
            {
              "id": "CC0007",
              "shortDescription": {
                "text": "Return Condition directly"
              },
              "fullDescription": {
                "text": "Using an if/else statement to return a boolean can be replaced by directly returning a boolean."
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0007.html",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "CC0008",
              "shortDescription": {
                "text": "Use object initializer"
              },
              "fullDescription": {
                "text": "When possible an object initializer should be used to initialize the properties of an object instead of multiple assignments."
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0008.html",
              "properties": {
                "category": "Style"
              }
            },
            {
              "id": "CC0009",
              "shortDescription": {
                "text": "Use object initializer"
              },
              "fullDescription": {
                "text": "When possible an object initializer should be used to initialize the properties of an object instead of multiple assignments."
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0009.html",
              "properties": {
                "category": "Style"
              }
            },
            {
              "id": "CC0010",
              "shortDescription": {
                "text": "Your regex expression is incorrect"
              },
              "fullDescription": {
                "text": "There is an error in your regex expression."
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0010.html",
              "properties": {
                "category": "Naming"
              }
            },
            {
              "id": "CC0011",
              "shortDescription": {
                "text": "You should remove the 'Where' invocation when it is possible."
              },
              "fullDescription": {
                "text": "When a linq operator support a predicate parameter it should be used instead of using 'Where' followed by the operator"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0011.html",
              "properties": {
                "category": "Performance"
              }
            },
            {
              "id": "CC0012",
              "shortDescription": {
                "text": "Your throw does nothing"
              },
              "fullDescription": {
                "text": "If a exception is caught and then thrown again the original stack trace will be lost. Instead it is best to throw the exception without using any parameters."
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0012.html",
              "properties": {
                "category": "Naming"
              }
            },
            {
              "id": "CC0013",
              "shortDescription": {
                "text": "Use ternary operator"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0013.html",
              "properties": {
                "category": "Style"
              }
            },
            {
              "id": "CC0014",
              "shortDescription": {
                "text": "Use ternary operator"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0014.html",
              "properties": {
                "category": "Style"
              }
            },
            {
              "id": "CC0015",
              "shortDescription": {
                "text": "Unnecessary Parenthesis"
              },
              "fullDescription": {
                "text": "There is no need to specify that the no-parameter constructor is used with  an initializer as it is implicit"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0015.html",
              "properties": {
                "category": "Style",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "CC0017",
              "shortDescription": {
                "text": "Use auto property"
              },
              "fullDescription": {
                "text": "Auto properties offer a more concise way of defining a property. If you are using simple getters and setters you are able to simplify your code with autoproperties."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0017.html",
              "properties": {
                "category": "Style"
              }
            },
            {
              "id": "CC0018",
              "shortDescription": {
                "text": "Use the existence operator"
              },
              "fullDescription": {
                "text": "The null-propagating operator allow for terse code to handle potentially null variables."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0018.html",
              "properties": {
                "category": "Style"
              }
            },
            {
              "id": "CC0019",
              "shortDescription": {
                "text": "Use 'switch'"
              },
              "fullDescription": {
                "text": "Multiple 'if' and 'else if' on the same variable can be replaced with a 'switch'on the variable\u000d\u000a\u000d\u000aNote: This diagnostic trigger for 3 or more 'case' statements"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0019.html",
              "properties": {
                "category": "Style"
              }
            },
            {
              "id": "CC0020",
              "shortDescription": {
                "text": "You should remove the lambda expression when it only invokes a method with the same signature"
              },
              "fullDescription": {
                "text": "The extra unnecessary layer of indirection induced by the lambda expression may be avoided by passing the method group instead."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0020.html",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "CC0021",
              "shortDescription": {
                "text": "Use nameof"
              },
              "fullDescription": {
                "text": "In C#6 the nameof() operator should be used to specify the name of a program element instead of a string literal as it produce code that is easier to refactor."
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0021.html",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "CC0022",
              "shortDescription": {
                "text": "Should dispose object"
              },
              "fullDescription": {
                "text": "When a disposable object is created it should be disposed as soon as possible.\u000aThis warning will appear if you create a disposable object and don't store, return or dispose it."
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0022.html",
              "properties": {
                "category": "Usage",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "CC0023",
              "shortDescription": {
                "text": "Unsealed Attribute"
              },
              "fullDescription": {
                "text": "Framework methods that retrieve attributes by default search the whole inheritence hierarchy of the attribute class. Marking the type as sealed eliminate this search and can improve performance"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0023.html",
              "properties": {
                "category": "Performance"
              }
            },
            {
              "id": "CC0024",
              "shortDescription": {
                "text": "Don't throw exceptions inside static constructors."
              },
              "fullDescription": {
                "text": "Static constructors are called before a class is used for the first time. Exceptions thrown in static constructors force the use of a try block and should be avoided."
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0024.html",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "CC0025",
              "shortDescription": {
                "text": "Remove Empty Finalizers"
              },
              "fullDescription": {
                "text": "An empty finalizer will stop your object from being collected immediately by the Garbage Collector when no longer used.It will instead be placed in the finalizer queue needlessly using resources."
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0025.html",
              "properties": {
                "category": "Performance",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "CC0026",
              "shortDescription": {
                "text": "Call Extension Method As Extension"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0026.html",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "CC0029",
              "shortDescription": {
                "text": "Disposables Should Call Suppress Finalize"
              },
              "fullDescription": {
                "text": "Classes implementing IDisposable should call the GC.SuppressFinalize method in their finalize method to avoid any finalizer from being called.\u000d\u000aThis rule should be followed even if the class doesn't have a finalizer as a derived class could have one."
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0029.html",
              "properties": {
                "category": "Naming"
              }
            },
            {
              "id": "CC0030",
              "shortDescription": {
                "text": "Make Local Variable Constant."
              },
              "fullDescription": {
                "text": "This variable is assigned a constant value and never changed it can be made 'const'"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0030.html",
              "properties": {
                "category": "Performance"
              }
            },
            {
              "id": "CC0031",
              "shortDescription": {
                "text": "Check for null before calling a delegate"
              },
              "fullDescription": {
                "text": "In C#6 a delegate can be invoked using the null-propagating operator (?.) and it's invoke method to avoid throwing a NullReference exception when there is no method attached to the delegate. Or you can check for null before calling the delegate."
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0031.html",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "CC0032",
              "shortDescription": {
                "text": "Dispose Fields Properly"
              },
              "fullDescription": {
                "text": "This class has a disposable field and is not disposing it."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0032.html",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "CC0033",
              "shortDescription": {
                "text": "Dispose Fields Properly"
              },
              "fullDescription": {
                "text": "This class has a disposable field and is not disposing it."
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0033.html",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "CC0034",
              "shortDescription": {
                "text": "Redundant field assignment"
              },
              "fullDescription": {
                "text": "It's recommend not to assign the default value to a field as a performance optimization."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0034.html",
              "properties": {
                "category": "Usage",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "CC0035",
              "shortDescription": {
                "text": "Ordering member inside this type."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0035.html",
              "properties": {
                "category": "Refactoring",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "CC0037",
              "shortDescription": {
                "text": "Remove commented code."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0037.html",
              "properties": {
                "category": "Style"
              }
            },
            {
              "id": "CC0038",
              "shortDescription": {
                "text": "You should use expression bodied members whenever possible."
              },
              "fullDescription": {
                "text": "Usage of an expression bodied members improve readability of the code."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0038.html",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "CC0039",
              "shortDescription": {
                "text": "Don't concatenate strings in loops"
              },
              "fullDescription": {
                "text": "Don't concatenate strings in a loop. Using a StringBuilder will require less memory and time."
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0039.html",
              "properties": {
                "category": "Performance"
              }
            },
            {
              "id": "CC0042",
              "shortDescription": {
                "text": "Invert the for loop counting."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0042.html",
              "properties": {
                "category": "Refactoring",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "CC0043",
              "shortDescription": {
                "text": "Change Any to All"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0043.html",
              "properties": {
                "category": "Refactoring",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "CC0044",
              "shortDescription": {
                "text": "You should use a class"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0044.html",
              "properties": {
                "category": "Refactoring",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "CC0045",
              "shortDescription": {
                "text": "Regular string"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0045.html",
              "properties": {
                "category": "Refactoring",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "CC0046",
              "shortDescription": {
                "text": "Verbatim string"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0046.html",
              "properties": {
                "category": "Refactoring",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "CC0047",
              "shortDescription": {
                "text": "You should change to 'private set' whenever possible."
              },
              "fullDescription": {
                "text": "Use private set for automatic properties."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0047.html",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "CC0048",
              "shortDescription": {
                "text": "Use string interpolation instead of String.Format"
              },
              "fullDescription": {
                "text": "String interpolation allows for better reading of the resulting string when compared to String.Format. You should use String.Format only when another method is supplying the format string."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0048.html",
              "properties": {
                "category": "Style"
              }
            },
            {
              "id": "CC0049",
              "shortDescription": {
                "text": "Simplify expression"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0049.html",
              "properties": {
                "category": "Usage",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "CC0052",
              "shortDescription": {
                "text": "Make field readonly"
              },
              "fullDescription": {
                "text": "A field that is only assigned on the constructor can be made readonly."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0052.html",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "CC0054",
              "shortDescription": {
                "text": "Your Json syntax is wrong"
              },
              "fullDescription": {
                "text": "This diagnostic checks the json string and triggers if the parsing fail by throwing an exception."
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0054.html",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "CC0056",
              "shortDescription": {
                "text": "Incorrect String.Format usage"
              },
              "fullDescription": {
                "text": "The format argument in String.Format determines the number of other arguments that need to be passed into the method based on the number of curly braces {} used. The incorrect number of arguments are being passed."
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0056.html",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "CC0057",
              "shortDescription": {
                "text": "Unused parameters"
              },
              "fullDescription": {
                "text": "A method with an unused parameter creates unnecessary confusion and should be deleted."
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0057.html",
              "properties": {
                "category": "Usage",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "CC0060",
              "shortDescription": {
                "text": "Abstract class should not have public constructors."
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0060.html",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "CC0061",
              "shortDescription": {
                "text": "Asynchronous method can be terminated with the 'Async' keyword."
              },
              "fullDescription": {
                "text": "Asynchronous method can be terminated with the 'Async' keyword."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0061.html",
              "properties": {
                "category": "Style"
              }
            },
            {
              "id": "CC0062",
              "shortDescription": {
                "text": "You should add letter 'I' before interface name."
              },
              "fullDescription": {
                "text": "Consider naming interfaces starting with 'I'."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0062.html",
              "properties": {
                "category": "Style"
              }
            },
            {
              "id": "CC0063",
              "shortDescription": {
                "text": "Your Uri syntax is wrong."
              },
              "fullDescription": {
                "text": "This diagnostic checks the Uri string and triggers if the parsing fail by throwing an exception."
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0063.html",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "CC0064",
              "shortDescription": {
                "text": "Your IP Address syntax is incorrect."
              },
              "fullDescription": {
                "text": "An error was found parsing the IP Address string."
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0064.html",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "CC0065",
              "shortDescription": {
                "text": "Remove trailing whitespace"
              },
              "fullDescription": {
                "text": "Trailing whitespaces are ugly and show sloppiness. Remove them."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0065.html",
              "properties": {
                "category": "Style"
              }
            },
            {
              "id": "CC0067",
              "shortDescription": {
                "text": "Virtual Method Called On Constructor"
              },
              "fullDescription": {
                "text": "When a virtual method is called, the actual type that executes the method is not selected until run time. When a constructor calls a virtual method, it is possible that the constructor for the instance that invokes the method has not executed."
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0067.html",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "CC0068",
              "shortDescription": {
                "text": "Unused Method"
              },
              "fullDescription": {
                "text": "Unused private methods can be safely removed as they are unnecessary."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0068.html",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "CC0070",
              "shortDescription": {
                "text": "Use ConfigureAwait(false) on awaited task."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0070.html",
              "properties": {
                "category": "Reliability",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "CC0071",
              "shortDescription": {
                "text": "Consider introduce field for constructor parameters."
              },
              "fullDescription": {
                "text": "Consider introduce field for constructor parameters."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0071.html",
              "properties": {
                "category": "Refactoring",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "CC0072",
              "shortDescription": {
                "text": "Remove Async termination when method is not asynchronous."
              },
              "fullDescription": {
                "text": "Remove Async termination when method is not asynchronous."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0072.html",
              "properties": {
                "category": "Style"
              }
            },
            {
              "id": "CC0073",
              "shortDescription": {
                "text": "Add braces to switch sections."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0073.html",
              "properties": {
                "category": "Refactoring",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "CC0074",
              "shortDescription": {
                "text": "Make field readonly"
              },
              "fullDescription": {
                "text": "A field that is only assigned on the constructor can be made readonly."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0074.html",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "CC0075",
              "shortDescription": {
                "text": "Merge nested ifs"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0075.html",
              "properties": {
                "category": "Refactoring",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "CC0076",
              "shortDescription": {
                "text": "Split into nested if"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0076.html",
              "properties": {
                "category": "Refactoring",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "CC0079",
              "shortDescription": {
                "text": "Change numeric literal expression"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0079.html",
              "properties": {
                "category": "Refactoring",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "CC0081",
              "shortDescription": {
                "text": "Use of Regex.IsMatch might be improved"
              },
              "fullDescription": {
                "text": "Instantiating the Regex object multiple times might be bad for performance. You may want to use the static IsMatch method from Regex class and/or compile the regex."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0081.html",
              "properties": {
                "category": "Performance"
              }
            },
            {
              "id": "CC0082",
              "shortDescription": {
                "text": "Change for expression value"
              },
              "fullDescription": {
                "text": "You may change an expression for its value if the expression is made of literal values."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0082.html",
              "properties": {
                "category": "Refactoring",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "CC0084",
              "shortDescription": {
                "text": "Consider use 'String.Empty'"
              },
              "fullDescription": {
                "text": "Consider user 'String.Empty' instead of \"\""
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0084.html",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "CC0088",
              "shortDescription": {
                "text": "Consider use \"\""
              },
              "fullDescription": {
                "text": "Consider using \"\" instead of 'string.Empty'"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0088.html",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "CC0089",
              "shortDescription": {
                "text": "Remove redundant else."
              },
              "fullDescription": {
                "text": "An empty else clause only adds complexity. You may safely remove it."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0089.html",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "CC0090",
              "shortDescription": {
                "text": "You have missing/unexistent parameters in Xml Docs"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0090.html",
              "properties": {
                "category": "Maintainability"
              }
            },
            {
              "id": "CC0091",
              "shortDescription": {
                "text": "Use static method"
              },
              "fullDescription": {
                "text": "If the method is not referencing any instance variable and if you are not creating a virtual, abstract, new or partial method, and if it is not a method override, your instance method may be changed to a static method."
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0091.html",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "inSource"
                ]
              }
            },
            {
              "id": "CC0092",
              "shortDescription": {
                "text": "Change All to Any"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0092.html",
              "properties": {
                "category": "Refactoring",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "CC0095",
              "shortDescription": {
                "text": "Use string interpolation instead of arguments on Console.WriteLine"
              },
              "fullDescription": {
                "text": "String interpolation allows for better reading of the resulting string when compared to Console.WriteLine arguments. You should use Console.WriteLine with arguments only when another method is supplying the format string."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0095.html",
              "properties": {
                "category": "Style"
              }
            },
            {
              "id": "CC0097",
              "shortDescription": {
                "text": "You have missing/unexistent parameters in Xml Docs"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0097.html",
              "properties": {
                "category": "Maintainability"
              }
            },
            {
              "id": "CC0105",
              "shortDescription": {
                "text": "You should use 'var' whenever possible."
              },
              "fullDescription": {
                "text": "Usage of an implicit type improve readability of the code.\u000d\u000aCode depending on types for their readability should be refactored with better variable names or by introducing well-named methods."
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0105.html",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "CC0106",
              "shortDescription": {
                "text": "PropertyChangedEventArgs unnecessary allocation"
              },
              "fullDescription": {
                "text": "Creating every time an instance of PropertyChangedEventArgs class causes unnecessary memory allocation. Instance can be created once and reused."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0106.html",
              "properties": {
                "category": "Refactoring",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "CC0108",
              "shortDescription": {
                "text": "Use nameof"
              },
              "fullDescription": {
                "text": "In C#6 the nameof() operator should be used to specify the name of a program element instead of a string literal as it produce code that is easier to refactor."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0108.html",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "CC0111",
              "shortDescription": {
                "text": "Incorrect String.Format usage"
              },
              "fullDescription": {
                "text": "The format argument in String.Format determines the number of other arguments that need to be passed into the method based on the number of curly braces {} used. The incorrect number of arguments are being passed."
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0111.html",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "CC0118",
              "shortDescription": {
                "text": "Unnecessary '.ToString()' call in string concatenation."
              },
              "fullDescription": {
                "text": "The runtime automatically calls '.ToString()' method for string concatenation operations when there is no parameters. Remove them."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0118.html",
              "properties": {
                "category": "Style",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "CC0120",
              "shortDescription": {
                "text": "Your Switch maybe include default clause"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0120.html",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "CC0121",
              "shortDescription": {
                "text": "Complex fields must be readonly"
              },
              "fullDescription": {
                "text": "Complex fields must be readonly"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0121.html",
              "properties": {
                "category": "Usage",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "CC0125",
              "shortDescription": {
                "text": "Property can be simplified by using an getter-only auto-property."
              },
              "fullDescription": {
                "text": "Getter only properties with backing read-only field can be converted to getter-only auto-properties."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://code-cracker.github.io/diagnostics/CC0125.html",
              "properties": {
                "category": "Refactoring",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "ConsoleWriteImplicitToStringAnalyzer",
              "shortDescription": {
                "text": "Suspicious implicit conversion to string"
              },
              "fullDescription": {
                "text": "Prevents calling .ToString() on a type which does not provide an override"
              },
              "properties": {
                "category": "Naming"
              }
            },
            {
              "id": "CSE001",
              "shortDescription": {
                "text": "Required properties initialization"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "CSharp Extensions"
              }
            },
            {
              "id": "CSE002",
              "shortDescription": {
                "text": "InitOnly member modification"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "CSharp Extensions"
              }
            },
            {
              "id": "CSE003",
              "shortDescription": {
                "text": "Type should have the same fields as twin type"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "CSharp Extensions"
              }
            },
            {
              "id": "CSE004",
              "shortDescription": {
                "text": "InitOnlyOptional requires default value"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "CSharp Extensions"
              }
            },
            {
              "id": "CSE005",
              "shortDescription": {
                "text": "Return value unused"
              },
              "properties": {
                "category": "CSharp Extensions"
              }
            },
            {
              "id": "CSE006",
              "shortDescription": {
                "text": "Expression too complex"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "CSharp Extensions"
              }
            },
            {
              "id": "CSE007",
              "shortDescription": {
                "text": "Return disposable value unused"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "CSharp Extensions",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "inSource"
                ]
              }
            },
            {
              "id": "CSE008",
              "shortDescription": {
                "text": "Return async result unused"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "CSharp Extensions"
              }
            },
            {
              "id": "CSE009",
              "shortDescription": {
                "text": "Task variable not awaited"
              },
              "properties": {
                "category": "CSharp Extensions"
              }
            },
            {
              "id": "ENUM001",
              "shortDescription": {
                "text": "Do not use ToString() on an enum use EnumHelpers.GetName(this Enum value) instead"
              },
              "fullDescription": {
                "text": "Do not use ToString() on an enum use EnumHelpers.GetName(this Enum value) instead"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Do not use ToString() on an enum use EnumHelpers.GetName(this Enum value) instead"
              }
            },
            {
              "id": "ExplicitToStringWithoutOverrideAnalyzer",
              "shortDescription": {
                "text": "Suspicious conversion to string"
              },
              "fullDescription": {
                "text": "Prevents calling .ToString() on a type which does not provide an override"
              },
              "properties": {
                "category": "Naming"
              }
            },
            {
              "id": "FFS0001",
              "shortDescription": {
                "text": "Avoid use of DateTime methods"
              },
              "fullDescription": {
                "text": "Call IDateTimeSource.UtcNow() rather than DateTime.Now"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "IllegalMethodCalls"
              }
            },
            {
              "id": "FFS0002",
              "shortDescription": {
                "text": "Avoid use of DateTime methods"
              },
              "fullDescription": {
                "text": "Call IDateTimeSource.UtcNow() rather than DateTime.UtcNow"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "IllegalMethodCalls"
              }
            },
            {
              "id": "FFS0003",
              "shortDescription": {
                "text": "Avoid use of DateTime methods"
              },
              "fullDescription": {
                "text": "Call IDateTimeSource.UtcNow().Date rather than DateTime.Today"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "IllegalMethodCalls"
              }
            },
            {
              "id": "FFS0004",
              "shortDescription": {
                "text": "Avoid use of DateTime methods"
              },
              "fullDescription": {
                "text": "Call IDateTimeSource.UtcNow() rather than DateTimeOffset.Now"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "IllegalMethodCalls"
              }
            },
            {
              "id": "FFS0005",
              "shortDescription": {
                "text": "Avoid use of DateTime methods"
              },
              "fullDescription": {
                "text": "Call IDateTimeSource.UtcNow() rather than DateTimeOffset.UtcNow"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "IllegalMethodCalls"
              }
            },
            {
              "id": "FFS0006",
              "shortDescription": {
                "text": "Avoid use of inline SQL statements"
              },
              "fullDescription": {
                "text": "Only use ISqlServerDatabase.ExecuteArbitrarySqlAsync in integration tests"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "IllegalMethodCalls"
              }
            },
            {
              "id": "FFS0007",
              "shortDescription": {
                "text": "Avoid use of inline SQL statements"
              },
              "fullDescription": {
                "text": "Only use ISqlServerDatabase.QueryArbitrarySqlAsync in integration tests"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "IllegalMethodCalls"
              }
            },
            {
              "id": "FFS0008",
              "shortDescription": {
                "text": "Don't disable warnings with #pragma warning disable"
              },
              "fullDescription": {
                "text": "Don't disable warnings using #pragma warning disable"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "IllegalPragmas"
              }
            },
            {
              "id": "FFS0009",
              "shortDescription": {
                "text": "Avoid use of assert method without message"
              },
              "fullDescription": {
                "text": "Only use Assert.True with message parameter"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "IllegalMethodInvocations"
              }
            },
            {
              "id": "FFS0010",
              "shortDescription": {
                "text": "Avoid use of assert method without message"
              },
              "fullDescription": {
                "text": "Only use Assert.False with message parameter"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "IllegalMethodInvocations"
              }
            },
            {
              "id": "FFS0011",
              "shortDescription": {
                "text": "Structs should be read-only"
              },
              "fullDescription": {
                "text": "Structs should be read-only"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Structs"
              }
            },
            {
              "id": "FFS0012",
              "shortDescription": {
                "text": "Classes should be static, sealed or abstract"
              },
              "fullDescription": {
                "text": "Classes should be static, sealed or abstract"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Classes"
              }
            },
            {
              "id": "FFS0013",
              "shortDescription": {
                "text": "Test classes should be derived from TestBase"
              },
              "fullDescription": {
                "text": "Test classes should be derived from TestBase"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Classes"
              }
            },
            {
              "id": "FFS0014",
              "shortDescription": {
                "text": "Avoid use of serializer without own JsonSerializerOptions parameter"
              },
              "fullDescription": {
                "text": "Only use JsonSerializer.Serialize with own JsonSerializerOptions"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "ForcedMethodInvocations"
              }
            },
            {
              "id": "FFS0015",
              "shortDescription": {
                "text": "Avoid use of deserializer without own JsonSerializerOptions parameter"
              },
              "fullDescription": {
                "text": "Only use JsonSerializer.Deserialize with own JsonSerializerOptions"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "ForcedMethodInvocations"
              }
            },
            {
              "id": "FFS0016",
              "shortDescription": {
                "text": "Argument Exceptions should pass parameter name"
              },
              "fullDescription": {
                "text": "Argument Exceptions should pass parameter name"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Exceptions"
              }
            },
            {
              "id": "FFS0017",
              "shortDescription": {
                "text": "Pass an a inner exception when thrown from a catch clause"
              },
              "fullDescription": {
                "text": "Provide '{0}' as a inner exception when throw from the catch clauses"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Exceptions"
              }
            },
            {
              "id": "FFS0018",
              "shortDescription": {
                "text": "Avoid use of received without call count"
              },
              "fullDescription": {
                "text": "Only use Received with expected call count"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "ForcedMethodInvocations"
              }
            },
            {
              "id": "FFS0019",
              "shortDescription": {
                "text": "ILogger parameters should be called 'logger'"
              },
              "fullDescription": {
                "text": "ILogger parameters should be called 'logger'"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Naming"
              }
            },
            {
              "id": "FFS0020",
              "shortDescription": {
                "text": "Parameters are out of order"
              },
              "fullDescription": {
                "text": "Parameter '{0}' must be parameter {1}"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Parameters"
              }
            },
            {
              "id": "FFS0021",
              "shortDescription": {
                "text": "Avoid use of received with zero call count"
              },
              "fullDescription": {
                "text": "Only use Received with expected call count greater than 0, use DidNotReceived instead if 0 call received expected"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "ProhibitedMethodWithStrictInvocations"
              }
            },
            {
              "id": "FFS0022",
              "shortDescription": {
                "text": "Don't use #nulllable directive, make the change globally for the project"
              },
              "fullDescription": {
                "text": "Don't use #nulllable directive, make the change globally for the project"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "IllegalDirectives"
              }
            },
            {
              "id": "FFS0023",
              "shortDescription": {
                "text": "ILogger parameters on base classes should not be ILogger<{0}> but ILogger"
              },
              "fullDescription": {
                "text": "ILogger parameters on base classes should not be ILogger<{0}> but ILogger"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Naming"
              }
            },
            {
              "id": "FFS0024",
              "shortDescription": {
                "text": "ILogger parameters on leaf classes should not be ILogger but ILogger<{0}>"
              },
              "fullDescription": {
                "text": "ILogger parameters on leaf classes should not be ILogger but ILogger<{0}>"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Naming"
              }
            },
            {
              "id": "FFS0025",
              "shortDescription": {
                "text": "Should be using '{0}' rather than '{1}' with {2}"
              },
              "fullDescription": {
                "text": "Should be using '{0}' rather than '{1}' with {2}"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Naming"
              }
            },
            {
              "id": "FFS0026",
              "shortDescription": {
                "text": "Use RemoteIpAddressRetriever instead of getting RemoteIpAddress directly from the HttpRequest"
              },
              "fullDescription": {
                "text": "Use RemoteIpAddressRetriever"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "IllegalMethodCalls"
              }
            },
            {
              "id": "FFS0027",
              "shortDescription": {
                "text": "SuppressMessage must specify a Justification"
              },
              "fullDescription": {
                "text": "SuppressMessage must specify a Justification"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "SuppressedErrors"
              }
            },
            {
              "id": "FFS0028",
              "shortDescription": {
                "text": "Records should be sealed"
              },
              "fullDescription": {
                "text": "Records should be sealed"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Records"
              }
            },
            {
              "id": "FFS0029",
              "shortDescription": {
                "text": "MockBase<T> instances must be internal"
              },
              "fullDescription": {
                "text": "MockBase<T> instances must be internal"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Classes"
              }
            },
            {
              "id": "FFS0030",
              "shortDescription": {
                "text": "MockBase<T> instances must be sealed"
              },
              "fullDescription": {
                "text": "MockBase<T> instances must be sealed"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Classes"
              }
            },
            {
              "id": "FFS0031",
              "shortDescription": {
                "text": "Avoid use of System.Collections.Concurrent.ConcurrentDictionary class"
              },
              "fullDescription": {
                "text": "Use NonBlocking.ConcurrentDictionary  rather than System.Collections.Concurrent.ConcurrentDictionary"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "IllegalClassUsage"
              }
            },
            {
              "id": "FFS0032",
              "shortDescription": {
                "text": "Avoid use of the built in AddOrUpdate methods"
              },
              "fullDescription": {
                "text": "Don't use any of the built in AddOrUpdate methods, instead FunFair.Common.Extensions.ConcurrentDictionaryExtensions.AddOrUpdate can be used"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "IllegalMethodInvocations"
              }
            },
            {
              "id": "FFS0033",
              "shortDescription": {
                "text": "Avoid use of the built in GetOrAdd methods"
              },
              "fullDescription": {
                "text": "Don't use any of the built in GetOrAdd methods, instead FunFair.Common.Extensions.ConcurrentDictionaryExtensions.GetOrAdd can be used"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "IllegalMethodInvocations"
              }
            },
            {
              "id": "FFS0034",
              "shortDescription": {
                "text": "Avoid use of reloadOnChange with value true"
              },
              "fullDescription": {
                "text": "Only use AddJsonFile with reloadOnChange set to false"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "ProhibitedMethodWithStrictInvocations"
              }
            },
            {
              "id": "FFS0035",
              "shortDescription": {
                "text": "Fields in test classes should be read-only or const"
              },
              "fullDescription": {
                "text": "Fields in test classes should be read-only or const"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Classes"
              }
            },
            {
              "id": "FFS0036",
              "shortDescription": {
                "text": "Properties in test classes should be read-only or const"
              },
              "fullDescription": {
                "text": "Properties in test classes should be read-only or const"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Classes"
              }
            },
            {
              "id": "FFS0037",
              "shortDescription": {
                "text": "Use new Guid() with constant guids or Guid.TryParse everywhere else"
              },
              "fullDescription": {
                "text": "Use new Guid() with constant guids or Guid.TryParse everywhere else"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "IllegalMethodCalls"
              }
            },
            {
              "id": "FFS0038",
              "shortDescription": {
                "text": "Should have DebuggerDisplay attribute"
              },
              "fullDescription": {
                "text": "Should have DebuggerDisplay attribute"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Debugging"
              }
            },
            {
              "id": "FFS0039",
              "shortDescription": {
                "text": "Should be only one type per file"
              },
              "fullDescription": {
                "text": "Should be only one type per file"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Files"
              }
            },
            {
              "id": "FFS0040",
              "shortDescription": {
                "text": "Should be in a file of the same name as the type"
              },
              "fullDescription": {
                "text": "Should be in a file of the same name as the type"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Files"
              }
            },
            {
              "id": "FFS0041",
              "shortDescription": {
                "text": "Avoid use of System.Console class"
              },
              "fullDescription": {
                "text": "Use ITestOutputHelper rather than System.Console in test projects"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "IllegalClassUsage"
              }
            },
            {
              "id": "FFS0042",
              "shortDescription": {
                "text": "SuppressMessage must not have a TODO Justification"
              },
              "fullDescription": {
                "text": "SuppressMessage must not have a TODO Justification"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "SuppressedErrors"
              }
            },
            {
              "id": "IDE0004",
              "shortDescription": {
                "text": "Remove Unnecessary Cast"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0004",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled",
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "IDE0005",
              "shortDescription": {
                "text": "Using directive is unnecessary."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0005",
              "properties": {
                "category": "Style",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_HighlyRecommended",
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "IDE0005_gen",
              "shortDescription": {
                "text": "Using directive is unnecessary."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Style",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Never",
                  "NotConfigurable",
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "IDE0007",
              "shortDescription": {
                "text": "Use implicit type"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0007",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_HighlyRecommended"
                ]
              }
            },
            {
              "id": "IDE0008",
              "shortDescription": {
                "text": "Use explicit type"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0008",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_HighlyRecommended"
                ]
              }
            },
            {
              "id": "IDE0009",
              "shortDescription": {
                "text": "Member access should be qualified."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0009",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Never"
                ]
              }
            },
            {
              "id": "IDE0010",
              "shortDescription": {
                "text": "Add missing cases"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0010",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled"
                ]
              }
            },
            {
              "id": "IDE0011",
              "shortDescription": {
                "text": "Add braces"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0011",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_HighlyRecommended"
                ]
              }
            },
            {
              "id": "IDE0016",
              "shortDescription": {
                "text": "Use 'throw' expression"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0016",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0017",
              "shortDescription": {
                "text": "Simplify object initialization"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0017",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0018",
              "shortDescription": {
                "text": "Inline variable declaration"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0018",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0019",
              "shortDescription": {
                "text": "Use pattern matching"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0019",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0020",
              "shortDescription": {
                "text": "Use pattern matching"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0020",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0021",
              "shortDescription": {
                "text": "Use expression body for constructor"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0021",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0022",
              "shortDescription": {
                "text": "Use expression body for method"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0022",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0023",
              "shortDescription": {
                "text": "Use expression body for conversion operator"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0023",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0024",
              "shortDescription": {
                "text": "Use expression body for operator"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0024",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0025",
              "shortDescription": {
                "text": "Use expression body for property"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0025",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0026",
              "shortDescription": {
                "text": "Use expression body for indexer"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0026",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0027",
              "shortDescription": {
                "text": "Use expression body for accessor"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0027",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0028",
              "shortDescription": {
                "text": "Simplify collection initialization"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0028",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0029",
              "shortDescription": {
                "text": "Use coalesce expression"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0029",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0030",
              "shortDescription": {
                "text": "Use coalesce expression"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0030",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0031",
              "shortDescription": {
                "text": "Use null propagation"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0031",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0032",
              "shortDescription": {
                "text": "Use auto property"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0032",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0033",
              "shortDescription": {
                "text": "Use explicitly provided tuple name"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0033",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0034",
              "shortDescription": {
                "text": "Simplify 'default' expression"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0034",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "IDE0035",
              "shortDescription": {
                "text": "Unreachable code detected"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0035",
              "properties": {
                "category": "Style",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Never",
                  "NotConfigurable",
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "IDE0036",
              "shortDescription": {
                "text": "Order modifiers"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0036",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_HighlyRecommended"
                ]
              }
            },
            {
              "id": "IDE0037",
              "shortDescription": {
                "text": "Use inferred member name"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0037",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled",
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "IDE0039",
              "shortDescription": {
                "text": "Use local function"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0039",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0040",
              "shortDescription": {
                "text": "Add accessibility modifiers"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0040",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_HighlyRecommended"
                ]
              }
            },
            {
              "id": "IDE0041",
              "shortDescription": {
                "text": "Use 'is null' check"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0041",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled"
                ]
              }
            },
            {
              "id": "IDE0042",
              "shortDescription": {
                "text": "Deconstruct variable declaration"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0042",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0043",
              "shortDescription": {
                "text": "Invalid format string"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Compiler",
                "tags": [
                  "EnforceOnBuild_HighlyRecommended"
                ]
              }
            },
            {
              "id": "IDE0044",
              "shortDescription": {
                "text": "Add readonly modifier"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0044",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_HighlyRecommended"
                ]
              }
            },
            {
              "id": "IDE0045",
              "shortDescription": {
                "text": "Convert to conditional expression"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0045",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0046",
              "shortDescription": {
                "text": "Convert to conditional expression"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0046",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0047",
              "shortDescription": {
                "text": "Remove unnecessary parentheses"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0047",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "IDE0048",
              "shortDescription": {
                "text": "Add parentheses for clarity"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0048",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled"
                ]
              }
            },
            {
              "id": "IDE0051",
              "shortDescription": {
                "text": "Remove unused private members"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0051",
              "properties": {
                "category": "CodeQuality",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_HighlyRecommended",
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "IDE0052",
              "shortDescription": {
                "text": "Remove unread private members"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0052",
              "properties": {
                "category": "CodeQuality",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_HighlyRecommended",
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "IDE0053",
              "shortDescription": {
                "text": "Use expression body for lambda expression"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0053",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0054",
              "shortDescription": {
                "text": "Use compound assignment"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0054",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0055",
              "shortDescription": {
                "text": "Fix formatting"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0055",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_HighlyRecommended"
                ]
              }
            },
            {
              "id": "IDE0056",
              "shortDescription": {
                "text": "Use index operator"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0056",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0057",
              "shortDescription": {
                "text": "Use range operator"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0057",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0058",
              "shortDescription": {
                "text": "Expression value is never used"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0058",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled"
                ]
              }
            },
            {
              "id": "IDE0059",
              "shortDescription": {
                "text": "Unnecessary assignment of a value"
              },
              "fullDescription": {
                "text": "Avoid unnecessary value assignments in your code, as these likely indicate redundant value computations. If the value computation is not redundant and you intend to retain the assignment, then change the assignment target to a local variable whose name starts with an underscore and is optionally followed by an integer, such as '_', '_1', '_2', etc. These are treated as special discard symbol names."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0059",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_HighlyRecommended",
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "IDE0060",
              "shortDescription": {
                "text": "Remove unused parameter"
              },
              "fullDescription": {
                "text": "Avoid unused parameters in your code. If the parameter cannot be removed, then change its name so it starts with an underscore and is optionally followed by an integer, such as '_', '_1', '_2', etc. These are treated as special discard symbol names."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0060",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_HighlyRecommended",
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "IDE0061",
              "shortDescription": {
                "text": "Use expression body for local function"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0061",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0062",
              "shortDescription": {
                "text": "Make local function 'static'"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0062",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0063",
              "shortDescription": {
                "text": "Use simple 'using' statement"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0063",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0064",
              "shortDescription": {
                "text": "Make readonly fields writable"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0064",
              "properties": {
                "category": "CodeQuality",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled"
                ]
              }
            },
            {
              "id": "IDE0065",
              "shortDescription": {
                "text": "Misplaced using directive"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0065",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0066",
              "shortDescription": {
                "text": "Convert switch statement to expression"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0066",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled"
                ]
              }
            },
            {
              "id": "IDE0070",
              "shortDescription": {
                "text": "Use 'System.HashCode'"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0070",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0071",
              "shortDescription": {
                "text": "Simplify interpolation"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0071",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "IDE0072",
              "shortDescription": {
                "text": "Add missing cases"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0072",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled"
                ]
              }
            },
            {
              "id": "IDE0073",
              "shortDescription": {
                "text": "The file header is missing or not located at the top of the file"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0073",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_HighlyRecommended"
                ]
              }
            },
            {
              "id": "IDE0074",
              "shortDescription": {
                "text": "Use compound assignment"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0074",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0075",
              "shortDescription": {
                "text": "Simplify conditional expression"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0075",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0076",
              "shortDescription": {
                "text": "Invalid global 'SuppressMessageAttribute'"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0076",
              "properties": {
                "category": "CodeQuality",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_HighlyRecommended",
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "IDE0077",
              "shortDescription": {
                "text": "Avoid legacy format target in 'SuppressMessageAttribute'"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0077",
              "properties": {
                "category": "CodeQuality",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_HighlyRecommended"
                ]
              }
            },
            {
              "id": "IDE0078",
              "shortDescription": {
                "text": "Use pattern matching"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0078",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0080",
              "shortDescription": {
                "text": "Remove unnecessary suppression operator"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0080",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_HighlyRecommended"
                ]
              }
            },
            {
              "id": "IDE0082",
              "shortDescription": {
                "text": "'typeof' can be converted  to 'nameof'"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0082",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0083",
              "shortDescription": {
                "text": "Use pattern matching"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0083",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0090",
              "shortDescription": {
                "text": "Use 'new(...)'"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0090",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0100",
              "shortDescription": {
                "text": "Remove redundant equality"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0100",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0110",
              "shortDescription": {
                "text": "Remove unnecessary discard"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0110",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "IDE0120",
              "shortDescription": {
                "text": "Simplify LINQ expression"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0120",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled"
                ]
              }
            },
            {
              "id": "IDE0130",
              "shortDescription": {
                "text": "Namespace does not match folder structure"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0130",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0150",
              "shortDescription": {
                "text": "Prefer 'null' check over type check"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0150",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled"
                ]
              }
            },
            {
              "id": "IDE0160",
              "shortDescription": {
                "text": "Convert to block scoped namespace"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0160",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_HighlyRecommended"
                ]
              }
            },
            {
              "id": "IDE0161",
              "shortDescription": {
                "text": "Convert to file-scoped namespace"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0161",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_HighlyRecommended"
                ]
              }
            },
            {
              "id": "IDE0170",
              "shortDescription": {
                "text": "Property pattern can be simplified"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0170",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0180",
              "shortDescription": {
                "text": "Use tuple to swap values"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0180",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_HighlyRecommended"
                ]
              }
            },
            {
              "id": "IDE0200",
              "shortDescription": {
                "text": "Remove unnecessary lambda expression"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0200",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "IDE0210",
              "shortDescription": {
                "text": "Convert to top-level statements"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0210",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled"
                ]
              }
            },
            {
              "id": "IDE0211",
              "shortDescription": {
                "text": "Convert to 'Program.Main' style program"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0211",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled"
                ]
              }
            },
            {
              "id": "IDE0220",
              "shortDescription": {
                "text": "Add explicit cast"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0220",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled"
                ]
              }
            },
            {
              "id": "IDE0230",
              "shortDescription": {
                "text": "Use UTF-8 string literal"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0230",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled"
                ]
              }
            },
            {
              "id": "IDE0240",
              "shortDescription": {
                "text": "Remove redundant nullable directive"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0240",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "IDE0241",
              "shortDescription": {
                "text": "Remove unnecessary nullable directive"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0241",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "IDE0250",
              "shortDescription": {
                "text": "Make struct 'readonly'"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0250",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0260",
              "shortDescription": {
                "text": "Use pattern matching"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0260",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0270",
              "shortDescription": {
                "text": "Use coalesce expression"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0270",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0280",
              "shortDescription": {
                "text": "Use 'nameof'"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0280",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE1005",
              "shortDescription": {
                "text": "Delegate invocation can be simplified."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide1005",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE1006",
              "shortDescription": {
                "text": "Naming Styles"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide1006",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE2000",
              "shortDescription": {
                "text": "Avoid multiple blank lines"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide2000",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled"
                ]
              }
            },
            {
              "id": "IDE2001",
              "shortDescription": {
                "text": "Embedded statements must be on their own line"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide2001",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled"
                ]
              }
            },
            {
              "id": "IDE2002",
              "shortDescription": {
                "text": "Consecutive braces must not have blank line between them"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide2002",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled"
                ]
              }
            },
            {
              "id": "IDE2003",
              "shortDescription": {
                "text": "Blank line required between block and subsequent statement"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide2003",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled"
                ]
              }
            },
            {
              "id": "IDE2004",
              "shortDescription": {
                "text": "Blank line not allowed after constructor initializer colon"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide2004",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled"
                ]
              }
            },
            {
              "id": "IDE2005",
              "shortDescription": {
                "text": "Blank line not allowed after conditional expression token"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide2005",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled"
                ]
              }
            },
            {
              "id": "IDE2006",
              "shortDescription": {
                "text": "Blank line not allowed after arrow expression clause token"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide2006",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled"
                ]
              }
            },
            {
              "id": "ImplicitStringConversionAnalyzer",
              "shortDescription": {
                "text": "Suspicious implicit conversion to string"
              },
              "fullDescription": {
                "text": "Prevents calling .ToString() on a type which does not provide an override"
              },
              "properties": {
                "category": "Naming"
              }
            },
            {
              "id": "InterpolatedStringImplicitToStringAnalyzer",
              "shortDescription": {
                "text": "Suspicious conversion to string"
              },
              "fullDescription": {
                "text": "Prevents calling .ToString() on a type which does not provide an override"
              },
              "properties": {
                "category": "Naming"
              }
            },
            {
              "id": "MA0001",
              "shortDescription": {
                "text": "StringComparison is missing"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0001.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "MA0002",
              "shortDescription": {
                "text": "IEqualityComparer<string> or IComparer<string> is missing"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0002.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "MA0003",
              "shortDescription": {
                "text": "Add parameter name to improve readability"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0003.md",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "MA0004",
              "shortDescription": {
                "text": "Use Task.ConfigureAwait(false)"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0004.md",
              "properties": {
                "category": "Usage",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "MA0005",
              "shortDescription": {
                "text": "Use Array.Empty<T>()"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0005.md",
              "properties": {
                "category": "Performance"
              }
            },
            {
              "id": "MA0006",
              "shortDescription": {
                "text": "Use String.Equals instead of equality operator"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0006.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "MA0007",
              "shortDescription": {
                "text": "Add a comma after the last value"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0007.md",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "MA0008",
              "shortDescription": {
                "text": "Add StructLayoutAttribute"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0008.md",
              "properties": {
                "category": "Performance"
              }
            },
            {
              "id": "MA0009",
              "shortDescription": {
                "text": "Add regex evaluation timeout"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0009.md",
              "properties": {
                "category": "Security"
              }
            },
            {
              "id": "MA0010",
              "shortDescription": {
                "text": "Mark attributes with AttributeUsageAttribute"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0010.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0011",
              "shortDescription": {
                "text": "IFormatProvider is missing"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0011.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "MA0012",
              "shortDescription": {
                "text": "Do not raise reserved exception type"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0012.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0013",
              "shortDescription": {
                "text": "Types should not extend System.ApplicationException"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0013.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0014",
              "shortDescription": {
                "text": "Do not raise System.ApplicationException type"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0014.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0015",
              "shortDescription": {
                "text": "Specify the parameter name in ArgumentException"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0015.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "MA0016",
              "shortDescription": {
                "text": "Prefer returning collection abstraction instead of implementation"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0016.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0017",
              "shortDescription": {
                "text": "Abstract types should not have public or internal constructors"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0017.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0018",
              "shortDescription": {
                "text": "Do not declare static members on generic types"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0018.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0019",
              "shortDescription": {
                "text": "Use EventArgs.Empty"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0019.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "MA0020",
              "shortDescription": {
                "text": "Use direct methods instead of LINQ methods"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0020.md",
              "properties": {
                "category": "Performance"
              }
            },
            {
              "id": "MA0021",
              "shortDescription": {
                "text": "Use StringComparer.GetHashCode instead of string.GetHashCode"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0021.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "MA0022",
              "shortDescription": {
                "text": "Return Task.FromResult instead of returning null"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0022.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0023",
              "shortDescription": {
                "text": "Add RegexOptions.ExplicitCapture"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0023.md",
              "properties": {
                "category": "Performance"
              }
            },
            {
              "id": "MA0024",
              "shortDescription": {
                "text": "Use an explicit StringComparer when possible"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0024.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "MA0025",
              "shortDescription": {
                "text": "Implement the functionality instead of throwing NotImplementedException"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0025.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0026",
              "shortDescription": {
                "text": "Fix TODO comment"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0026.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0027",
              "shortDescription": {
                "text": "Prefer rethrowing an exception implicitly"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0027.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "MA0028",
              "shortDescription": {
                "text": "Optimize StringBuilder usage"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0028.md",
              "properties": {
                "category": "Performance"
              }
            },
            {
              "id": "MA0029",
              "shortDescription": {
                "text": "Combine LINQ methods"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0029.md",
              "properties": {
                "category": "Performance"
              }
            },
            {
              "id": "MA0030",
              "shortDescription": {
                "text": "Remove useless OrderBy call"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0030.md",
              "properties": {
                "category": "Performance"
              }
            },
            {
              "id": "MA0031",
              "shortDescription": {
                "text": "Optimize Enumerable.Count() usage"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0031.md",
              "properties": {
                "category": "Performance"
              }
            },
            {
              "id": "MA0032",
              "shortDescription": {
                "text": "Use an overload with a CancellationToken argument"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0032.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "MA0033",
              "shortDescription": {
                "text": "Do not tag instance fields with ThreadStaticAttribute"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0033.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0035",
              "shortDescription": {
                "text": "Do not use dangerous threading methods"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0035.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "MA0036",
              "shortDescription": {
                "text": "Make class static"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0036.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0037",
              "shortDescription": {
                "text": "Remove empty statement"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0037.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "MA0038",
              "shortDescription": {
                "text": "Make method static (deprecated, use CA1822 instead)"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0038.md",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "MA0039",
              "shortDescription": {
                "text": "Do not write your own certificate validation method"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0039.md",
              "properties": {
                "category": "Security"
              }
            },
            {
              "id": "MA0040",
              "shortDescription": {
                "text": "Forward the CancellationToken parameter to methods that take one"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0040.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "MA0041",
              "shortDescription": {
                "text": "Make property static (deprecated, use CA1822 instead)"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0041.md",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "MA0042",
              "shortDescription": {
                "text": "Do not use blocking calls in an async method"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0042.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0043",
              "shortDescription": {
                "text": "Use nameof operator in ArgumentException"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0043.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "MA0044",
              "shortDescription": {
                "text": "Remove useless ToString call"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0044.md",
              "properties": {
                "category": "Performance"
              }
            },
            {
              "id": "MA0045",
              "shortDescription": {
                "text": "Do not use blocking calls in a sync method (need to make calling method async)"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0045.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0046",
              "shortDescription": {
                "text": "Use EventHandler<T> to declare events"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0046.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0047",
              "shortDescription": {
                "text": "Declare types in namespaces"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0047.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0048",
              "shortDescription": {
                "text": "File name must match type name"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0048.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0049",
              "shortDescription": {
                "text": "Type name should not match containing namespace"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0049.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0050",
              "shortDescription": {
                "text": "Validate arguments correctly in iterator methods"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0050.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0051",
              "shortDescription": {
                "text": "Method is too long"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0051.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0052",
              "shortDescription": {
                "text": "Replace constant Enum.ToString with nameof"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0052.md",
              "properties": {
                "category": "Performance"
              }
            },
            {
              "id": "MA0053",
              "shortDescription": {
                "text": "Make class sealed"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0053.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0054",
              "shortDescription": {
                "text": "Embed the caught exception as innerException"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0054.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0055",
              "shortDescription": {
                "text": "Do not use finalizer"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0055.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0056",
              "shortDescription": {
                "text": "Do not call overridable members in constructor"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0056.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0057",
              "shortDescription": {
                "text": "Class name should end with 'Attribute'"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0057.md",
              "properties": {
                "category": "Naming"
              }
            },
            {
              "id": "MA0058",
              "shortDescription": {
                "text": "Class name should end with 'Exception'"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0058.md",
              "properties": {
                "category": "Naming"
              }
            },
            {
              "id": "MA0059",
              "shortDescription": {
                "text": "Class name should end with 'EventArgs'"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0059.md",
              "properties": {
                "category": "Naming"
              }
            },
            {
              "id": "MA0060",
              "shortDescription": {
                "text": "The value returned by Stream.Read/Stream.ReadAsync is not used"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0060.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0061",
              "shortDescription": {
                "text": "Method overrides should not change default values"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0061.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0062",
              "shortDescription": {
                "text": "Non-flags enums should not be marked with \"FlagsAttribute\""
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0062.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0063",
              "shortDescription": {
                "text": "Use Where before OrderBy"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0063.md",
              "properties": {
                "category": "Performance"
              }
            },
            {
              "id": "MA0064",
              "shortDescription": {
                "text": "Avoid locking on publicly accessible instance"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0064.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0065",
              "shortDescription": {
                "text": "Default ValueType.Equals or HashCode is used for struct equality"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0065.md",
              "properties": {
                "category": "Performance"
              }
            },
            {
              "id": "MA0066",
              "shortDescription": {
                "text": "Hash table unfriendly type is used in a hash table"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0066.md",
              "properties": {
                "category": "Performance"
              }
            },
            {
              "id": "MA0067",
              "shortDescription": {
                "text": "Use Guid.Empty"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0067.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0068",
              "shortDescription": {
                "text": "Invalid parameter name for nullable attribute"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0068.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0069",
              "shortDescription": {
                "text": "Non-constant static fields should not be visible"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0069.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0070",
              "shortDescription": {
                "text": "Obsolete attributes should include explanations"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0070.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0071",
              "shortDescription": {
                "text": "Avoid using redundant else"
              },
              "fullDescription": {
                "text": "The 'if' block contains a jump statement (break, continue, goto, return, throw, yield break). Using 'else' is redundant and needlessly maintains a higher nesting level."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0071.md",
              "properties": {
                "category": "Style"
              }
            },
            {
              "id": "MA0072",
              "shortDescription": {
                "text": "Do not throw from a finally block"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0072.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0073",
              "shortDescription": {
                "text": "Avoid comparison with bool constant"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0073.md",
              "properties": {
                "category": "Style"
              }
            },
            {
              "id": "MA0074",
              "shortDescription": {
                "text": "Avoid implicit culture-sensitive methods"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0074.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "MA0075",
              "shortDescription": {
                "text": "Do not use implicit culture-sensitive ToString"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0075.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0076",
              "shortDescription": {
                "text": "Do not use implicit culture-sensitive ToString in interpolated strings"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0076.md",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "MA0077",
              "shortDescription": {
                "text": "A class that provides Equals(T) should implement IEquatable<T>"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0077.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0078",
              "shortDescription": {
                "text": "Use 'Cast' instead of 'Select' to cast"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0078.md",
              "properties": {
                "category": "Performance"
              }
            },
            {
              "id": "MA0079",
              "shortDescription": {
                "text": "Forward the CancellationToken using .WithCancellation()"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0079.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "MA0080",
              "shortDescription": {
                "text": "Use a cancellation token using .WithCancellation()"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0080.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "MA0081",
              "shortDescription": {
                "text": "Method overrides should not omit params keyword"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0081.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0082",
              "shortDescription": {
                "text": "NaN should not be used in comparisons"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0082.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0083",
              "shortDescription": {
                "text": "ConstructorArgument parameters should exist in constructors"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0083.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0084",
              "shortDescription": {
                "text": "Local variables should not hide other symbols"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0084.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0085",
              "shortDescription": {
                "text": "Anonymous delegates should not be used to unsubscribe from Events"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0085.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "MA0086",
              "shortDescription": {
                "text": "Do not throw from a finalizer"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0086.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0087",
              "shortDescription": {
                "text": "Parameters with [DefaultParameterValue] attributes should also be marked [Optional]"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0087.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0088",
              "shortDescription": {
                "text": "Use [DefaultParameterValue] instead of [DefaultValue]"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0088.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0089",
              "shortDescription": {
                "text": "Optimize string method usage"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0089.md",
              "properties": {
                "category": "Performance"
              }
            },
            {
              "id": "MA0090",
              "shortDescription": {
                "text": "Remove empty else/finally block"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0090.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0091",
              "shortDescription": {
                "text": "Sender should be 'this' for instance events"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0091.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "MA0092",
              "shortDescription": {
                "text": "Sender should be 'null' for static events"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0092.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "MA0093",
              "shortDescription": {
                "text": "EventArgs should not be null"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0093.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "MA0094",
              "shortDescription": {
                "text": "A class that provides CompareTo(T) should implement IComparable<T>"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0094.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0095",
              "shortDescription": {
                "text": "A class that implements IEquatable<T> should override Equals(object)"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0095.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0096",
              "shortDescription": {
                "text": "A class that implements IComparable<T> should also implement IEquatable<T>"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0096.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0097",
              "shortDescription": {
                "text": "A class that implements IComparable<T> or IComparable should override comparison operators"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0097.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0098",
              "shortDescription": {
                "text": "Use indexer instead of LINQ methods"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0098.md",
              "properties": {
                "category": "Performance"
              }
            },
            {
              "id": "MA0099",
              "shortDescription": {
                "text": "Use Explicit enum value instead of 0"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0099.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "MA0100",
              "shortDescription": {
                "text": "Await task before disposing of resources"
              },
              "fullDescription": {
                "text": "Await the task before the end of the enclosing using block."
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0100.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "MA0101",
              "shortDescription": {
                "text": "String contains an implicit end of line character"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0101.md",
              "properties": {
                "category": "Usage",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "MA0102",
              "shortDescription": {
                "text": "Make member readonly"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0102.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0103",
              "shortDescription": {
                "text": "Use SequenceEqual instead of equality operator"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0103.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "MA0104",
              "shortDescription": {
                "text": "Do not create a type with a name from the BCL"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0104.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0105",
              "shortDescription": {
                "text": "Use the lambda parameters instead of using a closure"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0105.md",
              "properties": {
                "category": "Performance"
              }
            },
            {
              "id": "MA0106",
              "shortDescription": {
                "text": "Avoid closure by using an overload with the 'factoryArgument' parameter"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0106.md",
              "properties": {
                "category": "Performance"
              }
            },
            {
              "id": "MA0107",
              "shortDescription": {
                "text": "Do not use culture-sensitive object.ToString"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0107.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0108",
              "shortDescription": {
                "text": "Remove redundant argument value"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0108.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "MA0109",
              "shortDescription": {
                "text": "Consider adding an overload with a Span<T> or Memory<T>"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0109.md",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "inSource"
                ]
              }
            },
            {
              "id": "MA0110",
              "shortDescription": {
                "text": "Use the Regex source generator"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0110.md",
              "properties": {
                "category": "Performance"
              }
            },
            {
              "id": "MA0111",
              "shortDescription": {
                "text": "Use string.Create instead of FormattableString"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0111.md",
              "properties": {
                "category": "Performance"
              }
            },
            {
              "id": "MA0112",
              "shortDescription": {
                "text": "Use 'Count > 0' instead of 'Any()'"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0112.md",
              "properties": {
                "category": "Performance"
              }
            },
            {
              "id": "MA0113",
              "shortDescription": {
                "text": "Use DateTime.UnixEpoch"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0113.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0114",
              "shortDescription": {
                "text": "Use DateTimeOffset.UnixEpoch"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0114.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0115",
              "shortDescription": {
                "text": "Unknown component parameter"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0115.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "MA0116",
              "shortDescription": {
                "text": "Parameters with [SupplyParameterFromQuery] attributes should also be marked as [Parameter]"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0116.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0117",
              "shortDescription": {
                "text": "Parameters with [EditorRequired] attributes should also be marked as [Parameter]"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0117.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0118",
              "shortDescription": {
                "text": "[JSInvokable] methods must be public"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0118.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0119",
              "shortDescription": {
                "text": "JSRuntime must not be used in OnInitialized or OnInitializedAsync"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0119.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0120",
              "shortDescription": {
                "text": "Use InvokeVoidAsync when the returned value is not used"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0120.md",
              "properties": {
                "category": "Performance"
              }
            },
            {
              "id": "MA0121",
              "shortDescription": {
                "text": "Do not overwrite parameter value"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0121.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0122",
              "shortDescription": {
                "text": "Parameters with [SupplyParameterFromQuery] attributes are only valid in routable components (@page)"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0122.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0123",
              "shortDescription": {
                "text": "Sequence number must be a constant"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0123.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0124",
              "shortDescription": {
                "text": "Log Parameter type is not valid"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0124.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0125",
              "shortDescription": {
                "text": "The list of log parameter types contains an invalid type"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0125.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0126",
              "shortDescription": {
                "text": "The list of log parameter types contains a duplicate"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0126.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0127",
              "shortDescription": {
                "text": "Use String.Equals instead of is pattern"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0127.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "MA0128",
              "shortDescription": {
                "text": "Use 'is' operator instead of SequenceEqual"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0128.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "MA0129",
              "shortDescription": {
                "text": "Await task in using statement"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0129.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "MA0130",
              "shortDescription": {
                "text": "GetType() should not be used on System.Type instances"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0130.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "MA0131",
              "shortDescription": {
                "text": "ArgumentNullException.ThrowIfNull should not be used with non-nullable types"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0131.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "MA0132",
              "shortDescription": {
                "text": "Do not convert implicitly to DateTimeOffset"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0132.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0133",
              "shortDescription": {
                "text": "Use DateTimeOffset instead of relying on the implicit conversion"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0133.md",
              "properties": {
                "category": "Design"
              }
            },
            {
              "id": "MA0134",
              "shortDescription": {
                "text": "Observe result of async calls"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0134.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "MVC1000",
              "shortDescription": {
                "text": "Use of IHtmlHelper.{0} should be avoided"
              },
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "MVC1001",
              "shortDescription": {
                "text": "Filters cannot be applied to page handler methods"
              },
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "MVC1002",
              "shortDescription": {
                "text": "Route attributes cannot be applied to page handler methods"
              },
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "MVC1003",
              "shortDescription": {
                "text": "Route attributes cannot be applied to page models"
              },
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "MVC1004",
              "shortDescription": {
                "text": "Rename model bound parameter"
              },
              "helpUri": "https://aka.ms/AA20pbc",
              "properties": {
                "category": "Naming"
              }
            },
            {
              "id": "MVC1005",
              "shortDescription": {
                "text": "Cannot use UseMvc with Endpoint Routing"
              },
              "helpUri": "https://aka.ms/YJggeFn",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "MVC1006",
              "shortDescription": {
                "text": "Methods containing TagHelpers must be async and return Task"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "NX0001",
              "shortDescription": {
                "text": "Find general usages of the NullForgiving operator"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-forgiving",
              "properties": {
                "category": "nullable"
              }
            },
            {
              "id": "NX0002",
              "shortDescription": {
                "text": "Find usages of the NullForgiving operator on null or default expression"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-forgiving",
              "properties": {
                "category": "nullable"
              }
            },
            {
              "id": "NX0003",
              "shortDescription": {
                "text": "Find usages of the NullForgiving operator inside lambda expressions"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-forgiving",
              "properties": {
                "category": "nullable"
              }
            },
            {
              "id": "PH2001",
              "shortDescription": {
                "text": "Summary XML comments"
              },
              "fullDescription": {
                "text": "Summary XML comments for classes, methods, etc. must be useful or non-existent."
              },
              "defaultConfiguration": {
                "level": "error",
                "enabled": false
              },
              "properties": {
                "category": "Documentation"
              }
            },
            {
              "id": "PH2006",
              "shortDescription": {
                "text": "Namespace matches File Path"
              },
              "fullDescription": {
                "text": "In order to prevent pollution of namespaces, and maintainability of namespaces, the File Path, Assembly, Project, and Namespace must all match"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Naming",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "PH2020",
              "shortDescription": {
                "text": "Avoid Thread.Sleep"
              },
              "fullDescription": {
                "text": "Methods may not have Thread.Sleep to prevent inaccurate timeout."
              },
              "defaultConfiguration": {
                "level": "error",
                "enabled": false
              },
              "properties": {
                "category": "Maintainability"
              }
            },
            {
              "id": "PH2021",
              "shortDescription": {
                "text": "Do not inline new T() calls"
              },
              "fullDescription": {
                "text": "Create a local variable, or a field for the temporary instance of class '{0}'"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Readability",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "PH2026",
              "shortDescription": {
                "text": "SuppressMessage not allowed"
              },
              "fullDescription": {
                "text": "SuppressMessage results in violations of codified coding guidelines."
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Maintainability",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "PH2027",
              "shortDescription": {
                "text": "Avoid static Methods"
              },
              "fullDescription": {
                "text": "Do not unnecessarily mark methods as static."
              },
              "defaultConfiguration": {
                "level": "error",
                "enabled": false
              },
              "properties": {
                "category": "Maintainability",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "PH2028",
              "shortDescription": {
                "text": "Copyright Present"
              },
              "fullDescription": {
                "text": "File should start with a comment containing the company name, the year and either © or 'Copyright'."
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Documentation",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "PH2029",
              "shortDescription": {
                "text": "Avoid Pragma Warning"
              },
              "fullDescription": {
                "text": "Do not use #pragma warning"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Maintainability",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "PH2030",
              "shortDescription": {
                "text": "Follow variable naming coding guidelines"
              },
              "defaultConfiguration": {
                "level": "error",
                "enabled": false
              },
              "properties": {
                "category": "Naming",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "PH2031",
              "shortDescription": {
                "text": "Do not use TryParse without specifying a culture"
              },
              "fullDescription": {
                "text": "Do not use TryParse without specifying a culture if such an overload exists. Failure to do so may result in code not correctly handling localized delimiters (such as commas instead of decimal points)."
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Maintainability"
              }
            },
            {
              "id": "PH2032",
              "shortDescription": {
                "text": "Avoid Empty Type Initializer"
              },
              "fullDescription": {
                "text": "Remove empty type initializer"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Maintainability"
              }
            },
            {
              "id": "PH2040",
              "shortDescription": {
                "text": "Interfaces marked with [ServiceContract] must have methods marked with [OperationContract]"
              },
              "fullDescription": {
                "text": "Attribute method with [OperationContract]"
              },
              "defaultConfiguration": {
                "level": "error",
                "enabled": false
              },
              "properties": {
                "category": "Maintainability",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "PH2042",
              "shortDescription": {
                "text": "Check for UserControl constructor chains calls to InitializeComponent()"
              },
              "fullDescription": {
                "text": "All UserControl constructor chains must call InitializeComponent()."
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Maintainability",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "PH2044",
              "shortDescription": {
                "text": "Prohibit the \"dynamic\" Keyword"
              },
              "fullDescription": {
                "text": "The \"dynamic\" keyword is not checked for type safety at compile time and is prohibited."
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Maintainability"
              }
            },
            {
              "id": "PH2045",
              "shortDescription": {
                "text": "Avoid static classes"
              },
              "fullDescription": {
                "text": "Static Classes are not easily mockable. Avoid them so that your code is Unit Testable."
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Maintainability",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "PH2047",
              "shortDescription": {
                "text": "Avoid public fields declaration"
              },
              "fullDescription": {
                "text": "Avoid public  fields in a class. Declare public property if needed for static fields"
              },
              "defaultConfiguration": {
                "level": "error",
                "enabled": false
              },
              "properties": {
                "category": "Maintainability"
              }
            },
            {
              "id": "PH2051",
              "shortDescription": {
                "text": "Unnecessary Range Checks"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Readability"
              }
            },
            {
              "id": "PH2060",
              "shortDescription": {
                "text": "Follow variable naming coding guidelines"
              },
              "defaultConfiguration": {
                "level": "error",
                "enabled": false
              },
              "properties": {
                "category": "Naming",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "PH2061",
              "shortDescription": {
                "text": "Enforce Regions"
              },
              "fullDescription": {
                "text": "Given member doesn't belong to region {0}. Change the method's location to its correct region"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Readability"
              }
            },
            {
              "id": "PH2064",
              "shortDescription": {
                "text": "Enforce Non Duplicate Regions"
              },
              "fullDescription": {
                "text": "A Class cannot have regions of the same name"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Readability"
              }
            },
            {
              "id": "PH2065",
              "shortDescription": {
                "text": "Members location relative to regions (Enforce Region Analyzer)."
              },
              "fullDescription": {
                "text": "Member's location relative to region {0} should be verified. Implement the check in enforce region analyer"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Readability"
              }
            },
            {
              "id": "PH2066",
              "shortDescription": {
                "text": "Objects used as locks should be readonly"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Maintainability"
              }
            },
            {
              "id": "PH2067",
              "shortDescription": {
                "text": "Don't nest string.Format (or similar) methods"
              },
              "fullDescription": {
                "text": "Don't nest string.Format (or similar) methods"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Maintainability",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "PH2068",
              "shortDescription": {
                "text": "Do not use goto"
              },
              "fullDescription": {
                "text": "Do not use goto"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Maintainability"
              }
            },
            {
              "id": "PH2069",
              "shortDescription": {
                "text": "Don't call string.Format unnecessarily"
              },
              "fullDescription": {
                "text": "Don't call string.Format unnecessarily"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Maintainability"
              }
            },
            {
              "id": "PH2070",
              "shortDescription": {
                "text": "Do not use protected fields"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Maintainability",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "PH2071",
              "shortDescription": {
                "text": "Avoid Duplicate Code"
              },
              "fullDescription": {
                "text": "Duplicate code is less maintainable"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Maintainability"
              }
            },
            {
              "id": "PH2072",
              "shortDescription": {
                "text": "Missing .editorconfig"
              },
              "fullDescription": {
                "text": ".editorconfig files help enforce and configure Analyzers"
              },
              "defaultConfiguration": {
                "level": "error",
                "enabled": false
              },
              "properties": {
                "category": "Maintainability",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "PH2073",
              "shortDescription": {
                "text": "Call extension methods as if they were instance methods"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Maintainability"
              }
            },
            {
              "id": "PH2074",
              "shortDescription": {
                "text": "Dispose Registration"
              },
              "fullDescription": {
                "text": "MyClass.Event += MyHandler is not allowed in a Dispose method.  Should be MyClass.Event -= MyHandler."
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Maintainability"
              }
            },
            {
              "id": "PH2075",
              "shortDescription": {
                "text": "Avoid AssemblyVersion change"
              },
              "fullDescription": {
                "text": "AssemblyVersion breaks compatibility.  If intentional, specify dotnet_code_quality.PH2075.assembly_version in EditorConfig."
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Runtime Failure",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "PH2077",
              "shortDescription": {
                "text": "Do not use redundant switch statements"
              },
              "fullDescription": {
                "text": "Elide the switch statement"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Readability",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "PH2078",
              "shortDescription": {
                "text": "Do not use PrivateKey property on X509Certificate2 class"
              },
              "fullDescription": {
                "text": "Do not use PrivateKey property on X509Certificate2 class as it might cause the Application to crash. Use a Getter instead. Eg: GetRSAPrivateKey(), GetDSAPrivateKey(), GetECDsaPrivateKey()"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "helpUri": "https://www.pkisolutions.com/accessing-and-using-certificate-private-keys-in-net-framework-net-core/",
              "properties": {
                "category": "Maintainability"
              }
            },
            {
              "id": "PH2079",
              "shortDescription": {
                "text": "Namespace must use  predefined prefixes"
              },
              "fullDescription": {
                "text": "Namespace must use the predefined prefixes configured in the .editorconfig file"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Naming",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "PH2080",
              "shortDescription": {
                "text": "Avoid hardcoded absolute paths"
              },
              "fullDescription": {
                "text": "Avoid hardcoded absolute paths"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Maintainability"
              }
            },
            {
              "id": "PH2081",
              "shortDescription": {
                "text": "No Regions In Methods"
              },
              "fullDescription": {
                "text": "A #region cannot start or end within a method. Consider refactoring long methods instead."
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Maintainability"
              }
            },
            {
              "id": "PH2082",
              "shortDescription": {
                "text": "Positive Naming"
              },
              "fullDescription": {
                "text": "Properties and variables should be named using positive wording."
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Naming",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "PH2083",
              "shortDescription": {
                "text": "Avoid passing parameters by reference"
              },
              "fullDescription": {
                "text": "There is no need to pass parameters by reference if the method does not write to them."
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Maintainability"
              }
            },
            {
              "id": "PH2084",
              "shortDescription": {
                "text": "Don't lock new object"
              },
              "fullDescription": {
                "text": "Lock objects must be sharable between threads"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Maintainability"
              }
            },
            {
              "id": "PH2085",
              "shortDescription": {
                "text": "Accessors should be ordered"
              },
              "fullDescription": {
                "text": "Properties should be ordered get then set (or init)"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Documentation",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "PH2086",
              "shortDescription": {
                "text": "Avoid Task.Result"
              },
              "fullDescription": {
                "text": "To avoid deadlocks, methods may not call Result on a Task."
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "helpUri": "https://docs.microsoft.com/en-us/archive/msdn-magazine/2013/march/async-await-best-practices-in-asynchronous-programming#async-all-the-way",
              "properties": {
                "category": "Maintainability",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "PH2087",
              "shortDescription": {
                "text": "Do not use spaces in file names."
              },
              "fullDescription": {
                "text": "Space in filename/ path."
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Runtime Failure"
              }
            },
            {
              "id": "PH2088",
              "shortDescription": {
                "text": "Path too long, make smaller to avoid $MAX_RELATIVE_PATH_LENGTH limit."
              },
              "fullDescription": {
                "text": "Too long path."
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Runtime Failure",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "PH2089",
              "shortDescription": {
                "text": "Assignment in condition."
              },
              "fullDescription": {
                "text": "Assignment in condition."
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Maintainability"
              }
            },
            {
              "id": "PH2090",
              "shortDescription": {
                "text": "Log caught exceptions."
              },
              "fullDescription": {
                "text": "Log caught exceptions."
              },
              "defaultConfiguration": {
                "level": "error",
                "enabled": false
              },
              "properties": {
                "category": "Maintainability",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "PH2091",
              "shortDescription": {
                "text": "Use inner exceptions for unhandled exceptions"
              },
              "fullDescription": {
                "text": "Use inner exceptions for unhandled exceptions"
              },
              "defaultConfiguration": {
                "level": "error",
                "enabled": false
              },
              "properties": {
                "category": "Maintainability"
              }
            },
            {
              "id": "PH2092",
              "shortDescription": {
                "text": "Limit the number of clauses in a condition"
              },
              "fullDescription": {
                "text": "Limit the number of clauses in a condition"
              },
              "defaultConfiguration": {
                "level": "error",
                "enabled": false
              },
              "properties": {
                "category": "Readability"
              }
            },
            {
              "id": "PH2093",
              "shortDescription": {
                "text": "Prefer tuples that have names"
              },
              "fullDescription": {
                "text": "Name this tuple field for readability"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Readability"
              }
            },
            {
              "id": "PH2094",
              "shortDescription": {
                "text": "Prefer tuple field names over generic item1, item2, etc"
              },
              "fullDescription": {
                "text": "For readability use the name provided for this field, not a generic field name"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Readability"
              }
            },
            {
              "id": "PH2096",
              "shortDescription": {
                "text": "Avoid async void"
              },
              "fullDescription": {
                "text": "To avoid unhandled exception, methods should not use async void unless a event handler."
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "helpUri": "https://docs.microsoft.com/en-us/archive/msdn-magazine/2013/march/async-await-best-practices-in-asynchronous-programming#avoid-async-void",
              "properties": {
                "category": "Maintainability",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "PH2097",
              "shortDescription": {
                "text": "Avoid empty statement blocks"
              },
              "fullDescription": {
                "text": "Avoid empty statement blocks"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Maintainability",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "PH2098",
              "shortDescription": {
                "text": "Avoid empty catch blocks"
              },
              "fullDescription": {
                "text": "Avoid empty catch blocks"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Maintainability",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "PH2099",
              "shortDescription": {
                "text": "Ensure FileVersion is the same as PackageVersion"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Maintainability",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "PH2101",
              "shortDescription": {
                "text": "Dereference Null after As"
              },
              "fullDescription": {
                "text": "Using the 'as' expression means a check should be made before dereferencing, or cast if you definitively know it will be this type in this context."
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Runtime Failure"
              }
            },
            {
              "id": "PH2102",
              "shortDescription": {
                "text": "Documentation text should add value"
              },
              "fullDescription": {
                "text": "Summary XML comments for classes, methods, etc. must add more information then just repeating its name."
              },
              "defaultConfiguration": {
                "level": "error",
                "enabled": false
              },
              "properties": {
                "category": "Documentation"
              }
            },
            {
              "id": "RCS1001",
              "shortDescription": {
                "text": "Add braces (when expression spans over multiple lines)."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1001",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1002",
              "shortDescription": {
                "text": "Remove braces."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1002",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1002FadeOut",
              "shortDescription": {
                "text": "Remove braces."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1003",
              "shortDescription": {
                "text": "Add braces to if-else (when expression spans over multiple lines)."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1003",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1004",
              "shortDescription": {
                "text": "Remove braces from if-else."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1004",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1004FadeOut",
              "shortDescription": {
                "text": "Remove braces from if-else."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1005",
              "shortDescription": {
                "text": "Simplify nested using statement."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1005",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1005FadeOut",
              "shortDescription": {
                "text": "Simplify nested using statement."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1006",
              "shortDescription": {
                "text": "Merge 'else' with nested 'if'."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1006",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1006FadeOut",
              "shortDescription": {
                "text": "Merge 'else' with nested 'if'."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1007",
              "shortDescription": {
                "text": "Add braces."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1007",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "RCS1008",
              "shortDescription": {
                "text": "Use explicit type instead of 'var' (when the type is not obvious)."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1008",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "RCS1009",
              "shortDescription": {
                "text": "Use explicit type instead of 'var' (foreach variable)."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1009",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "RCS1010",
              "shortDescription": {
                "text": "Use 'var' instead of explicit type (when the type is obvious)."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1010",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1012",
              "shortDescription": {
                "text": "Use explicit type instead of 'var' (when the type is obvious)."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1012",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "RCS1013",
              "shortDescription": {
                "text": "Use predefined type."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1013",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1014",
              "shortDescription": {
                "text": "Use explicitly/implicitly typed array."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1014",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "RCS1015",
              "shortDescription": {
                "text": "Use nameof operator."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1015",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1015FadeOut",
              "shortDescription": {
                "text": "Use nameof operator."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1016",
              "shortDescription": {
                "text": "Use block body or expression body."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1016",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "RCS1018",
              "shortDescription": {
                "text": "Add/remove accessibility modifiers."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1018",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "RCS1019",
              "shortDescription": {
                "text": "Order modifiers."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1019",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "RCS1020",
              "shortDescription": {
                "text": "Simplify Nullable<T> to T?."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1020",
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1021",
              "shortDescription": {
                "text": "Convert lambda expression body to expression body."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1021",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1021FadeOut",
              "shortDescription": {
                "text": "Convert lambda expression body to expression body."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1031",
              "shortDescription": {
                "text": "Remove unnecessary braces in switch section."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1031",
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1031FadeOut",
              "shortDescription": {
                "text": "Remove unnecessary braces in switch section."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1032",
              "shortDescription": {
                "text": "Remove redundant parentheses."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1032",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1032FadeOut",
              "shortDescription": {
                "text": "Remove redundant parentheses."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1033",
              "shortDescription": {
                "text": "Remove redundant boolean literal."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1033",
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1034",
              "shortDescription": {
                "text": "Remove redundant 'sealed' modifier."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1034",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1035",
              "shortDescription": {
                "text": "Remove redundant comma in initializer."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1035",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1036",
              "shortDescription": {
                "text": "Remove unnecessary blank line."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1036",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1037",
              "shortDescription": {
                "text": "Remove trailing white-space."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1037",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1038",
              "shortDescription": {
                "text": "Remove empty statement."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1038",
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1039",
              "shortDescription": {
                "text": "Remove argument list from attribute."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1039",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1040",
              "shortDescription": {
                "text": "Remove empty 'else' clause."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1040",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1041",
              "shortDescription": {
                "text": "Remove empty initializer."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1041",
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1042",
              "shortDescription": {
                "text": "Remove enum default underlying type."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1042",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1043",
              "shortDescription": {
                "text": "Remove 'partial' modifier from type with a single part."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1043",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1044",
              "shortDescription": {
                "text": "Remove original exception from throw statement."
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1044",
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1046",
              "shortDescription": {
                "text": "Asynchronous method name should end with 'Async'."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1046",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1047",
              "shortDescription": {
                "text": "Non-asynchronous method name should not end with 'Async'."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1047",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1047FadeOut",
              "shortDescription": {
                "text": "Non-asynchronous method name should not end with 'Async'."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1048",
              "shortDescription": {
                "text": "Use lambda expression instead of anonymous method."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1048",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1048FadeOut",
              "shortDescription": {
                "text": "Use lambda expression instead of anonymous method."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1049",
              "shortDescription": {
                "text": "Simplify boolean comparison."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1049",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1049FadeOut",
              "shortDescription": {
                "text": "Simplify boolean comparison."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1050",
              "shortDescription": {
                "text": "Include/omit parentheses when creating new object."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1050",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1051",
              "shortDescription": {
                "text": "Add/remove parentheses from condition in conditional operator."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1051",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "RCS1052",
              "shortDescription": {
                "text": "Declare each attribute separately."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1052",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "RCS1055",
              "shortDescription": {
                "text": "Avoid semicolon at the end of declaration."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1055",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1056",
              "shortDescription": {
                "text": "Avoid usage of using alias directive."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1056",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1058",
              "shortDescription": {
                "text": "Use compound assignment."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1058",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1058FadeOut",
              "shortDescription": {
                "text": "Use compound assignment."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1059",
              "shortDescription": {
                "text": "Avoid locking on publicly accessible instance."
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1059",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1060",
              "shortDescription": {
                "text": "Declare each type in separate file."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1060",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1061",
              "shortDescription": {
                "text": "Merge 'if' with nested 'if'."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1061",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1061FadeOut",
              "shortDescription": {
                "text": "Merge 'if' with nested 'if'."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1063",
              "shortDescription": {
                "text": "([deprecated] use RCS1252 instead) Avoid usage of do statement to create an infinite loop."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1063",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1064",
              "shortDescription": {
                "text": "([deprecated] use RCS1252 instead) Avoid usage of for statement to create an infinite loop."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1064",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "RCS1065",
              "shortDescription": {
                "text": "([deprecated] use RCS1252 instead) Avoid usage of while statement to create an infinite loop."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1065",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "RCS1066",
              "shortDescription": {
                "text": "Remove empty 'finally' clause."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1066",
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1066FadeOut",
              "shortDescription": {
                "text": "Remove empty 'finally' clause."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1068",
              "shortDescription": {
                "text": "Simplify logical negation."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1068",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1069",
              "shortDescription": {
                "text": "Remove unnecessary case label."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1069",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1070",
              "shortDescription": {
                "text": "Remove redundant default switch section."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1070",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1071",
              "shortDescription": {
                "text": "Remove redundant base constructor call."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1071",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1072",
              "shortDescription": {
                "text": "Remove empty namespace declaration."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1072",
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1073",
              "shortDescription": {
                "text": "Convert 'if' to 'return' statement."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1073",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1073FadeOut",
              "shortDescription": {
                "text": "Convert 'if' to 'return' statement."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1074",
              "shortDescription": {
                "text": "Remove redundant constructor."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1074",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1075",
              "shortDescription": {
                "text": "Avoid empty catch clause that catches System.Exception."
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1075",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1077",
              "shortDescription": {
                "text": "Optimize LINQ method call."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1077",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1078",
              "shortDescription": {
                "text": "Use \"\" or 'string.Empty'."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1078",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1079",
              "shortDescription": {
                "text": "Throwing of new NotImplementedException."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1079",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "RCS1080",
              "shortDescription": {
                "text": "Use 'Count/Length' property instead of 'Any' method."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1080",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1081",
              "shortDescription": {
                "text": "Split variable declaration."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1081",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "RCS1084",
              "shortDescription": {
                "text": "Use coalesce expression instead of conditional expression."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1084",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1085",
              "shortDescription": {
                "text": "Use auto-implemented property."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1085",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1085FadeOut",
              "shortDescription": {
                "text": "Use auto-implemented property."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1089",
              "shortDescription": {
                "text": "Use --/++ operator instead of assignment."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1089",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1089FadeOut",
              "shortDescription": {
                "text": "Use --/++ operator instead of assignment."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1090",
              "shortDescription": {
                "text": "Add/remove 'ConfigureAwait(false)' call."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1090",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "RCS1091",
              "shortDescription": {
                "text": "Remove empty region."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1091",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1091FadeOut",
              "shortDescription": {
                "text": "Remove empty region."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1093",
              "shortDescription": {
                "text": "Remove file with no code."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1093",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1094",
              "shortDescription": {
                "text": "Declare using directive on top level."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1094",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "RCS1096",
              "shortDescription": {
                "text": "Use 'HasFlag' method or bitwise operator."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1096",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "RCS1097",
              "shortDescription": {
                "text": "Remove redundant 'ToString' call."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1097",
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1098",
              "shortDescription": {
                "text": "Constant values should be placed on right side of comparisons."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1098",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1099",
              "shortDescription": {
                "text": "Default label should be the last label in a switch section."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1099",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1100",
              "shortDescription": {
                "text": "([deprecated] use RCS1253 instead) Format documentation summary on a single line."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1100",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "RCS1101",
              "shortDescription": {
                "text": "([deprecated] use RCS1253 instead) Format documentation summary on multiple lines."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1101",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "RCS1102",
              "shortDescription": {
                "text": "Make class static."
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1102",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1103",
              "shortDescription": {
                "text": "Convert 'if' to assignment."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1103",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1104",
              "shortDescription": {
                "text": "Simplify conditional expression."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1104",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1105",
              "shortDescription": {
                "text": "Unnecessary interpolation."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1105",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1106",
              "shortDescription": {
                "text": "Remove empty destructor."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1106",
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1107",
              "shortDescription": {
                "text": "Remove redundant 'ToCharArray' call."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1107",
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1108",
              "shortDescription": {
                "text": "Add 'static' modifier to all partial class declarations."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1108",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1110",
              "shortDescription": {
                "text": "Declare type inside namespace."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1110",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1111",
              "shortDescription": {
                "text": "Add braces to switch section with multiple statements."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1111",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "RCS1112",
              "shortDescription": {
                "text": "Combine 'Enumerable.Where' method chain."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1112",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1112FadeOut",
              "shortDescription": {
                "text": "Combine 'Enumerable.Where' method chain."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1113",
              "shortDescription": {
                "text": "Use 'string.IsNullOrEmpty' method."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1113",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1114",
              "shortDescription": {
                "text": "Remove redundant delegate creation."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1114",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1114FadeOut",
              "shortDescription": {
                "text": "Remove redundant delegate creation."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1118",
              "shortDescription": {
                "text": "Mark local variable as const."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1118",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1123",
              "shortDescription": {
                "text": "Add parentheses when necessary."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1123",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1124",
              "shortDescription": {
                "text": "Inline local variable."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1124",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "RCS1124FadeOut",
              "shortDescription": {
                "text": "Inline local variable."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1126",
              "shortDescription": {
                "text": "Add braces to if-else."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1126",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1128",
              "shortDescription": {
                "text": "Use coalesce expression."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1128",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1129",
              "shortDescription": {
                "text": "Remove redundant field initialization."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1129",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1130",
              "shortDescription": {
                "text": "Bitwise operation on enum without Flags attribute."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1130",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1132",
              "shortDescription": {
                "text": "Remove redundant overriding member."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1132",
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1133",
              "shortDescription": {
                "text": "Remove redundant Dispose/Close call."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1133",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1134",
              "shortDescription": {
                "text": "Remove redundant statement."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1134",
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1135",
              "shortDescription": {
                "text": "Declare enum member with zero value (when enum has FlagsAttribute)."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1135",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1136",
              "shortDescription": {
                "text": "Merge switch sections with equivalent content."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1136",
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1138",
              "shortDescription": {
                "text": "Add summary to documentation comment."
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1138",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1139",
              "shortDescription": {
                "text": "Add summary element to documentation comment."
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1139",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1140",
              "shortDescription": {
                "text": "Add exception to documentation comment."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1140",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "RCS1141",
              "shortDescription": {
                "text": "Add 'param' element to documentation comment."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1141",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1142",
              "shortDescription": {
                "text": "Add 'typeparam' element to documentation comment."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1142",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1143",
              "shortDescription": {
                "text": "Simplify coalesce expression."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1143",
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1145",
              "shortDescription": {
                "text": "Remove redundant 'as' operator."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1145",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1146",
              "shortDescription": {
                "text": "Use conditional access."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1146",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1151",
              "shortDescription": {
                "text": "Remove redundant cast."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1151",
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1154",
              "shortDescription": {
                "text": "Sort enum members."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1154",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1155",
              "shortDescription": {
                "text": "Use StringComparison when comparing strings."
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1155",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1156",
              "shortDescription": {
                "text": "Use string.Length instead of comparison with empty string."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1156",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1157",
              "shortDescription": {
                "text": "Composite enum value contains undefined flag."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1157",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1158",
              "shortDescription": {
                "text": "Static member in generic type should use a type parameter."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1158",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1159",
              "shortDescription": {
                "text": "Use EventHandler<T>."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1159",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1160",
              "shortDescription": {
                "text": "Abstract type should not have public constructors."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1160",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1161",
              "shortDescription": {
                "text": "Enum should declare explicit values."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1161",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "RCS1162",
              "shortDescription": {
                "text": "Avoid chain of assignments."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1162",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "RCS1163",
              "shortDescription": {
                "text": "Unused parameter."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1163",
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1164",
              "shortDescription": {
                "text": "Unused type parameter."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1164",
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1165",
              "shortDescription": {
                "text": "Unconstrained type parameter checked for null."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1165",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "RCS1166",
              "shortDescription": {
                "text": "Value type object is never equal to null."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1166",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1168",
              "shortDescription": {
                "text": "Parameter name differs from base name."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1168",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1169",
              "shortDescription": {
                "text": "Make field read-only."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1169",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1170",
              "shortDescription": {
                "text": "Use read-only auto-implemented property."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1170",
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1171",
              "shortDescription": {
                "text": "Simplify lazy initialization."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1171",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1172",
              "shortDescription": {
                "text": "Use 'is' operator instead of 'as' operator."
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1172",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1173",
              "shortDescription": {
                "text": "Use coalesce expression instead of 'if'."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1173",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1174",
              "shortDescription": {
                "text": "Remove redundant async/await."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1174",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1174FadeOut",
              "shortDescription": {
                "text": "Remove redundant async/await."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1175",
              "shortDescription": {
                "text": "Unused 'this' parameter."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1175",
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1176",
              "shortDescription": {
                "text": "Use 'var' instead of explicit type (when the type is not obvious)."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1176",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "RCS1177",
              "shortDescription": {
                "text": "Use 'var' instead of explicit type (in foreach)."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1177",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "RCS1179",
              "shortDescription": {
                "text": "Unnecessary assignment."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1179",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1180",
              "shortDescription": {
                "text": "Inline lazy initialization."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1180",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1181",
              "shortDescription": {
                "text": "Convert comment to documentation comment."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1181",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "RCS1182",
              "shortDescription": {
                "text": "Remove redundant base interface."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1182",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1186",
              "shortDescription": {
                "text": "Use Regex instance instead of static method."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1186",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1187",
              "shortDescription": {
                "text": "Use constant instead of field."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1187",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1188",
              "shortDescription": {
                "text": "Remove redundant auto-property initialization."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1188",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1189",
              "shortDescription": {
                "text": "Add or remove region name."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1189",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "RCS1190",
              "shortDescription": {
                "text": "Join string expressions."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1190",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1191",
              "shortDescription": {
                "text": "Declare enum value as combination of names."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1191",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1192",
              "shortDescription": {
                "text": "Unnecessary usage of verbatim string literal."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1192",
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1193",
              "shortDescription": {
                "text": "Overriding member should not change 'params' modifier."
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1193",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1194",
              "shortDescription": {
                "text": "Implement exception constructors."
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1194",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1195",
              "shortDescription": {
                "text": "Use ^ operator."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1195",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1196",
              "shortDescription": {
                "text": "Call extension method as instance method."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1196",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1197",
              "shortDescription": {
                "text": "Optimize StringBuilder.Append/AppendLine call."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1197",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1198",
              "shortDescription": {
                "text": "Avoid unnecessary boxing of value type."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1198",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "RCS1199",
              "shortDescription": {
                "text": "Unnecessary null check."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1199",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1200",
              "shortDescription": {
                "text": "Call 'Enumerable.ThenBy' instead of 'Enumerable.OrderBy'."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1200",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1201",
              "shortDescription": {
                "text": "Use method chaining."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1201",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1202",
              "shortDescription": {
                "text": "Avoid NullReferenceException."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1202",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1203",
              "shortDescription": {
                "text": "Use AttributeUsageAttribute."
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1203",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1204",
              "shortDescription": {
                "text": "Use EventArgs.Empty."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1204",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1205",
              "shortDescription": {
                "text": "Order named arguments according to the order of parameters."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1205",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1206",
              "shortDescription": {
                "text": "Use conditional access instead of conditional expression."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1206",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1207",
              "shortDescription": {
                "text": "Use anonymous function or method group."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1207",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "RCS1208",
              "shortDescription": {
                "text": "Reduce 'if' nesting."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1208",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "RCS1209",
              "shortDescription": {
                "text": "Order type parameter constraints."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1209",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1210",
              "shortDescription": {
                "text": "Return completed task instead of returning null."
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1210",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1211",
              "shortDescription": {
                "text": "Remove unnecessary 'else'."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1211",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "RCS1212",
              "shortDescription": {
                "text": "Remove redundant assignment."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1212",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1212FadeOut",
              "shortDescription": {
                "text": "Remove redundant assignment."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1213",
              "shortDescription": {
                "text": "Remove unused member declaration."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1213",
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1214",
              "shortDescription": {
                "text": "Unnecessary interpolated string."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1214",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1214FadeOut",
              "shortDescription": {
                "text": "Unnecessary interpolated string."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1215",
              "shortDescription": {
                "text": "Expression is always equal to true/false."
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1215",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1216",
              "shortDescription": {
                "text": "Unnecessary unsafe context."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1216",
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1217",
              "shortDescription": {
                "text": "Convert interpolated string to concatenation."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1217",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1217FadeOut",
              "shortDescription": {
                "text": "Convert interpolated string to concatenation."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1218",
              "shortDescription": {
                "text": "Simplify code branching."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1218",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1220",
              "shortDescription": {
                "text": "Use pattern matching instead of combination of 'is' operator and cast operator."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1220",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1221",
              "shortDescription": {
                "text": "Use pattern matching instead of combination of 'as' operator and null check."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1221",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1222",
              "shortDescription": {
                "text": "Merge preprocessor directives."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1222",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1223",
              "shortDescription": {
                "text": "Mark publicly visible type with DebuggerDisplay attribute."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1223",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "RCS1224",
              "shortDescription": {
                "text": "Make method an extension method."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1224",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1225",
              "shortDescription": {
                "text": "Make class sealed."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1225",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1226",
              "shortDescription": {
                "text": "Add paragraph to documentation comment."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1226",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1227",
              "shortDescription": {
                "text": "Validate arguments correctly."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1227",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1228",
              "shortDescription": {
                "text": "Unused element in documentation comment."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1228",
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1228FadeOut",
              "shortDescription": {
                "text": "Unused element in documentation comment."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1229",
              "shortDescription": {
                "text": "Use async/await when necessary."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1229",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1230",
              "shortDescription": {
                "text": "Unnecessary explicit use of enumerator."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1230",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1231",
              "shortDescription": {
                "text": "Make parameter ref read-only."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1231",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1232",
              "shortDescription": {
                "text": "Order elements in documentation comment."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1232",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1233",
              "shortDescription": {
                "text": "Use short-circuiting operator."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1233",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1234",
              "shortDescription": {
                "text": "Duplicate enum value."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1234",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1235",
              "shortDescription": {
                "text": "Optimize method call."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1235",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1236",
              "shortDescription": {
                "text": "Use exception filter."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1236",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1237",
              "shortDescription": {
                "text": "([deprecated] use RCS1254 instead) Use bit shift operator."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1237",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1238",
              "shortDescription": {
                "text": "Avoid nested ?: operators."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1238",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1239",
              "shortDescription": {
                "text": "Use 'for' statement instead of 'while' statement."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1239",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1240",
              "shortDescription": {
                "text": "Operator is unnecessary."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1240",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1241",
              "shortDescription": {
                "text": "Implement non-generic counterpart."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1241",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "RCS1242",
              "shortDescription": {
                "text": "Do not pass non-read-only struct by read-only reference."
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1242",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1243",
              "shortDescription": {
                "text": "Duplicate word in a comment."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1243",
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1244",
              "shortDescription": {
                "text": "Simplify 'default' expression."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1244",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1246",
              "shortDescription": {
                "text": "Use element access."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1246",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1247",
              "shortDescription": {
                "text": "Fix documentation comment tag."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1247",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1248",
              "shortDescription": {
                "text": "Normalize null check."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1248",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "RCS1249",
              "shortDescription": {
                "text": "Unnecessary null-forgiving operator."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1249",
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1250",
              "shortDescription": {
                "text": "Use implicit/explicit object creation."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1250",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "RCS1251",
              "shortDescription": {
                "text": "Remove unnecessary braces from record declaration."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1251",
              "properties": {
                "category": "Roslynator",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1252",
              "shortDescription": {
                "text": "Normalize usage of infinite loop."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1252",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "RCS1253",
              "shortDescription": {
                "text": "Format documentation comment summary."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1253",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "RCS1254",
              "shortDescription": {
                "text": "Normalize format of enum flag value."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1254",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RCS1255",
              "shortDescription": {
                "text": "Simplify argument null check."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1255",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "RCS1256",
              "shortDescription": {
                "text": "Invalid argument null check."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=RCS1256",
              "properties": {
                "category": "Roslynator"
              }
            },
            {
              "id": "RemoveUnnecessaryImportsFixable",
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Style",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Never",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "ROS0002",
              "shortDescription": {
                "text": "Analyzer option is obsolete"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=",
              "properties": {
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "ROS0003",
              "shortDescription": {
                "text": "Analyzer requires config option to be specified"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "http://pihrt.net/roslynator/analyzer?id=",
              "properties": {
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "S100",
              "shortDescription": {
                "text": "Methods and properties should be named in PascalCase"
              },
              "fullDescription": {
                "text": "Shared naming conventions allow teams to collaborate efficiently. This rule checks whether or not method and property names are PascalCased. To reduce noise, two consecutive upper case characters are allowed unless they form the whole name. So, MyXMethod is compliant, but XM on its own is not."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-100",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S1006",
              "shortDescription": {
                "text": "Method overrides should not change parameter defaults"
              },
              "fullDescription": {
                "text": "Default arguments are determined by the static type of the object. If a default argument is different for a parameter in an overriding method, the value used in the call will be different when calls are made via the base or derived object, which may be contrary to developer expectations."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1006",
              "properties": {
                "category": "Critical Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S101",
              "shortDescription": {
                "text": "Types should be named in PascalCase"
              },
              "fullDescription": {
                "text": "Shared naming conventions allow teams to collaborate efficiently. This rule checks whether or not type names are using PascalCase. To reduce noise, two consecutive upper case characters are allowed unless they form the whole type name. So, MyXClass is compliant, but XC on its own is not."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-101",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S103",
              "shortDescription": {
                "text": "Lines should not be too long"
              },
              "fullDescription": {
                "text": "Having to scroll horizontally makes it harder to get a quick overview and understanding of any piece of code."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-103",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S104",
              "shortDescription": {
                "text": "Files should not have too many lines of code"
              },
              "fullDescription": {
                "text": "A source file that grows too much tends to aggregate too many responsibilities and inevitably becomes harder to understand and therefore to maintain. Above a specific threshold, it is strongly advised to refactor it into smaller pieces of code which focus on well defined tasks. Those smaller files will not only be easier to understand but also probably easier to test."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-104",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S1048",
              "shortDescription": {
                "text": "Destructors should not throw exceptions"
              },
              "fullDescription": {
                "text": "If Finalize or an override of Finalize throws an exception, and the runtime is not hosted by an application that overrides the default policy, the runtime terminates the process immediately without graceful cleanup (finally blocks and finalizers are not executed). This behavior ensures process integrity if the finalizer cannot free or destroy resources."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1048",
              "properties": {
                "category": "Blocker Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S105",
              "shortDescription": {
                "text": "Tabulation characters should not be used"
              },
              "fullDescription": {
                "text": "Developers should not need to configure the tab width of their text editors in order to be able to read source code."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-105",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S106",
              "shortDescription": {
                "text": "Standard outputs should not be used directly to log anything"
              },
              "fullDescription": {
                "text": "When logging a message there are several important requirements which must be fulfilled:"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-106",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S1066",
              "shortDescription": {
                "text": "Collapsible \"if\" statements should be merged"
              },
              "fullDescription": {
                "text": "Merging collapsible if statements increases the code’s readability."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1066",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1067",
              "shortDescription": {
                "text": "Expressions should not be too complex"
              },
              "fullDescription": {
                "text": "The complexity of an expression is defined by the number of &&, || and condition ? ifTrue : ifFalse operators it contains."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1067",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S107",
              "shortDescription": {
                "text": "Methods should not have too many parameters"
              },
              "fullDescription": {
                "text": "A long parameter list can indicate that a new structure should be created to wrap the numerous parameters or that the function is doing too many things."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-107",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1075",
              "shortDescription": {
                "text": "URIs should not be hardcoded"
              },
              "fullDescription": {
                "text": "Hardcoding a URI makes it difficult to test a program: path literals are not always portable across operating systems, a given absolute path may not exist on a specific test environment, a specified Internet URL may not be available when executing the tests, production environment filesystems usually differ from the development environment, …​etc. For all those reasons, a URI should never be hardcoded. Instead, it should be replaced by customizable parameter."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1075",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S108",
              "shortDescription": {
                "text": "Nested blocks of code should not be left empty"
              },
              "fullDescription": {
                "text": "Most of the time a block of code is empty when a piece of code is really missing. So such empty block must be either filled or removed."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-108",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S109",
              "shortDescription": {
                "text": "Magic numbers should not be used"
              },
              "fullDescription": {
                "text": "A magic number is a number that comes out of nowhere, and is directly used in a statement. Magic numbers are often used, for instance to limit the number of iterations of a loop, to test the value of a property, etc."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-109",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S110",
              "shortDescription": {
                "text": "Inheritance tree of classes should not be too deep"
              },
              "fullDescription": {
                "text": "Inheritance is certainly one of the most valuable concepts in object-oriented programming. It’s a way to compartmentalize and reuse code by creating collections of attributes and behaviors called classes which can be based on previously created classes. But abusing this concept by creating a deep inheritance tree can lead to very complex and unmaintainable source code. Most of the time a too deep inheritance tree is due to bad object oriented design which has led to systematically use 'inheritance' when for instance 'composition' would suit better."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-110",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1104",
              "shortDescription": {
                "text": "Fields should not have public accessibility"
              },
              "fullDescription": {
                "text": "Public fields in public classes do not respect the encapsulation principle and has three main disadvantages:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1104",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1109",
              "shortDescription": {
                "text": "A close curly brace should be located at the beginning of a line"
              },
              "fullDescription": {
                "text": "Shared coding conventions make it possible for a team to efficiently collaborate. This rule makes it mandatory to place a close curly brace at the beginning of a line."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1109",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S1110",
              "shortDescription": {
                "text": "Redundant pairs of parentheses should be removed"
              },
              "fullDescription": {
                "text": "The use of parentheses, even those not required to enforce a desired order of operations, can clarify the intent behind a piece of code. But redundant pairs of parentheses could be misleading, and should be removed."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1110",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1116",
              "shortDescription": {
                "text": "Empty statements should be removed"
              },
              "fullDescription": {
                "text": "Empty statements, i.e. ;, are usually introduced by mistake, for example because:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1116",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1117",
              "shortDescription": {
                "text": "Local variables should not shadow class fields"
              },
              "fullDescription": {
                "text": "Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of code. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1117",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1118",
              "shortDescription": {
                "text": "Utility classes should not have public constructors"
              },
              "fullDescription": {
                "text": "Utility classes, which are collections of static members, are not meant to be instantiated."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1118",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S112",
              "shortDescription": {
                "text": "General exceptions should never be thrown"
              },
              "fullDescription": {
                "text": "Throwing such general exceptions as Exception, SystemException, ApplicationException, IndexOutOfRangeException, NullReferenceException, OutOfMemoryException and ExecutionEngineException prevents calling methods from handling true, system-generated exceptions differently than application-generated errors."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-112",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1121",
              "shortDescription": {
                "text": "Assignments should not be made from within sub-expressions"
              },
              "fullDescription": {
                "text": "Assignments within sub-expressions are hard to spot and therefore make the code less readable. Ideally, sub-expressions should not have side-effects."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1121",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1123",
              "shortDescription": {
                "text": "\"Obsolete\" attributes should include explanations"
              },
              "fullDescription": {
                "text": "The Obsolete attribute can be applied with or without a message argument. Marking something Obsolete without including advice on why it’s obsolete or what to use instead will lead maintainers to waste time trying to figure those things out."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1123",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1125",
              "shortDescription": {
                "text": "Boolean literals should not be redundant"
              },
              "fullDescription": {
                "text": "Redundant Boolean literals should be removed from expressions to improve readability."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1125",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1128",
              "shortDescription": {
                "text": "Unused \"using\" should be removed"
              },
              "fullDescription": {
                "text": "Although unnecessary using won’t change anything to the produced application, removing them:"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1128",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S113",
              "shortDescription": {
                "text": "Files should contain an empty newline at the end"
              },
              "fullDescription": {
                "text": "Some tools work better when files end with an empty line."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-113",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S1133",
              "shortDescription": {
                "text": "Deprecated code should be removed"
              },
              "fullDescription": {
                "text": "This rule is meant to be used as a way to track code which is marked as being deprecated. Deprecated code should eventually be removed."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1133",
              "properties": {
                "category": "Info Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1134",
              "shortDescription": {
                "text": "Track uses of \"FIXME\" tags"
              },
              "fullDescription": {
                "text": "FIXME tags are commonly used to mark places where a bug is suspected, but which the developer wants to deal with later."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1134",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1135",
              "shortDescription": {
                "text": "Track uses of \"TODO\" tags"
              },
              "fullDescription": {
                "text": "TODO tags are commonly used to mark places where some more code is required, but which the developer wants to implement later."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1135",
              "properties": {
                "category": "Info Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1144",
              "shortDescription": {
                "text": "Unused private types or members should be removed"
              },
              "fullDescription": {
                "text": "private or internal types or private members that are never executed or referenced are dead code: unnecessary, inoperative code that should be removed. Cleaning out dead code decreases the size of the maintained codebase, making it easier to understand the program and preventing bugs from being introduced."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1144",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1147",
              "shortDescription": {
                "text": "Exit methods should not be called"
              },
              "fullDescription": {
                "text": "Calling Environment.Exit(exitCode) or Application.Exit() terminates the process and returns an exit code to the operating system.."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1147",
              "properties": {
                "category": "Blocker Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S1151",
              "shortDescription": {
                "text": "\"switch case\" clauses should not have too many lines of code"
              },
              "fullDescription": {
                "text": "The switch statement should be used only to clearly define some new branches in the control flow. As soon as a case clause contains too many statements this highly decreases the readability of the overall control flow statement. In such case, the content of the case clause should be extracted into a dedicated method."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1151",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S1155",
              "shortDescription": {
                "text": "\"Any()\" should be used to test for emptiness"
              },
              "fullDescription": {
                "text": "Using .Count() to test for emptiness works, but using .Any() makes the intent clearer, and the code more readable. However, there are some cases where special attention should be paid:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1155",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1163",
              "shortDescription": {
                "text": "Exceptions should not be thrown in finally blocks"
              },
              "fullDescription": {
                "text": "Throwing an exception from within a finally block will mask any exception which was previously thrown in the try or catch block, and the masked’s exception message and stack trace will be lost."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1163",
              "properties": {
                "category": "Critical Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1168",
              "shortDescription": {
                "text": "Empty arrays and collections should be returned instead of null"
              },
              "fullDescription": {
                "text": "Returning null or default instead of an actual collection forces the method callers to explicitly test for null, making the code more complex and less readable."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1168",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1172",
              "shortDescription": {
                "text": "Unused method parameters should be removed"
              },
              "fullDescription": {
                "text": "Unused parameters are misleading. Whatever the values passed to such parameters, the behavior will be the same."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1172",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1185",
              "shortDescription": {
                "text": "Overriding members should do more than simply call the same member in the base class"
              },
              "fullDescription": {
                "text": "Overriding a method just to call the same method from the base class without performing any other actions is useless and misleading. The only time this is justified is in sealed overriding methods, where the effect is to lock in the parent class behavior. This rule ignores overrides of Equals and GetHashCode."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1185",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1186",
              "shortDescription": {
                "text": "Methods should not be empty"
              },
              "fullDescription": {
                "text": "There are several reasons for a method not to have a method body:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1186",
              "properties": {
                "category": "Critical Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1192",
              "shortDescription": {
                "text": "String literals should not be duplicated"
              },
              "fullDescription": {
                "text": "Duplicated string literals make the process of refactoring error-prone, since you must be sure to update all occurrences."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1192",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S1199",
              "shortDescription": {
                "text": "Nested code blocks should not be used"
              },
              "fullDescription": {
                "text": "Nested code blocks can be used to create a new scope and restrict the visibility of the variables defined inside it. Using this feature in a method typically indicates that the method has too many responsibilities, and should be refactored into smaller methods."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1199",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1200",
              "shortDescription": {
                "text": "Classes should not be coupled to too many other classes (Single Responsibility Principle)"
              },
              "fullDescription": {
                "text": "According to the Single Responsibility Principle, introduced by Robert C. Martin in his book \"Principles of Object Oriented Design\", a class should have only one responsibility:"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1200",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S1206",
              "shortDescription": {
                "text": "\"Equals(Object)\" and \"GetHashCode()\" should be overridden in pairs"
              },
              "fullDescription": {
                "text": "There is a contract between Equals(object) and GetHashCode(): If two objects are equal according to the Equals(object) method, then calling GetHashCode() on each of them must yield the same result. If this is not the case, many collections won’t handle class instances correctly."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1206",
              "properties": {
                "category": "Minor Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S121",
              "shortDescription": {
                "text": "Control structures should use curly braces"
              },
              "fullDescription": {
                "text": "While not technically incorrect, the omission of curly braces can be misleading, and may lead to the introduction of errors during maintenance."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-121",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S1210",
              "shortDescription": {
                "text": "\"Equals\" and the comparison operators should be overridden when implementing \"IComparable\""
              },
              "fullDescription": {
                "text": "When you implement IComparable or IComparable<T> on a class you should also override Equals(object) and overload the comparison operators (==, !=, <, <=, >, >=). That’s because the CLR cannot automatically call your CompareTo implementation from Equals(object) or from the base comparison operator implementations. Additionally, it is best practice to override GetHashCode along with Equals."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1210",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1215",
              "shortDescription": {
                "text": "\"GC.Collect\" should not be called"
              },
              "fullDescription": {
                "text": "Calling GC.Collect is rarely necessary, and can significantly affect application performance. That’s because it triggers a blocking operation that examines every object in memory for cleanup. Further, you don’t have control over when this blocking cleanup will actually run."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1215",
              "properties": {
                "category": "Critical Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S122",
              "shortDescription": {
                "text": "Statements should be on separate lines"
              },
              "fullDescription": {
                "text": "For better readability, do not put more than one statement on a single line."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-122",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S1226",
              "shortDescription": {
                "text": "Method parameters, caught exceptions and foreach variables' initial values should not be ignored"
              },
              "fullDescription": {
                "text": "While it is technically correct to assign to parameters from within method bodies, doing so before the parameter value is read is likely a bug. Instead, initial values of parameters, caught exceptions, and foreach parameters should be, if not treated as final, then at least read before reassignment."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1226",
              "properties": {
                "category": "Minor Bug",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S1227",
              "shortDescription": {
                "text": "break statements should not be used except for switch cases"
              },
              "fullDescription": {
                "text": "break; is an unstructured control flow statement which makes code harder to read."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1227",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S1244",
              "shortDescription": {
                "text": "Floating point numbers should not be tested for equality"
              },
              "fullDescription": {
                "text": "Floating point math is imprecise because of the challenges of storing such values in a binary representation. Even worse, floating point math is not associative; push a float or a double through a series of simple mathematical operations and the answer will be different based on the order of those operation because of the rounding that takes place at each step."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1244",
              "properties": {
                "category": "Major Bug",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S125",
              "shortDescription": {
                "text": "Sections of code should not be commented out"
              },
              "fullDescription": {
                "text": "Programmers should not comment out code as it bloats programs and reduces readability."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-125",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S126",
              "shortDescription": {
                "text": "\"if ... else if\" constructs should end with \"else\" clauses"
              },
              "fullDescription": {
                "text": "This rule applies whenever an if statement is followed by one or more else if statements; the final else if should be followed by an else statement."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-126",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S1264",
              "shortDescription": {
                "text": "A \"while\" loop should be used instead of a \"for\" loop"
              },
              "fullDescription": {
                "text": "When only the condition expression is defined in a for loop, and the initialization and increment expressions are missing, a while loop should be used instead to increase readability."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1264",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S127",
              "shortDescription": {
                "text": "\"for\" loop stop conditions should be invariant"
              },
              "fullDescription": {
                "text": "A for loop stop condition should test the loop counter against an invariant value (i.e. one that is true at both the beginning and ending of every loop iteration). Ideally, this means that the stop condition is set to a local variable just before the loop begins."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-127",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S1301",
              "shortDescription": {
                "text": "\"switch\" statements should have at least 3 \"case\" clauses"
              },
              "fullDescription": {
                "text": "switch statements and expressions are useful when there are many different cases depending on the value of the same expression."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1301",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S1309",
              "shortDescription": {
                "text": "Track uses of in-source issue suppressions"
              },
              "fullDescription": {
                "text": "This rule allows you to track the usage of the SuppressMessage attributes and #pragma warning disable mechanism."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1309",
              "properties": {
                "category": "Info Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S131",
              "shortDescription": {
                "text": "\"switch/Select\" statements should contain a \"default/Case Else\" clauses"
              },
              "fullDescription": {
                "text": "The requirement for a final default clause is defensive programming. The clause should either take appropriate action, or contain a suitable comment as to why no action is taken. Even when the switch covers all current values of an enum, a default case should still be used because there is no guarantee that the enum won’t be extended."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-131",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S1313",
              "shortDescription": {
                "text": "Using hardcoded IP addresses is security-sensitive"
              },
              "fullDescription": {
                "text": "Hardcoding IP addresses is security-sensitive. It has led in the past to the following vulnerabilities:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1313",
              "properties": {
                "category": "Major Security Hotspot",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S134",
              "shortDescription": {
                "text": "Control flow statements \"if\", \"switch\", \"for\", \"foreach\", \"while\", \"do\"  and \"try\" should not be nested too deeply"
              },
              "fullDescription": {
                "text": "Nested if, switch, for, foreach, while, do, and try statements are key ingredients for making what’s known as \"Spaghetti code\"."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-134",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S138",
              "shortDescription": {
                "text": "Functions should not have too many lines of code"
              },
              "fullDescription": {
                "text": "A function that grows too large tends to aggregate too many responsibilities."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-138",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S1449",
              "shortDescription": {
                "text": "Culture should be specified for \"string\" operations"
              },
              "fullDescription": {
                "text": "string.ToLower(), ToUpper, IndexOf, LastIndexOf, and Compare are all culture-dependent, as are some (floating point number and DateTime-related) calls to ToString. Fortunately, all have variants which accept an argument specifying the culture or formatter to use. Leave that argument off and the call will use the system default culture, possibly creating problems with international characters."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1449",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S1450",
              "shortDescription": {
                "text": "Private fields only used as local variables in methods should become local variables"
              },
              "fullDescription": {
                "text": "When the value of a private field is always assigned to in a class' methods before being read, then it is not being used to store class information. Therefore, it should become a local variable in the relevant methods to prevent any misunderstanding."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1450",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1451",
              "shortDescription": {
                "text": "Track lack of copyright and license headers"
              },
              "fullDescription": {
                "text": "Each source file should start with a header stating file ownership and the license which must be used to distribute the application."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1451",
              "properties": {
                "category": "Blocker Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S1479",
              "shortDescription": {
                "text": "\"switch\" statements should not have too many \"case\" clauses"
              },
              "fullDescription": {
                "text": "When switch statements have large sets of case clauses, it is usually an attempt to map two sets of data. A Dictionary should be used instead to make the code more readable and maintainable."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1479",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1481",
              "shortDescription": {
                "text": "Unused local variables should be removed"
              },
              "fullDescription": {
                "text": "If a local variable is declared but not used, it is dead code and should be removed. Doing so will improve maintainability because developers will not wonder what the variable is used for."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1481",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1541",
              "shortDescription": {
                "text": "Methods and properties should not be too complex"
              },
              "fullDescription": {
                "text": "The cyclomatic complexity of methods and properties should not exceed a defined threshold. Complex code can perform poorly and will in any case be difficult to understand and therefore to maintain."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1541",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S1607",
              "shortDescription": {
                "text": "Tests should not be ignored"
              },
              "fullDescription": {
                "text": "When a test fails due, for example, to infrastructure issues, you might want to ignore it temporarily. But without some kind of notation about why the test is being ignored, it may never be reactivated. Such tests are difficult to address without comprehensive knowledge of the project, and end up polluting their projects."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1607",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1643",
              "shortDescription": {
                "text": "Strings should not be concatenated using '+' in a loop"
              },
              "fullDescription": {
                "text": "StringBuilder is more efficient than string concatenation, especially when the operator is repeated over and over as in loops."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1643",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1656",
              "shortDescription": {
                "text": "Variables should not be self-assigned"
              },
              "fullDescription": {
                "text": "There is no reason to re-assign a variable to itself. Either this statement is redundant and should be removed, or the re-assignment is a mistake and some other value or variable was intended for the assignment instead."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1656",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1659",
              "shortDescription": {
                "text": "Multiple variables should not be declared on the same line"
              },
              "fullDescription": {
                "text": "Declaring multiple variable on one line is difficult to read."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1659",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S1694",
              "shortDescription": {
                "text": "An abstract class should have both abstract and concrete methods"
              },
              "fullDescription": {
                "text": "The purpose of an abstract class is to provide some heritable behaviors while also defining methods which must be implemented by sub-classes."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1694",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S1696",
              "shortDescription": {
                "text": "NullReferenceException should not be caught"
              },
              "fullDescription": {
                "text": "NullReferenceException should be avoided, not caught. Any situation in which NullReferenceException is explicitly caught can easily be converted to a null test, and any behavior being carried out in the catch block can easily be moved to the \"is null\" branch of the conditional."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1696",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S1698",
              "shortDescription": {
                "text": "\"==\" should not be used when \"Equals\" is overridden"
              },
              "fullDescription": {
                "text": "Using the equality == and inequality != operators to compare two objects generally works. The operators can be overloaded, and therefore the comparison can resolve to the appropriate method. However, when the operators are used on interface instances, then == resolves to reference equality, which may result in unexpected behavior if implementing classes override Equals. Similarly, when a class overrides Equals, but instances are compared with non-overloaded ==, there is a high chance that value comparison was meant instead of the reference one."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1698",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S1699",
              "shortDescription": {
                "text": "Constructors should only call non-overridable methods"
              },
              "fullDescription": {
                "text": "Calling an overridable method from a constructor could result in failures or strange behaviors when instantiating a subclass which overrides the method."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1699",
              "properties": {
                "category": "Critical Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1751",
              "shortDescription": {
                "text": "Loops with at most one iteration should be refactored"
              },
              "fullDescription": {
                "text": "A loop with at most one iteration is equivalent to the use of an if statement to conditionally execute one piece of code. If the initial intention of the author was really to conditionally execute one piece of code, an if statement should be used instead. If that was not the initial intention of the author, the body of the loop should be fixed to use the nested return, break or throw statements in a more appropriate way."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1751",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1764",
              "shortDescription": {
                "text": "Identical expressions should not be used on both sides of a binary operator"
              },
              "fullDescription": {
                "text": "Using the same value on either side of a binary operator is almost always a mistake. In the case of logical operators, it is either a copy/paste error and therefore a bug, or it is simply wasted code, and should be simplified. In the case of bitwise operators and most binary mathematical operators, having the same value on both sides of an operator yields predictable results, and should be simplified."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1764",
              "properties": {
                "category": "Major Bug",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1821",
              "shortDescription": {
                "text": "\"switch\" statements should not be nested"
              },
              "fullDescription": {
                "text": "Nested switch structures are difficult to understand because you can easily confuse the cases of an inner switch as belonging to an outer statement. Therefore nested switch statements should be avoided."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1821",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S1848",
              "shortDescription": {
                "text": "Objects should not be created to be dropped immediately without being used"
              },
              "fullDescription": {
                "text": "There is no good reason to create a new object to not do anything with it. Most of the time, this is due to a missing piece of code and so could lead to an unexpected behavior in production."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1848",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1854",
              "shortDescription": {
                "text": "Unused assignments should be removed"
              },
              "fullDescription": {
                "text": "A dead store happens when a local variable is assigned a value that is not read by any subsequent instruction. Calculating or retrieving a value only to then overwrite it or throw it away, could indicate a serious error in the code. Even if it’s not an error, it is at best a waste of resources. Therefore all calculated values should be used."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1854",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1858",
              "shortDescription": {
                "text": "\"ToString()\" calls should not be redundant"
              },
              "fullDescription": {
                "text": "Invoking a method designed to return a string representation of an object which is already a string is a waste of keystrokes. Similarly, explicitly invoking ToString() when the compiler would do it implicitly is also needless code-bloat."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1858",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S1862",
              "shortDescription": {
                "text": "Related \"if/else if\" statements should not have the same condition"
              },
              "fullDescription": {
                "text": "A chain of if/else if statements is evaluated from top to bottom. At most, only one branch will be executed: the first one with a condition that evaluates to true."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1862",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1871",
              "shortDescription": {
                "text": "Two branches in a conditional structure should not have exactly the same implementation"
              },
              "fullDescription": {
                "text": "Having two cases in the same switch statement or branches in the same if structure with the same implementation is at best duplicate code, and at worst a coding error. If the same logic is truly needed for both instances, then in an if structure they should be combined, or for a switch, one should fall through to the other."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1871",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1905",
              "shortDescription": {
                "text": "Redundant casts should not be used"
              },
              "fullDescription": {
                "text": "Unnecessary casting expressions make the code harder to read and understand."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1905",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1939",
              "shortDescription": {
                "text": "Inheritance list should not be redundant"
              },
              "fullDescription": {
                "text": "An inheritance list entry is redundant if:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1939",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1940",
              "shortDescription": {
                "text": "Boolean checks should not be inverted"
              },
              "fullDescription": {
                "text": "It is needlessly complex to invert the result of a boolean comparison. The opposite comparison should be made instead."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1940",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1944",
              "shortDescription": {
                "text": "Inappropriate casts should not be made"
              },
              "fullDescription": {
                "text": "Inappropriate casts are issues that will lead to unexpected behavior or runtime errors, such as InvalidCastExceptions. The compiler will catch bad casts from one class to another, but not bad casts to interfaces. Nor will it catch nullable values that are known to be null but that are cast to their underlying value types anyway."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1944",
              "properties": {
                "category": "Critical Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1994",
              "shortDescription": {
                "text": "\"for\" loop increment clauses should modify the loops' counters"
              },
              "fullDescription": {
                "text": "It can be extremely confusing when a for loop’s counter is incremented outside of its increment clause. In such cases, the increment should be moved to the loop’s increment clause if at all possible."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1994",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S2053",
              "shortDescription": {
                "text": "Hashes should include an unpredictable salt"
              },
              "fullDescription": {
                "text": "In cryptography, a \"salt\" is an extra piece of data which is included when hashing a password. This makes rainbow-table attacks more difficult. Using a cryptographic hash function without an unpredictable salt increases the likelihood that an attacker could successfully find the hash value in databases of precomputed hashes (called rainbow-tables)."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2053",
              "properties": {
                "category": "Critical Vulnerability",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2068",
              "shortDescription": {
                "text": "Hard-coded credentials are security-sensitive"
              },
              "fullDescription": {
                "text": "Because it is easy to extract strings from an application source code or binary, credentials should not be hard-coded. This is particularly true for applications that are distributed or that are open-source."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2068",
              "properties": {
                "category": "Blocker Security Hotspot",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2077",
              "shortDescription": {
                "text": "Formatting SQL queries is security-sensitive"
              },
              "fullDescription": {
                "text": "Formatted SQL queries can be difficult to maintain, debug and can increase the risk of SQL injection when concatenating untrusted values into the query. However, this rule doesn’t detect SQL injections (unlike rule {rule:csharpsquid:S3649}), the goal is only to highlight complex/formatted queries."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2077",
              "properties": {
                "category": "Major Security Hotspot",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2092",
              "shortDescription": {
                "text": "Creating cookies without the \"secure\" flag is security-sensitive"
              },
              "fullDescription": {
                "text": "When a cookie is protected with the secure attribute set to true it will not be send by the browser over an unencrypted HTTP request and thus cannot be observed by an unauthorized person during a man-in-the-middle attack."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2092",
              "properties": {
                "category": "Minor Security Hotspot",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2094",
              "shortDescription": {
                "text": "Classes should not be empty"
              },
              "fullDescription": {
                "text": "There is no good excuse for an empty class. If it’s being used simply as a common extension point, it should be replaced with an interface. If it was stubbed in as a placeholder for future development it should be fleshed-out. In any other case, it should be eliminated."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2094",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2114",
              "shortDescription": {
                "text": "Collections should not be passed as arguments to their own methods"
              },
              "fullDescription": {
                "text": "Passing a collection as an argument to the collection’s own method is either an error - some other argument was intended - or simply nonsensical code."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2114",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2115",
              "shortDescription": {
                "text": "A secure password should be used when connecting to a database"
              },
              "fullDescription": {
                "text": "When relying on the password authentication mode for the database connection, a secure password should be chosen."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2115",
              "properties": {
                "category": "Blocker Vulnerability",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2123",
              "shortDescription": {
                "text": "Values should not be uselessly incremented"
              },
              "fullDescription": {
                "text": "A value that is incremented or decremented and then not stored is at best wasted code and at worst a bug."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2123",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2148",
              "shortDescription": {
                "text": "Underscores should be used to make large numbers readable"
              },
              "fullDescription": {
                "text": "Beginning with C# 7, it is possible to add underscores ('_') to numeric literals to enhance readability. The addition of underscores in this manner has no semantic meaning, but makes it easier for maintainers to understand the code."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2148",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S2156",
              "shortDescription": {
                "text": "\"sealed\" classes should not have \"protected\" members"
              },
              "fullDescription": {
                "text": "The difference between private and protected visibility is that child classes can see and use protected members, but they cannot see private ones. Since a sealed class cannot have children, marking its members protected is confusingly pointless."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2156",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S2166",
              "shortDescription": {
                "text": "Classes named like \"Exception\" should extend \"Exception\" or a subclass"
              },
              "fullDescription": {
                "text": "Clear, communicative naming is important in code. It helps maintainers and API users understand the intentions for and uses of a unit of code. Using \"exception\" in the name of a class that does not extend Exception or one of its subclasses is a clear violation of the expectation that a class' name will indicate what it is and/or does."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2166",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2178",
              "shortDescription": {
                "text": "Short-circuit logic should be used in boolean contexts"
              },
              "fullDescription": {
                "text": "The use of non-short-circuit logic in a boolean context is likely a mistake - one that could cause serious program errors as conditions are evaluated under the wrong circumstances."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2178",
              "properties": {
                "category": "Blocker Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2183",
              "shortDescription": {
                "text": "Integral numbers should not be shifted by zero or more than their number of bits-1"
              },
              "fullDescription": {
                "text": "Shifting an integral number by 0 is equivalent to doing nothing but makes the code confusing for maintainers."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2183",
              "properties": {
                "category": "Minor Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2184",
              "shortDescription": {
                "text": "Results of integer division should not be assigned to floating point variables"
              },
              "fullDescription": {
                "text": "When division is performed on ints, the result will always be an int. You can assign that result to a double, float or decimal with automatic type conversion, but having started as an int, the result will likely not be what you expect. If the result of int division is assigned to a floating-point variable, precision will have been lost before the assignment. Instead, at least one operand should be cast or promoted to the final type before the operation takes place."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2184",
              "properties": {
                "category": "Minor Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2187",
              "shortDescription": {
                "text": "TestCases should contain tests"
              },
              "fullDescription": {
                "text": "There’s no point in having a test class without any test methods.This could lead a maintainer to assume a class is covered by tests even though it is not."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2187",
              "properties": {
                "category": "Blocker Code Smell",
                "tags": [
                  "C#",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2190",
              "shortDescription": {
                "text": "Recursion should not be infinite"
              },
              "fullDescription": {
                "text": "Recursion happens when control enters a loop that has no exit. This can happen a method invokes itself, when a pair of methods invoke each other, or when goto statements are used to move between two segments of code. It can be a useful tool, but unless the method includes a provision to break out of the recursion and return, the recursion will continue until the stack overflows and the program crashes."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2190",
              "properties": {
                "category": "Blocker Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2197",
              "shortDescription": {
                "text": "Modulus results should not be checked for direct equality"
              },
              "fullDescription": {
                "text": "When the modulus of a negative number is calculated, the result will either be negative or zero. Thus, comparing the modulus of a variable for equality with a positive number (or a negative one) could result in unexpected results."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2197",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S2198",
              "shortDescription": {
                "text": "Silly mathematical comparisons should not be made"
              },
              "fullDescription": {
                "text": "Certain mathematical comparisons will always return the same value, and should simply not be made."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2198",
              "properties": {
                "category": "Critical Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2201",
              "shortDescription": {
                "text": "Return values from functions without side effects should not be ignored"
              },
              "fullDescription": {
                "text": "When the call to a function doesn’t have any side effects, what is the point of making the call if the results are ignored? In such case, either the function call is useless and should be dropped or the source code doesn’t behave as expected."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2201",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2219",
              "shortDescription": {
                "text": "Runtime type checking should be simplified"
              },
              "fullDescription": {
                "text": "To check the type of an object there are several options:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2219",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2221",
              "shortDescription": {
                "text": "\"Exception\" should not be caught"
              },
              "fullDescription": {
                "text": "Catching System.Exception seems like an efficient way to handle multiple possible exceptions. Unfortunately, it traps all exception types, including the ones that were not intended to be caught. To prevent any misunderstandings, the exception filters should be used. Alternatively each exception type should be in a separate catch block."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2221",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S2222",
              "shortDescription": {
                "text": "Locks should be released on all paths"
              },
              "fullDescription": {
                "text": "If a lock is held or acquired and then released within a method, it should be released along all execution paths."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2222",
              "properties": {
                "category": "Critical Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2223",
              "shortDescription": {
                "text": "Non-constant static fields should not be visible"
              },
              "fullDescription": {
                "text": "Non-private static fields that are neither const nor readonly can lead to errors and unpredictable behavior."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2223",
              "properties": {
                "category": "Critical Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2225",
              "shortDescription": {
                "text": "\"ToString()\" method should not return null"
              },
              "fullDescription": {
                "text": "Calling ToString() on an object should always return a string. Returning null instead contravenes the method’s implicit contract."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2225",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2228",
              "shortDescription": {
                "text": "Console logging should not be used"
              },
              "fullDescription": {
                "text": "Debug statements are always useful during development. But include them in production code - particularly in code that runs client-side - and you run the risk of inadvertently exposing sensitive information."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2228",
              "properties": {
                "category": "Minor Vulnerability",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S2234",
              "shortDescription": {
                "text": "Parameters should be passed in the correct order"
              },
              "fullDescription": {
                "text": "When the names of parameters in a method call match the names of the method arguments, it contributes to clearer, more readable code. However, when the names match, but are passed in a different order than the method arguments, it indicates a mistake in the parameter order which will likely lead to unexpected results."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2234",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2245",
              "shortDescription": {
                "text": "Using pseudorandom number generators (PRNGs) is security-sensitive"
              },
              "fullDescription": {
                "text": "Using pseudorandom number generators (PRNGs) is security-sensitive. For example, it has led in the past to the following vulnerabilities:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2245",
              "properties": {
                "category": "Critical Security Hotspot",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2251",
              "shortDescription": {
                "text": "A \"for\" loop update clause should move the counter in the right direction"
              },
              "fullDescription": {
                "text": "A for loop with a counter that moves in the wrong direction is not an infinite loop. Because of wraparound, the loop will eventually reach its stop condition, but in doing so, it will run many, many more times than anticipated, potentially causing unexpected behavior."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2251",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2252",
              "shortDescription": {
                "text": "For-loop conditions should be true at least once"
              },
              "fullDescription": {
                "text": "If a for loop’s condition is false before the first loop iteration, the loop will never be executed. Such loops are almost always bugs, particularly when the initial value and stop conditions are hard-coded."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2252",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2255",
              "shortDescription": {
                "text": "Writing cookies is security-sensitive"
              },
              "fullDescription": {
                "text": "Using cookies is security-sensitive. It has led in the past to the following vulnerabilities:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2255",
              "properties": {
                "category": "Minor Security Hotspot",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S2257",
              "shortDescription": {
                "text": "Using non-standard cryptographic algorithms is security-sensitive"
              },
              "fullDescription": {
                "text": "The use of a non-standard algorithm is dangerous because a determined attacker may be able to break the algorithm and compromise whatever data has been protected. Standard algorithms like AES, RSA, SHA, …​ should be used instead."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2257",
              "properties": {
                "category": "Critical Security Hotspot",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2259",
              "shortDescription": {
                "text": "Null pointers should not be dereferenced"
              },
              "fullDescription": {
                "text": "A reference to null should never be dereferenced/accessed. Doing so will cause a NullReferenceException to be thrown. At best, such an exception will cause abrupt program termination. At worst, it could expose debugging information that would be useful to an attacker, or it could allow an attacker to bypass security measures."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2259",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2275",
              "shortDescription": {
                "text": "Composite format strings should not lead to unexpected behavior at runtime"
              },
              "fullDescription": {
                "text": "Because composite format strings are interpreted at runtime, rather than validated by the compiler, they can contain errors that lead to unexpected behaviors or runtime errors. This rule statically validates the good behavior of composite formats when calling the methods of String.Format, StringBuilder.AppendFormat, Console.Write, Console.WriteLine, TextWriter.Write, TextWriter.WriteLine, Debug.WriteLine(String, Object[]), Trace.TraceError(String, Object[]), Trace.TraceInformation(String, Object[]), Trace.TraceWarning(String, Object[]) and TraceSource.TraceInformation(String, Object[])."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2275",
              "properties": {
                "category": "Blocker Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2290",
              "shortDescription": {
                "text": "Field-like events should not be virtual"
              },
              "fullDescription": {
                "text": "Field-like events are events that do not have explicit add and remove methods. The compiler generates a private delegate field to back the event, as well as generating the implicit add and remove methods."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2290",
              "properties": {
                "category": "Critical Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2291",
              "shortDescription": {
                "text": "Overflow checking should not be disabled for \"Enumerable.Sum\""
              },
              "fullDescription": {
                "text": "Enumerable.Sum() always executes addition in a checked context, so an OverflowException will be thrown if the value exceeds MaxValue even if an unchecked context was specified. Using an unchecked context anyway represents a misunderstanding of how Sum works."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2291",
              "properties": {
                "category": "Critical Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2292",
              "shortDescription": {
                "text": "Trivial properties should be auto-implemented"
              },
              "fullDescription": {
                "text": "Trivial properties, which include no logic but setting and getting a backing field should be converted to auto-implemented properties, yielding cleaner and more readable code."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2292",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2302",
              "shortDescription": {
                "text": "\"nameof\" should be used"
              },
              "fullDescription": {
                "text": "Because parameter names could be changed during refactoring, they should not be spelled out literally in strings. Instead, use nameof(), and the string that’s output will always be correct."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2302",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S2306",
              "shortDescription": {
                "text": "\"async\" and \"await\" should not be used as identifiers"
              },
              "fullDescription": {
                "text": "Since C# 5.0, async and await are contextual keywords. Contextual keywords do have a particular meaning in some contexts, but can still be used as variable names. Keywords, on the other hand, are always reserved, and therefore are not valid variable names. To avoid any confusion though, it is best to not use async and await as identifiers."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2306",
              "properties": {
                "category": "Blocker Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2325",
              "shortDescription": {
                "text": "Methods and properties that don't access instance data should be static"
              },
              "fullDescription": {
                "text": "Methods and properties that don’t access instance data can be static to prevent any misunderstanding about the contract of the method."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2325",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S2326",
              "shortDescription": {
                "text": "Unused type parameters should be removed"
              },
              "fullDescription": {
                "text": "Type parameters that aren’t used are dead code, which can only distract and possibly confuse developers during maintenance. Therefore, unused type parameters should be removed."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2326",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2327",
              "shortDescription": {
                "text": "\"try\" statements with identical \"catch\" and/or \"finally\" blocks should be merged"
              },
              "fullDescription": {
                "text": "When multiple, adjacent try statements have duplicate catch and/or finally blocks, they should be merged to consolidate the catch/finally logic for cleaner, more readable code. Note that this applies even when there is intervening code outside any try block."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2327",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S2328",
              "shortDescription": {
                "text": "\"GetHashCode\" should not reference mutable fields"
              },
              "fullDescription": {
                "text": "GetHashCode is used to file an object in a Dictionary or Hashtable. If GetHashCode uses non-readonly fields and those fields change after the object is stored, the object immediately becomes mis-filed in the Hashtable. Any subsequent test to see if the object is in the Hashtable will return a false negative."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2328",
              "properties": {
                "category": "Minor Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2330",
              "shortDescription": {
                "text": "Array covariance should not be used"
              },
              "fullDescription": {
                "text": "Array covariance is the principle that if an implicit or explicit reference conversion exits from type A to B, then the same conversion exists from the array type A[] to B[]."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2330",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S2333",
              "shortDescription": {
                "text": "Redundant modifiers should not be used"
              },
              "fullDescription": {
                "text": "Unnecessary keywords simply clutter the code and should be removed. Specifically:"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2333",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S2339",
              "shortDescription": {
                "text": "Public constant members should not be used"
              },
              "fullDescription": {
                "text": "Constant members are copied at compile time to the call sites, instead of being fetched at runtime."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2339",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S2342",
              "shortDescription": {
                "text": "Enumeration types should comply with a naming convention"
              },
              "fullDescription": {
                "text": "Shared naming conventions allow teams to collaborate efficiently. This rule checks that all enum names match a provided regular expression."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2342",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2344",
              "shortDescription": {
                "text": "Enumeration type names should not have \"Flags\" or \"Enum\" suffixes"
              },
              "fullDescription": {
                "text": "The information that an enumeration type is actually an enumeration or a set of flags should not be duplicated in its name."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2344",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2345",
              "shortDescription": {
                "text": "Flags enumerations should explicitly initialize all their members"
              },
              "fullDescription": {
                "text": "Flags enumerations should not rely on the language to initialize the values of their members. Implicit initialization will set the first member to 0, and increment the value by one for each subsequent member. This implicit behavior does not allow members to be combined using the bitwise or operator in a useful way."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2345",
              "properties": {
                "category": "Minor Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2346",
              "shortDescription": {
                "text": "Flags enumerations zero-value members should be named \"None\""
              },
              "fullDescription": {
                "text": "Consistent use of \"None\" in flags enumerations indicates that all flag values are cleared. The value 0 should not be used to indicate any other state, since there is no way to check that the bit 0 is set."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2346",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2357",
              "shortDescription": {
                "text": "Fields should be private"
              },
              "fullDescription": {
                "text": "Fields should not be part of an API, and therefore should always be private. Indeed, they cannot be added to an interface for instance, and validation cannot be added later on without breaking backward compatibility. Instead, developers should encapsulate their fields into properties. Explicit property getters and setters can be introduced for validation purposes or to smooth the transition to a newer system."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2357",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S2360",
              "shortDescription": {
                "text": "Optional parameters should not be used"
              },
              "fullDescription": {
                "text": "The overloading mechanism should be used in place of optional parameters for several reasons:"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2360",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S2365",
              "shortDescription": {
                "text": "Properties should not make collection or array copies"
              },
              "fullDescription": {
                "text": "Most developers expect property access to be as efficient as field access. However, if a property returns a copy of an array or collection, it will be much slower than simple field access, contrary to the caller’s likely expectations. Therefore, such properties should be refactored into methods so that callers are not surprised by the unexpectedly poor performance."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2365",
              "properties": {
                "category": "Critical Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2368",
              "shortDescription": {
                "text": "Public methods should not have multidimensional array parameters"
              },
              "fullDescription": {
                "text": "Exposing methods with multidimensional array parameters requires developers to have advanced knowledge about the language in order to be able to use them. Moreover, what exactly to pass to such parameters is not intuitive. Therefore, such methods should not be exposed, but can be used internally."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2368",
              "properties": {
                "category": "Blocker Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2372",
              "shortDescription": {
                "text": "Exceptions should not be thrown from property getters"
              },
              "fullDescription": {
                "text": "Property getters should be simple operations that are always safe to call. If exceptions need to be thrown, it is best to convert the property to a method."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2372",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2376",
              "shortDescription": {
                "text": "Write-only properties should not be used"
              },
              "fullDescription": {
                "text": "Properties with only setters are confusing and counterintuitive. Instead, a property getter should be added if possible, or the property should be replaced with a setter method."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2376",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2386",
              "shortDescription": {
                "text": "Mutable fields should not be \"public static\""
              },
              "fullDescription": {
                "text": "public static mutable fields of classes which are accessed directly should be protected to the degree possible. This can be done by reducing the accessibility of the field or by changing the return type to an immutable type."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2386",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2387",
              "shortDescription": {
                "text": "Child class fields should not shadow parent class fields"
              },
              "fullDescription": {
                "text": "Having a variable with the same name in two unrelated classes is fine, but do the same thing within a class hierarchy and you’ll get confusion at best, chaos at worst."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2387",
              "properties": {
                "category": "Blocker Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S2436",
              "shortDescription": {
                "text": "Types and methods should not have too many generic parameters"
              },
              "fullDescription": {
                "text": "A method or class with too many type parameters has likely aggregated too many responsibilities and should be split."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2436",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2437",
              "shortDescription": {
                "text": "Silly bit operations should not be performed"
              },
              "fullDescription": {
                "text": "Certain bit operations are just silly and should not be performed because their results are predictable."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2437",
              "properties": {
                "category": "Blocker Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay",
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "S2445",
              "shortDescription": {
                "text": "Blocks should be synchronized on read-only fields"
              },
              "fullDescription": {
                "text": "Locking on a class field synchronizes not on the field itself, but on the object assigned to it. Thus, there are some good practices to follow to avoid bugs related to thread synchronization."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2445",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2479",
              "shortDescription": {
                "text": "Whitespace and control characters in string literals should be explicit"
              },
              "fullDescription": {
                "text": "Non-encoded control characters and whitespace characters are often injected in the source code because of a bad manipulation. They are either invisible or difficult to recognize, which can result in bugs when the string is not what the developer expects. If you actually need to use a control character use their encoded version (ex: ASCII \\n,\\t,…​ or Unicode U+000D, U+0009,…​)."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2479",
              "properties": {
                "category": "Critical Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2486",
              "shortDescription": {
                "text": "Generic exceptions should not be ignored"
              },
              "fullDescription": {
                "text": "When exceptions occur, it is usually a bad idea to simply ignore them. Instead, it is better to handle them properly, or at least to log them."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2486",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2551",
              "shortDescription": {
                "text": "Shared resources should not be used for locking"
              },
              "fullDescription": {
                "text": "Shared resources should not be used for locking as it increases the chance of deadlocks. Any other thread could acquire (or attempt to acquire) the same lock for another unrelated purpose."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2551",
              "properties": {
                "category": "Critical Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2583",
              "shortDescription": {
                "text": "Conditionally executed code should be reachable"
              },
              "fullDescription": {
                "text": "Conditional expressions which are always true or false can lead to dead code. Such code is always buggy and should never be used in production."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2583",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2589",
              "shortDescription": {
                "text": "Boolean expressions should not be gratuitous"
              },
              "fullDescription": {
                "text": "If a boolean expression doesn’t change the evaluation of the condition, then it is entirely unnecessary, and can be removed. If it is gratuitous because it does not match the programmer’s intent, then it’s a bug and the expression should be fixed."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2589",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2612",
              "shortDescription": {
                "text": "Setting loose file permissions is security-sensitive"
              },
              "fullDescription": {
                "text": "In Unix, \"others\" class refers to all users except the owner of the file and the members of the group assigned to this file."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2612",
              "properties": {
                "category": "Major Security Hotspot",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2674",
              "shortDescription": {
                "text": "The length returned from a stream read should be checked"
              },
              "fullDescription": {
                "text": "You cannot assume that any given stream reading call will fill the byte[] passed in to the method with the number of bytes requested. Instead, you must check the value returned by the read method to see how many bytes were read. Fail to do so, and you introduce a bug that is both harmful and difficult to reproduce."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2674",
              "properties": {
                "category": "Minor Bug",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S2681",
              "shortDescription": {
                "text": "Multiline blocks should be enclosed in curly braces"
              },
              "fullDescription": {
                "text": "Curly braces can be omitted from a one-line block, such as with an if statement or for loop, but doing so can be misleading and induce bugs."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2681",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2688",
              "shortDescription": {
                "text": "\"NaN\" should not be used in comparisons"
              },
              "fullDescription": {
                "text": "NaN is not equal to anything, even itself. Testing for equality or inequality against NaN will yield predictable results, but probably not the ones you want."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2688",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2692",
              "shortDescription": {
                "text": "\"IndexOf\" checks should not be for positive numbers"
              },
              "fullDescription": {
                "text": "Most checks against an IndexOf value compare it with -1 because 0 is a valid index. Any checks which look for values > 0 ignore the first element, which is likely a bug. If the intent is merely to check inclusion of a value in a string, List, or an array, consider using the Contains method instead."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2692",
              "properties": {
                "category": "Critical Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2696",
              "shortDescription": {
                "text": "Instance members should not write to \"static\" fields"
              },
              "fullDescription": {
                "text": "Correctly updating a static field from a non-static method is tricky to get right and could easily lead to bugs if there are multiple class instances and/or multiple threads in play."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2696",
              "properties": {
                "category": "Critical Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2699",
              "shortDescription": {
                "text": "Tests should include assertions"
              },
              "fullDescription": {
                "text": "A test case without assertions ensures only that no exceptions are thrown. Beyond basic runnability, it ensures nothing about the behavior of the code under test."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2699",
              "properties": {
                "category": "Blocker Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2701",
              "shortDescription": {
                "text": "Literal boolean values should not be used in assertions"
              },
              "fullDescription": {
                "text": "There’s no reason to use literal boolean values in assertions. Doing so is at best confusing for maintainers, and at worst a bug."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2701",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S2737",
              "shortDescription": {
                "text": "\"catch\" clauses should do more than rethrow"
              },
              "fullDescription": {
                "text": "A catch clause that only rethrows the caught exception has the same effect as omitting the catch altogether and letting it bubble up automatically, but with more code and the additional detriment of leaving maintainers scratching their heads."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2737",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2743",
              "shortDescription": {
                "text": "Static fields should not be used in generic types"
              },
              "fullDescription": {
                "text": "A static field in a generic type is not shared among instances of different closed constructed types, thus LengthLimitedSingletonCollection<int>.instances and LengthLimitedSingletonCollection<string>.instances will point to different objects, even though instances is seemingly shared among all LengthLimitedSingletonCollection<> generic classes."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2743",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2755",
              "shortDescription": {
                "text": "XML parsers should not be vulnerable to XXE attacks"
              },
              "fullDescription": {
                "text": "XML standard allows the use of entities, declared in the DOCTYPE of the document, which can be internal or external."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2755",
              "properties": {
                "category": "Blocker Vulnerability",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2757",
              "shortDescription": {
                "text": "\"=+\" should not be used instead of \"+=\""
              },
              "fullDescription": {
                "text": "The use of operators pairs ( =+, =- or =! ) where the reversed, single operator was meant (+=, -= or !=) will compile and run, but not produce the expected results."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2757",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2760",
              "shortDescription": {
                "text": "Sequential tests should not check the same condition"
              },
              "fullDescription": {
                "text": "When the same condition is checked twice in a row, it is either confusing - why have separate checks? - or an error - some other condition should have been checked in the second test."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2760",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S2761",
              "shortDescription": {
                "text": "Doubled prefix operators \"!!\" and \"~~\" should not be used"
              },
              "fullDescription": {
                "text": "Calling the ! or ~ prefix operator twice does nothing: the second invocation undoes the first. Such mistakes are typically caused by accidentally double-tapping the key in question without noticing."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2761",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2857",
              "shortDescription": {
                "text": "SQL keywords should be delimited by whitespace"
              },
              "fullDescription": {
                "text": "Badly formed SQL is likely to cause errors at runtime."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2857",
              "properties": {
                "category": "Blocker Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2930",
              "shortDescription": {
                "text": "\"IDisposables\" should be disposed"
              },
              "fullDescription": {
                "text": "When writing managed code, you don’t need to worry about allocating or freeing memory: The garbage collector takes care of it. For efficiency reasons, some objects such as Bitmap use unmanaged memory, enabling for example the use of pointer arithmetic. Such objects have potentially huge unmanaged memory footprints, but will have tiny managed ones. Unfortunately, the garbage collector only sees the tiny managed footprint, and fails to reclaim the unmanaged memory (by calling Bitmap's finalizer method) in a timely fashion."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2930",
              "properties": {
                "category": "Blocker Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2931",
              "shortDescription": {
                "text": "Classes with \"IDisposable\" members should implement \"IDisposable\""
              },
              "fullDescription": {
                "text": "An IDisposable object should be disposed (there are some rare exceptions where not disposing is fine, most notably Task). If a class has an IDisposable field, there can be two situations:"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2931",
              "properties": {
                "category": "Blocker Bug",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S2933",
              "shortDescription": {
                "text": "Fields that are only assigned in the constructor should be \"readonly\""
              },
              "fullDescription": {
                "text": "readonly fields can only be assigned in a class constructor. If a class has a field that’s not marked readonly but is only set in the constructor, it could cause confusion about the field’s intended use. To avoid confusion, such fields should be marked readonly to make their intended use explicit, and to prevent future maintainers from inadvertently changing their use."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2933",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2934",
              "shortDescription": {
                "text": "Property assignments should not be made for \"readonly\" fields not constrained to reference types"
              },
              "fullDescription": {
                "text": "While the properties of a readonly reference type field can still be changed after initialization, those of a readonly value field, such as a struct, cannot."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2934",
              "properties": {
                "category": "Minor Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2952",
              "shortDescription": {
                "text": "Classes should \"Dispose\" of members from the classes' own \"Dispose\" methods"
              },
              "fullDescription": {
                "text": "It is possible in an IDisposable to call Dispose on class members from any method, but the contract of Dispose is that it will clean up all unmanaged resources. Move disposing of members to some other method, and you risk resource leaks."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2952",
              "properties": {
                "category": "Critical Bug",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S2953",
              "shortDescription": {
                "text": "Methods named \"Dispose\" should implement \"IDisposable.Dispose\""
              },
              "fullDescription": {
                "text": "Dispose as a method name should be used exclusively to implement IDisposable.Dispose to prevent any confusion."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2953",
              "properties": {
                "category": "Blocker Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2955",
              "shortDescription": {
                "text": "Generic parameters not constrained to reference types should not be compared to \"null\""
              },
              "fullDescription": {
                "text": "When constraints have not been applied to restrict a generic type parameter to be a reference type, then a value type, such as a struct, could also be passed. In such cases, comparing the type parameter to null would always be false, because a struct can be empty, but never null. If a value type is truly what’s expected, then the comparison should use default(). If it’s not, then constraints should be added so that no value type can be passed."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2955",
              "properties": {
                "category": "Minor Bug",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S2970",
              "shortDescription": {
                "text": "Assertions should be complete"
              },
              "fullDescription": {
                "text": "It is very easy to write incomplete assertions when using some test frameworks. This rule enforces complete assertions in the following cases:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2970",
              "properties": {
                "category": "Blocker Code Smell",
                "tags": [
                  "C#",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2971",
              "shortDescription": {
                "text": "\"IEnumerable\" LINQs should be simplified"
              },
              "fullDescription": {
                "text": "In the interests of readability, code that can be simplified should be simplified. To that end, there are several ways IEnumerable language integrated queries (LINQ) can be simplified"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2971",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2995",
              "shortDescription": {
                "text": "\"Object.ReferenceEquals\" should not be used for value types"
              },
              "fullDescription": {
                "text": "Using Object.ReferenceEquals to compare the references of two value types simply won’t return the expected results most of the time because such types are passed by value, not by reference."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2995",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2996",
              "shortDescription": {
                "text": "\"ThreadStatic\" fields should not be initialized"
              },
              "fullDescription": {
                "text": "When an object has a field annotated with ThreadStatic, that field is shared within a given thread, but unique across threads. Since a class' static initializer is only invoked for the first thread created, it also means that only the first thread will have the expected initial values."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2996",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2997",
              "shortDescription": {
                "text": "\"IDisposables\" created in a \"using\" statement should not be returned"
              },
              "fullDescription": {
                "text": "Typically you want to use using to create a local IDisposable variable; it will trigger disposal of the object when control passes out of the block’s scope. The exception to this rule is when your method returns that IDisposable. In that case using disposes of the object before the caller can make use of it, likely causing exceptions at runtime. So you should either remove using or avoid returning the IDisposable."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2997",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3005",
              "shortDescription": {
                "text": "\"ThreadStatic\" should not be used on non-static fields"
              },
              "fullDescription": {
                "text": "When a non-static class field is annotated with ThreadStatic, the code seems to show that the field can have different values for different calling threads, but that’s not the case, since the ThreadStatic attribute is simply ignored on non-static fields."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3005",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3010",
              "shortDescription": {
                "text": "Static fields should not be updated in constructors"
              },
              "fullDescription": {
                "text": "Assigning a value to a static field in a constructor could cause unreliable behavior at runtime since it will change the value for all instances of the class."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3010",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3011",
              "shortDescription": {
                "text": "Reflection should not be used to increase accessibility of classes, methods, or fields"
              },
              "fullDescription": {
                "text": "This rule raises an issue when reflection is used to change the visibility of a class, method or field, and when it is used to directly update a field value. Altering or bypassing the accessibility of classes, methods, or fields violates the encapsulation principle and could lead to run-time errors."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3011",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3052",
              "shortDescription": {
                "text": "Members should not be initialized to default values"
              },
              "fullDescription": {
                "text": "The compiler automatically initializes class fields, auto-properties and events to their default values before setting them with any initialization values, so there is no need to explicitly set a member to its default value. Further, under the logic that cleaner code is better code, it’s considered poor style to do so."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3052",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3059",
              "shortDescription": {
                "text": "Types should not have members with visibility set higher than the type's visibility"
              },
              "fullDescription": {
                "text": "There’s no point in having a public member in a non-public type because objects that can’t access the type will never have the chance to access the member."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3059",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S3060",
              "shortDescription": {
                "text": "\"is\" should not be used with \"this\""
              },
              "fullDescription": {
                "text": "There’s no valid reason to test this with is. The only plausible explanation for such a test is that you’re executing code in a parent class conditionally based on the kind of child class this is. But code that’s specific to a child class should be in that child class, not in the parent."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3060",
              "properties": {
                "category": "Blocker Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3063",
              "shortDescription": {
                "text": "\"StringBuilder\" data should be used"
              },
              "fullDescription": {
                "text": "StringBuilder instances that never build a string clutter the code and worse are a drag on performance. Either they should be removed, or the missing ToString() call should be added."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3063",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3168",
              "shortDescription": {
                "text": "\"async\" methods should not return \"void\""
              },
              "fullDescription": {
                "text": "An async method with a void return type is a \"fire and forget\" method best reserved for event handlers because there’s no way to wait for the method’s execution to complete and respond accordingly. There’s also no way to catch exceptions thrown from the method."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3168",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3169",
              "shortDescription": {
                "text": "Multiple \"OrderBy\" calls should not be used"
              },
              "fullDescription": {
                "text": "There’s no point in chaining multiple OrderBy calls in a LINQ; only the last one will be reflected in the result because each subsequent call completely reorders the list. Thus, calling OrderBy multiple times is a performance issue as well, because all of the sorting will be executed, but only the result of the last sort will be kept."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3169",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3172",
              "shortDescription": {
                "text": "Delegates should not be subtracted"
              },
              "fullDescription": {
                "text": "In C#, delegates can be added together to chain their execution, and subtracted to remove their execution from the chain."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3172",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3215",
              "shortDescription": {
                "text": "\"interface\" instances should not be cast to concrete types"
              },
              "fullDescription": {
                "text": "Needing to cast from an interface to a concrete type indicates that something is wrong with the abstractions in use, likely that something is missing from the interface. Instead of casting to a discrete type, the missing functionality should be added to the interface. Otherwise there is a risk of runtime exceptions."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3215",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S3216",
              "shortDescription": {
                "text": "\"ConfigureAwait(false)\" should be used"
              },
              "fullDescription": {
                "text": "After an awaited Task has executed, you can continue execution in the original, calling thread or any arbitrary thread. Unless the rest of the code needs the context from which the Task was spawned, Task.ConfigureAwait(false) should be used to keep execution in the Task thread to avoid the need for context switching and the possibility of deadlocks."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3216",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S3217",
              "shortDescription": {
                "text": "\"Explicit\" conversions of \"foreach\" loops should not be used"
              },
              "fullDescription": {
                "text": "The foreach statement was introduced in the C# language prior to generics to make it easier to work with the non-generic collections available at that time such as ArrayList. The foreach statements allows you to downcast elements of a collection of Objects to any other type. The problem is that to achieve the cast, the foreach statements silently performs explicit type conversion, which at runtime can result in an InvalidCastException."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3217",
              "properties": {
                "category": "Critical Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3218",
              "shortDescription": {
                "text": "Inner class members should not shadow outer class \"static\" or type members"
              },
              "fullDescription": {
                "text": "It’s possible to name the members of an inner class the same as the static members of its enclosing class - possible, but a bad idea. That’s because maintainers may be confused about which members are being used where. Instead the inner class' members should be renamed and all the references updated."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3218",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3220",
              "shortDescription": {
                "text": "Method calls should not resolve ambiguously to overloads with \"params\""
              },
              "fullDescription": {
                "text": "The rules for method resolution are complex and perhaps not properly understood by all coders. The params keyword can make method declarations overlap in non-obvious ways, so that slight changes in the argument types of an invocation can resolve to different methods."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3220",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3234",
              "shortDescription": {
                "text": "\"GC.SuppressFinalize\" should not be invoked for types without destructors"
              },
              "fullDescription": {
                "text": "GC.SuppressFinalize asks the Common Language Runtime not to call the finalizer of an object. This is useful when implementing the dispose pattern where object finalization is already handled in IDisposable.Dispose. However, it has no effect if there is no finalizer defined in the object’s type, so using it in such cases is just confusing."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3234",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3235",
              "shortDescription": {
                "text": "Redundant parentheses should not be used"
              },
              "fullDescription": {
                "text": "Redundant parentheses are simply wasted keystrokes, and should be removed."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3235",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3236",
              "shortDescription": {
                "text": "Caller information arguments should not be provided explicitly"
              },
              "fullDescription": {
                "text": "Caller information attributes: CallerFilePathAttribute, CallerLineNumberAttribute, and CallerArgumentExpressionAttribute provide a way to get information about the caller of a method through optional parameters. But the arguments for these optional parameters are only generated if they are not explicitly defined in the call. Thus, specifying the argument values defeats the purpose of the attributes."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3236",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3237",
              "shortDescription": {
                "text": "\"value\" parameters should be used"
              },
              "fullDescription": {
                "text": "In property and indexer set methods, and in event add and remove methods, the implicit value parameter holds the value the accessor was called with. Not using the value means that the accessor ignores the caller’s intent which could cause unexpected results at runtime."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3237",
              "properties": {
                "category": "Blocker Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3240",
              "shortDescription": {
                "text": "The simplest possible condition syntax should be used"
              },
              "fullDescription": {
                "text": "In the interests of keeping code clean, the simplest possible conditional syntax should be used. That means"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3240",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3241",
              "shortDescription": {
                "text": "Methods should not return values that are never used"
              },
              "fullDescription": {
                "text": "Private methods are clearly intended for use only within their own scope. When such methods return values that are never used by any of their callers, then clearly there is no need to actually make the return, and it should be removed in the interests of efficiency and clarity."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3241",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3242",
              "shortDescription": {
                "text": "Method parameters should be declared with base types"
              },
              "fullDescription": {
                "text": "When a derived type is used as a parameter instead of the base type, it limits the uses of the method. If the additional functionality that is provided in the derived type is not required then that limitation isn’t required, and should be removed."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3242",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3244",
              "shortDescription": {
                "text": "Anonymous delegates should not be used to unsubscribe from Events"
              },
              "fullDescription": {
                "text": "It is possible to subscribe to events with anonymous delegates, but having done so, it is impossible to unsubscribe from them. That’s because the process of subscribing adds the delegate to a list. The process of unsubscribing essentially says: remove this item from the subscription list. But because an anonymous delegate was used in both cases, the unsubscribe attempt tries to remove a different item from the list than was added. The result: NOOP."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3244",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3246",
              "shortDescription": {
                "text": "Generic type parameters should be co/contravariant when possible"
              },
              "fullDescription": {
                "text": "In the interests of making code as usable as possible, interfaces and delegates with generic parameters should use the out and in modifiers when possible to make the interfaces and delegates covariant and contravariant, respectively."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3246",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3247",
              "shortDescription": {
                "text": "Duplicate casts should not be made"
              },
              "fullDescription": {
                "text": "Because the is operator performs a cast if the object is not null, using is to check type and then casting the same argument to that type, necessarily performs two casts. The same result can be achieved more efficiently with a single cast using as, followed by a null-check."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3247",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3249",
              "shortDescription": {
                "text": "Classes directly extending \"object\" should not call \"base\" in \"GetHashCode\" or \"Equals\""
              },
              "fullDescription": {
                "text": "Making a base call in an overriding method is generally a good idea, but not in GetHashCode and Equals for classes that directly extend object because those methods are based on the object reference. Meaning that no two objects that use those base methods will ever be equal or have the same hash."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3249",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3251",
              "shortDescription": {
                "text": "Implementations should be provided for \"partial\" methods"
              },
              "fullDescription": {
                "text": "partial methods allow an increased degree of flexibility in programming a system. Hooks can be added to generated code by invoking methods that define their signature, but might not have an implementation yet. But if the implementation is still missing when the code makes it to production, the compiler silently removes the call. In the best case scenario, such calls simply represent cruft, but in they worst case they are critical, missing functionality, the loss of which will lead to unexpected results at runtime."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3251",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3253",
              "shortDescription": {
                "text": "Constructor and destructor declarations should not be redundant"
              },
              "fullDescription": {
                "text": "Since the compiler will automatically invoke the base type’s no-argument constructor, there’s no need to specify its invocation explicitly. Also, when only a single public parameterless constructor is defined in a class, then that constructor can be removed because the compiler would generate it automatically. Similarly, empty static constructors and empty destructors are also wasted keystrokes."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3253",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3254",
              "shortDescription": {
                "text": "Default parameter values should not be passed as arguments"
              },
              "fullDescription": {
                "text": "Specifying the default parameter values in a method call is redundant. Such values should be omitted in the interests of readability."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3254",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S3256",
              "shortDescription": {
                "text": "\"string.IsNullOrEmpty\" should be used"
              },
              "fullDescription": {
                "text": "Using string.Equals to determine if a string is empty is significantly slower than using string.IsNullOrEmpty() or checking for string.Length == 0. string.IsNullOrEmpty() is both clear and concise, and therefore preferred to laborious, error-prone, manual null- and emptiness-checking."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3256",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3257",
              "shortDescription": {
                "text": "Declarations and initializations should be as concise as possible"
              },
              "fullDescription": {
                "text": "Unnecessarily verbose declarations and initializations make it harder to read the code, and should be simplified."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3257",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3260",
              "shortDescription": {
                "text": "Non-derived \"private\" classes and records should be \"sealed\""
              },
              "fullDescription": {
                "text": "private classes and records aren’t visible outside of their assemblies anyway, so if they’re not extended inside the assemblies, they should be made explicitly non-extensible with the addition of the sealed keyword."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3260",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3261",
              "shortDescription": {
                "text": "Namespaces should not be empty"
              },
              "fullDescription": {
                "text": "Namespaces with no lines of code clutter a project and should be removed."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3261",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3262",
              "shortDescription": {
                "text": "\"params\" should be used on overrides"
              },
              "fullDescription": {
                "text": "Overriding methods automatically inherit the params behavior. To ease readability, this modifier should be explicitly used in the overriding method as well."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3262",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3263",
              "shortDescription": {
                "text": "Static fields should appear in the order they must be initialized "
              },
              "fullDescription": {
                "text": "Static field initializers are executed in the order in which they appear in the class from top to bottom. Thus, placing a static field in a class above the field or fields required for its initialization will yield unexpected results."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3263",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3264",
              "shortDescription": {
                "text": "Events should be invoked"
              },
              "fullDescription": {
                "text": "Events that are not invoked anywhere are dead code, and there’s no good reason to keep them in the source."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3264",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3265",
              "shortDescription": {
                "text": "Non-flags enums should not be used in bitwise operations"
              },
              "fullDescription": {
                "text": "enums are usually used to identify distinct elements in a set of values. However enums can be treated as bit fields and bitwise operations can be used on them to combine the values. This is a good way of specifying multiple elements of set with a single value. When enums are used this way, it is a best practice to mark the enum with the FlagsAttribute."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3265",
              "properties": {
                "category": "Critical Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3267",
              "shortDescription": {
                "text": "Loops should be simplified with \"LINQ\" expressions"
              },
              "fullDescription": {
                "text": "When a loop is filtering, selecting or aggregating, those functions can be handled with a clearer, more concise LINQ expression instead."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3267",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3329",
              "shortDescription": {
                "text": "Cipher Block Chaining IVs should be unpredictable"
              },
              "fullDescription": {
                "text": "When encrypting data with the Cipher Block Chaining (CBC) mode an Initialization Vector (IV) is used to randomize the encryption, ie under a given key the same plaintext doesn’t always produce the same ciphertext. The IV doesn’t need to be secret but should be unpredictable to avoid \"Chosen-Plaintext Attack\"."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3329",
              "properties": {
                "category": "Critical Vulnerability",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3330",
              "shortDescription": {
                "text": "Creating cookies without the \"HttpOnly\" flag is security-sensitive"
              },
              "fullDescription": {
                "text": "When a cookie is configured with the HttpOnly attribute set to true, the browser guaranties that no client-side script will be able to read it. In most cases, when a cookie is created, the default value of HttpOnly is false and it’s up to the developer to decide whether or not the content of the cookie can be read by the client-side script. As a majority of Cross-Site Scripting (XSS) attacks target the theft of session-cookies, the HttpOnly attribute can help to reduce their impact as it won’t be possible to exploit the XSS vulnerability to steal session-cookies."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3330",
              "properties": {
                "category": "Minor Security Hotspot",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3343",
              "shortDescription": {
                "text": "Caller information parameters should come at the end of the parameter list"
              },
              "fullDescription": {
                "text": "Caller information attributes (CallerFilePathAttribute, CallerLineNumberAttribute, CallerMemberNameAttribute, and CallerArgumentExpressionAttribute) provide a way to get information about the caller of a method through optional parameters. But they only work right if their values aren’t provided explicitly. So if you define a method with caller info attributes in the middle of the parameter list, you put your callers in a bad position: they are forced to use named arguments if they want to use the method properly."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3343",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3346",
              "shortDescription": {
                "text": "Expressions used in \"Debug.Assert\" should not produce side effects"
              },
              "fullDescription": {
                "text": "An assertion is a piece of code that’s used during development when the compilation debug mode is activated. It allows a program to check itself as it runs. When an assertion is true, that means everything is operating as expected."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3346",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3353",
              "shortDescription": {
                "text": "Unchanged local variables should be \"const\""
              },
              "fullDescription": {
                "text": "Marking a variable that is unchanged after initialization const is an indication to future maintainers that \"no this isn’t updated, and it’s not supposed to be\". const should be used in these situations in the interests of code clarity."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3353",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S3358",
              "shortDescription": {
                "text": "Ternary operators should not be nested"
              },
              "fullDescription": {
                "text": "Just because you can do something, doesn’t mean you should, and that’s the case with nested ternary operations. Nesting ternary operators results in the kind of code that may seem clear as day when you write it, but six months later will leave maintainers (or worse - future you) scratching their heads and cursing."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3358",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3366",
              "shortDescription": {
                "text": "\"this\" should not be exposed from constructors"
              },
              "fullDescription": {
                "text": "In single-threaded environments, the use of this in constructors is normal, and expected. But in multi-threaded environments, it could expose partially-constructed objects to other threads, and should be used with caution."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3366",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S3376",
              "shortDescription": {
                "text": "Attribute, EventArgs, and Exception type names should end with the type being extended"
              },
              "fullDescription": {
                "text": "Adherence to the standard naming conventions makes your code not only more readable, but more usable. For instance, class FirstAttribute : Attribute can be used simply with First, but you must use the full name for class AttributeOne : Attribute."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3376",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3397",
              "shortDescription": {
                "text": "\"base.Equals\" should not be used to check for reference equality in \"Equals\" if \"base\" is not \"object\""
              },
              "fullDescription": {
                "text": "object.Equals() overrides can be optimized by checking first for reference equality between this and the parameter. This check can be implemented by calling object.ReferenceEquals() or base.Equals(), where base is object. However, using base.Equals() is a maintenance hazard because while it works if you extend Object directly, if you introduce a new base class that overrides Equals, it suddenly stops working."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3397",
              "properties": {
                "category": "Minor Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3398",
              "shortDescription": {
                "text": "\"private\" methods called only by inner classes should be moved to those classes"
              },
              "fullDescription": {
                "text": "When a private static method is only invoked by a nested class, there’s no reason not to move it into that class. It will still have the same access to the outer class' static members, but the outer class will be clearer and less cluttered."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3398",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3400",
              "shortDescription": {
                "text": "Methods should not return constants"
              },
              "fullDescription": {
                "text": "There’s no point in forcing the overhead of a method call for a method that always returns the same constant value. Even worse, the fact that a method call must be made will likely mislead developers who call the method thinking that something more is done. Declare a constant instead."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3400",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3415",
              "shortDescription": {
                "text": "Assertion arguments should be passed in the correct order"
              },
              "fullDescription": {
                "text": "The standard assertions library methods such as AreEqual and AreSame in MSTest and NUnit, or Equal and Same in XUnit, expect the first argument to be the expected value and the second argument to be the actual value. Swap them, and your test will still have the same outcome (succeed/fail when it should) but the error messages will be confusing."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3415",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3427",
              "shortDescription": {
                "text": "Method overloads with default parameter values should not overlap "
              },
              "fullDescription": {
                "text": "The rules for method resolution are complex and perhaps not properly understood by all coders. Having overloads with optional parameter values makes the matter even harder to understand."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3427",
              "properties": {
                "category": "Blocker Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3431",
              "shortDescription": {
                "text": "\"[ExpectedException]\" should not be used"
              },
              "fullDescription": {
                "text": "It should be clear to a casual reader what code a test is testing and what results are expected. Unfortunately, that’s not usually the case with the ExpectedException attribute since an exception could be thrown from almost any line in the method."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3431",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3433",
              "shortDescription": {
                "text": "Test method signatures should be correct"
              },
              "fullDescription": {
                "text": "A method is detected as test method if marked with one of the following attributes [TestMethod] or [DataTestMethod] (for mstest), [Fact] or [Theory] (for xunit) or [Test], [TestCase], [TestCaseSource] or [Theory] (for nunit). However, whether or not they have a test attribute, non-public methods are not recognized as tests, and therefore not executed. Neither are async void methods, or methods with generics anywhere in their signatures."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3433",
              "properties": {
                "category": "Blocker Code Smell",
                "tags": [
                  "C#",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3440",
              "shortDescription": {
                "text": "Variables should not be checked against the values they're about to be assigned"
              },
              "fullDescription": {
                "text": "There’s no point in checking a variable against the value you’re about to assign it. Save the cycles and lines of code, and simply perform the assignment."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3440",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3441",
              "shortDescription": {
                "text": "Redundant property names should be omitted in anonymous classes"
              },
              "fullDescription": {
                "text": "When an anonymous type’s properties are copied from properties or variables with the same names, it yields cleaner code to omit the new type’s property name and the assignment operator."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3441",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3442",
              "shortDescription": {
                "text": "\"abstract\" classes should not have \"public\" constructors"
              },
              "fullDescription": {
                "text": "Since abstract classes can’t be instantiated, there’s no point in their having public or internal constructors. If there is basic initialization logic that should run when an extending class instance is created, you can by all means put it in a constructor, but make that constructor private, private protected or protected."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3442",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3443",
              "shortDescription": {
                "text": "Type should not be examined on \"System.Type\" instances"
              },
              "fullDescription": {
                "text": "If you call GetType() on a Type variable, the return value will always be typeof(System.Type). So there’s no real point in making that call. The same applies to passing a type argument to IsInstanceOfType. In both cases the results are entirely predictable."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3443",
              "properties": {
                "category": "Blocker Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3444",
              "shortDescription": {
                "text": "Interfaces should not simply inherit from base interfaces with colliding members"
              },
              "fullDescription": {
                "text": "When an interface inherits from two interfaces that both define a member with the same name, trying to access that member through the derived interface will result in the compiler error CS0229 Ambiguity between 'IBase1.SomeProperty' and 'IBase2.SomeProperty'."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3444",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3445",
              "shortDescription": {
                "text": "Exceptions should not be explicitly rethrown"
              },
              "fullDescription": {
                "text": "When rethrowing an exception, you should do it by simply calling throw; and not throw exc;, because the stack trace is reset with the second syntax, making debugging a lot harder."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3445",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3447",
              "shortDescription": {
                "text": "\"[Optional]\" should not be used on \"ref\" or \"out\" parameters"
              },
              "fullDescription": {
                "text": "The use of ref or out in combination with [Optional] is both confusing and contradictory. [Optional] indicates that the parameter doesn’t have to be provided, while out and ref mean that the parameter will be used to return data to the caller (ref additionally indicates that the parameter may also be used to pass data into the method)."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3447",
              "properties": {
                "category": "Critical Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3449",
              "shortDescription": {
                "text": "Right operands of shift operators should be integers"
              },
              "fullDescription": {
                "text": "Numbers can be shifted with the << and >> operators, but the right operand of the operation needs to be an int or a type that has an implicit conversion to int. However, with dynamic, the compiler’s type checking is turned off, so you can pass anything to a shift operator and have it compile. And if the argument can’t be converted to int at runtime, then a RuntimeBinderException will be raised."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3449",
              "properties": {
                "category": "Critical Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3450",
              "shortDescription": {
                "text": "Parameters with \"[DefaultParameterValue]\" attributes should also be marked \"[Optional]\""
              },
              "fullDescription": {
                "text": "There is no point in providing a default value for a parameter if callers are required to provide a value for it anyway. Thus, [DefaultParameterValue] should always be used in conjunction with [Optional]."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3450",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3451",
              "shortDescription": {
                "text": "\"[DefaultValue]\" should not be used when \"[DefaultParameterValue]\" is meant"
              },
              "fullDescription": {
                "text": "The use of [DefaultValue] with [Optional] has no more effect than [Optional] alone. That’s because [DefaultValue] doesn’t actually do anything; it merely indicates the intent for the value. More than likely, [DefaultValue] was used in confusion instead of [DefaultParameterValue]."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3451",
              "properties": {
                "category": "Critical Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3453",
              "shortDescription": {
                "text": "Classes should not have only \"private\" constructors"
              },
              "fullDescription": {
                "text": "A class with only private constructors can’t be instantiated, thus, it seems to be pointless code."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3453",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3456",
              "shortDescription": {
                "text": "\"string.ToCharArray()\" and \"ReadOnlySpan<T>.ToArray()\" should not be called redundantly"
              },
              "fullDescription": {
                "text": "ToCharArray can be omitted when the operation on the array could have been done directly on the string, such as when iterating over the characters in a string, and when accessing a character in a string via an array index. In those cases, explicit ToCharArray calls should be omitted."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3456",
              "properties": {
                "category": "Minor Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3457",
              "shortDescription": {
                "text": "Composite format strings should be used correctly"
              },
              "fullDescription": {
                "text": "Because composite format strings are interpreted at runtime, rather than validated by the compiler, they can contain errors that lead to unexpected behaviors or runtime errors. This rule statically validates the good behavior of composite formats when calling the methods of String.Format, StringBuilder.AppendFormat, Console.Write, Console.WriteLine, TextWriter.Write, TextWriter.WriteLine, Debug.WriteLine(String, Object[]), Trace.TraceError(String, Object[]), Trace.TraceInformation(String, Object[]), Trace.TraceWarning(String, Object[]) and TraceSource.TraceInformation(String, Object[])."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3457",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3458",
              "shortDescription": {
                "text": "Empty \"case\" clauses that fall through to the \"default\" should be omitted"
              },
              "fullDescription": {
                "text": "Empty case clauses that fall through to the default are useless. Whether or not such a case is present, the default clause will be invoked. Such cases simply clutter the code, and should be removed."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3458",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3459",
              "shortDescription": {
                "text": "Unassigned members should be removed"
              },
              "fullDescription": {
                "text": "Fields and auto-properties that are never assigned to hold the default values for their types. They are either pointless code or, more likely, mistakes."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3459",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3464",
              "shortDescription": {
                "text": "Type inheritance should not be recursive"
              },
              "fullDescription": {
                "text": "Recursion is acceptable in methods, where you can break out of it. But with class types, you end up with code that will compile but not run if you try to instantiate the class."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3464",
              "properties": {
                "category": "Blocker Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3466",
              "shortDescription": {
                "text": "Optional parameters should be passed to \"base\" calls"
              },
              "fullDescription": {
                "text": "Generally, writing the least code that will readably do the job is a good thing, so omitting default parameter values seems to make sense. Unfortunately, when you omit them from the base call in an override, you’re not actually getting the job done thoroughly, because you’re ignoring the value the caller passed in. The result will likely not be what the caller expected."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3466",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3532",
              "shortDescription": {
                "text": "Empty \"default\" clauses should be removed"
              },
              "fullDescription": {
                "text": "The default clause should take appropriate action. Having an empty default is a waste of keystrokes."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3532",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3597",
              "shortDescription": {
                "text": "\"ServiceContract\" and \"OperationContract\" attributes should be used together"
              },
              "fullDescription": {
                "text": "The ServiceContract attribute specifies that a class or interface defines the communication contract of a Windows Communication Foundation (WCF) service. The service operations of this class or interface are defined by OperationContract attributes added to methods. It doesn’t make sense to define a contract without any service operations; thus, in a ServiceContract class or interface at least one method should be annotated with OperationContract. Similarly, WCF only serves OperationContract methods that are defined inside ServiceContract classes or interfaces; thus, this rule also checks that ServiceContract is added to the containing type of OperationContract methods."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3597",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3598",
              "shortDescription": {
                "text": "One-way \"OperationContract\" methods should have \"void\" return type"
              },
              "fullDescription": {
                "text": "When declaring a Windows Communication Foundation (WCF) OperationContract method one-way, that service method won’t return any result, not even an underlying empty confirmation message. These are fire-and-forget methods that are useful in event-like communication. Specifying a return type therefore does not make sense."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3598",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3600",
              "shortDescription": {
                "text": "\"params\" should not be introduced on overrides"
              },
              "fullDescription": {
                "text": "Adding params to a method override has no effect. The compiler accepts it, but the callers won’t be able to benefit from the added modifier."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3600",
              "properties": {
                "category": "Critical Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3603",
              "shortDescription": {
                "text": "Methods with \"Pure\" attribute should return a value "
              },
              "fullDescription": {
                "text": "Marking a method with the Pure attribute specifies that the method doesn’t make any visible changes; thus, the method should return a result, otherwise the call to the method should be equal to no-operation. So Pure on a void method is either a mistake, or the method doesn’t do any meaningful task."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3603",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3604",
              "shortDescription": {
                "text": "Member initializer values should not be redundant"
              },
              "fullDescription": {
                "text": "Fields, properties and events can be initialized either inline or in the constructor. Initializing them inline and in the constructor at the same time is redundant; the inline initialization will be overridden."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3604",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3610",
              "shortDescription": {
                "text": "Nullable type comparison should not be redundant"
              },
              "fullDescription": {
                "text": "Calling GetType() on a nullable object returns the underlying value type. Thus, comparing the returned Type object to typeof(Nullable<SomeType>) doesn’t make sense. The comparison either throws an exception or the result can be known at compile time."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3610",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3626",
              "shortDescription": {
                "text": "Jump statements should not be redundant"
              },
              "fullDescription": {
                "text": "Jump statements, such as return, yield break, goto, and continue let you change the default flow of program execution, but jump statements that direct the control flow to the original direction are just a waste of keystrokes."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3626",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3655",
              "shortDescription": {
                "text": "Empty nullable value should not be accessed"
              },
              "fullDescription": {
                "text": "Nullable value types can hold either a value or null. The value held in the nullable type can be accessed with the Value property or by casting it to the underlying type. Still, both operations throw an InvalidOperationException when the value is null. A nullable type should always be tested before the value is accessed to avoid the exception."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3655",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3717",
              "shortDescription": {
                "text": "Track use of \"NotImplementedException\""
              },
              "fullDescription": {
                "text": "NotImplementedException is often used to mark methods which must be implemented for the overall functionality to be complete, but which the developer wants to implement later. That’s as opposed to the NotSupportedException which is thrown by methods which are required by base classes or interfaces, but which are not appropriate to the current class."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3717",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3776",
              "shortDescription": {
                "text": "Cognitive Complexity of methods should not be too high"
              },
              "fullDescription": {
                "text": "Cognitive Complexity is a measure of how hard the control flow of a method is to understand. Methods with high Cognitive Complexity will be difficult to maintain."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3776",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3869",
              "shortDescription": {
                "text": "\"SafeHandle.DangerousGetHandle\" should not be called"
              },
              "fullDescription": {
                "text": "Not surprisingly, the SafeHandle.DangerousGetHandle method is dangerous. That’s because it may not return a valid handle. Using it can lead to leaks and vulnerabilities. While it is possible to use the method successfully, it’s extremely difficult to do correctly, so the method should simply be avoided altogether."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3869",
              "properties": {
                "category": "Blocker Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3871",
              "shortDescription": {
                "text": "Exception types should be \"public\""
              },
              "fullDescription": {
                "text": "The point of having custom exception types is to convey more information than is available in standard types. But custom exception types must be public for that to work."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3871",
              "properties": {
                "category": "Critical Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3872",
              "shortDescription": {
                "text": "Parameter names should not duplicate the names of their methods"
              },
              "fullDescription": {
                "text": "The name of a method should communicate what it does, and the names of its parameters should indicate how they’re used. If a method and its parameter have the same name it is an indication that one of these rules of thumb has been broken, if not both. Even if by some trick of language that’s not the case, it is still likely to confuse callers and maintainers."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3872",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3874",
              "shortDescription": {
                "text": "\"out\" and \"ref\" parameters should not be used"
              },
              "fullDescription": {
                "text": "Passing a parameter by reference, which is what happens when you use the out or ref parameter modifiers, means that the method will receive a pointer to the argument, rather than the argument itself. If the argument was a value type, the method will be able to change the argument’s values. If it was a reference type, then the method receives a pointer to a pointer, which is usually not what was intended. Even when it is what was intended, this is the sort of thing that’s difficult to get right, and should be used with caution."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3874",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3875",
              "shortDescription": {
                "text": "\"operator==\" should not be overloaded on reference types"
              },
              "fullDescription": {
                "text": "The use of == to compare two objects is expected to do a reference comparison. That is, it is expected to return true if and only if they are the same object instance. Overloading the operator to do anything else will inevitably lead to the introduction of bugs by callers. On the other hand, overloading it to do exactly that is pointless; that’s what == does by default."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3875",
              "properties": {
                "category": "Blocker Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3876",
              "shortDescription": {
                "text": "Strings or integral types should be used for indexers"
              },
              "fullDescription": {
                "text": "Strings and integral types are typically used as indexers. When some other type is required, it typically indicates design problems, and potentially a situation where a method should be used instead."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3876",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3877",
              "shortDescription": {
                "text": "Exceptions should not be thrown from unexpected methods"
              },
              "fullDescription": {
                "text": "It is expected that some methods should be called with caution, but others, such as ToString, are expected to \"just work\". Throwing an exception from such a method is likely to break callers' code unexpectedly."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3877",
              "properties": {
                "category": "Blocker Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3878",
              "shortDescription": {
                "text": "Arrays should not be created for params parameters"
              },
              "fullDescription": {
                "text": "There’s no point in creating an array solely for the purpose of passing it to a params parameter. Simply pass the elements directly. They will be consolidated into an array automatically."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3878",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3880",
              "shortDescription": {
                "text": "Finalizers should not be empty"
              },
              "fullDescription": {
                "text": "Finalizers come with a performance cost due to the overhead of tracking the life cycle of objects. An empty one is consequently costly with no benefit or justification."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3880",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3881",
              "shortDescription": {
                "text": "\"IDisposable\" should be implemented correctly"
              },
              "fullDescription": {
                "text": "The IDisposable interface is a mechanism to release unmanaged resources, if not implemented correctly this could result in resource leaks or more severe bugs."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3881",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3884",
              "shortDescription": {
                "text": "\"CoSetProxyBlanket\" and \"CoInitializeSecurity\" should not be used"
              },
              "fullDescription": {
                "text": "CoSetProxyBlanket and CoInitializeSecurity both work to set the permissions context in which the process invoked immediately after is executed. Calling them from within that process is useless because it’s too late at that point; the permissions context has already been set."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3884",
              "properties": {
                "category": "Blocker Vulnerability",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3885",
              "shortDescription": {
                "text": "\"Assembly.Load\" should be used"
              },
              "fullDescription": {
                "text": "The parameter to Assembly.Load includes the full specification of the dll to be loaded. Use another method, and you might end up with a dll other than the one you expected."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3885",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3887",
              "shortDescription": {
                "text": "Mutable, non-private fields should not be \"readonly\""
              },
              "fullDescription": {
                "text": "Using the readonly keyword on a field means that it can’t be changed after initialization. However, when applied to collections or arrays, that’s only partly true. readonly enforces that another instance can’t be assigned to the field, but it cannot keep the contents from being updated. That means that in practice, the field value really can be changed, and the use of readonly on such a field is misleading, and you’re likely to not be getting the behavior you expect."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3887",
              "properties": {
                "category": "Minor Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3889",
              "shortDescription": {
                "text": "Neither \"Thread.Resume\" nor \"Thread.Suspend\" should be used"
              },
              "fullDescription": {
                "text": "Thread.Suspend and Thread.Resume can give unpredictable results, and both methods have been deprecated. Indeed, if Thread.Suspend is not used very carefully, a thread can be suspended while holding a lock, thus leading to a deadlock. Other safer synchronization mechanisms should be used, such as Monitor, Mutex, and Semaphore."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3889",
              "properties": {
                "category": "Blocker Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3897",
              "shortDescription": {
                "text": "Classes that provide \"Equals(<T>)\" should implement \"IEquatable<T>\""
              },
              "fullDescription": {
                "text": "The IEquatable<T> interface has only one method in it: Equals(<T>). If you’ve already written Equals(T), there’s no reason not to explicitly implement IEquatable<T>. Doing so expands the utility of your class by allowing it to be used where an IEquatable is called for."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3897",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3898",
              "shortDescription": {
                "text": "Value types should implement \"IEquatable<T>\""
              },
              "fullDescription": {
                "text": "If you’re using a struct, it is likely because you’re interested in performance. But by failing to implement IEquatable<T> you’re loosing performance when comparisons are made because without IEquatable<T>, boxing and reflection are used to make comparisons."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3898",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3900",
              "shortDescription": {
                "text": "Arguments of public methods should be validated against null"
              },
              "fullDescription": {
                "text": "Methods declared as public, protected, or protected internal can be accessed from other assemblies, which means you should validate parameters to be within the expected constraints. In general, checking against null is recommended in defensive programming."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3900",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3902",
              "shortDescription": {
                "text": "\"Assembly.GetExecutingAssembly\" should not be called"
              },
              "fullDescription": {
                "text": "Using Type.Assembly to get the current assembly is nearly free in terms of performance; it’s a simple property access. On the other hand, Assembly.GetExecutingAssembly() can take up to 30 times as long because it walks up the call stack to find the assembly."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3902",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3903",
              "shortDescription": {
                "text": "Types should be defined in named namespaces"
              },
              "fullDescription": {
                "text": "Types are declared in namespaces in order to prevent name collisions and as a way to organize them into the object hierarchy. Types that are defined outside any named namespace are in a global namespace that cannot be referenced in code."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3903",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3904",
              "shortDescription": {
                "text": "Assemblies should have version information"
              },
              "fullDescription": {
                "text": "If no AssemblyVersionAttribute is provided, the same default version will be used for every build. Since the version number is used by The .NET Framework to uniquely identify an assembly this can lead to broken dependencies."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3904",
              "properties": {
                "category": "Critical Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3906",
              "shortDescription": {
                "text": "Event Handlers should have the correct signature"
              },
              "fullDescription": {
                "text": "Delegate event handlers (i.e. delegates used as type of an event) should have a very specific signature:"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3906",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3908",
              "shortDescription": {
                "text": "Generic event handlers should be used"
              },
              "fullDescription": {
                "text": "Since .Net Framework version 2.0 it is not necessary to declare a delegate that specifies a class derived from System.EventArgs. The System.EventHandler<TEventArgs> delegate mechanism should be used instead as it allows any class derived from EventArgs to be used with that handler."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3908",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3909",
              "shortDescription": {
                "text": "Collections should implement the generic interface"
              },
              "fullDescription": {
                "text": "The NET Framework 2.0 introduced the generic interface System.Collections.Generic.IEnumerable<T> and it should be preferred over the older, non generic, interfaces."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3909",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3923",
              "shortDescription": {
                "text": "All branches in a conditional structure should not have exactly the same implementation"
              },
              "fullDescription": {
                "text": "Having all branches in a switch or if chain with the same implementation is an error. Either a copy-paste error was made and something different should be executed, or there shouldn’t be a switch/if chain at all."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3923",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3925",
              "shortDescription": {
                "text": "\"ISerializable\" should be implemented correctly"
              },
              "fullDescription": {
                "text": "The ISerializable interface is the mechanism to control the type serialization process. If not implemented correctly this could result in an invalid serialization and hard to detect bugs."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3925",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3926",
              "shortDescription": {
                "text": "Deserialization methods should be provided for \"OptionalField\" members"
              },
              "fullDescription": {
                "text": "Fields marked with System.Runtime.Serialization.OptionalFieldAttribute are serialized just like any other field. But such fields are ignored on deserialization, and retain the default values associated with their types. Therefore, deserialization event handlers should be declared to set such fields during the deserialization process."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3926",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3927",
              "shortDescription": {
                "text": "Serialization event handlers should be implemented correctly"
              },
              "fullDescription": {
                "text": "Serialization event handlers that don’t have the correct signature will simply not be called, thus bypassing any attempts to augment the automated de/serialization."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3927",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3928",
              "shortDescription": {
                "text": "Parameter names used into ArgumentException constructors should match an existing one "
              },
              "fullDescription": {
                "text": "Some constructors of the ArgumentException, ArgumentNullException, ArgumentOutOfRangeException and DuplicateWaitObjectException classes must be fed with a valid parameter name. This rule raises an issue in two cases:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3928",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3937",
              "shortDescription": {
                "text": "Number patterns should be regular"
              },
              "fullDescription": {
                "text": "The use of punctuation characters to separate subgroups in a number can make the number more readable. For instance consider 1,000,000,000 versus 1000000000. But when the grouping is irregular, such as 1,000,00,000; it indicates an error."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3937",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3949",
              "shortDescription": {
                "text": "Calculations should not overflow"
              },
              "fullDescription": {
                "text": "Numbers are infinite, but the types that hold them are not. Each numeric type has hard upper and lower bounds. Try to calculate or assign numbers beyond those bounds, and the result will be a value that has silently wrapped around from the expected positive value to a negative one, or vice versa."
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3949",
              "properties": {
                "category": "Major Bug",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "S3956",
              "shortDescription": {
                "text": "\"Generic.List\" instances should not be part of public APIs"
              },
              "fullDescription": {
                "text": "System.Collections.Generic.List<T> is a generic collection that is designed for performance and not inheritance. For example, it does not contain virtual members that make it easier to change the behavior of an inherited class. That means that future attempts to expand the behavior will be spoiled because the extension points simply aren’t there. Instead, one of the following generic collections should be used:"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3956",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S3962",
              "shortDescription": {
                "text": "\"static readonly\" constants should be \"const\" instead"
              },
              "fullDescription": {
                "text": "The value of a static readonly field is computed at runtime while the value of a const field is calculated at compile time, which improves performance."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3962",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3963",
              "shortDescription": {
                "text": "\"static\" fields should be initialized inline"
              },
              "fullDescription": {
                "text": "When a static constructor serves no other purpose that initializing static fields, it comes with an unnecessary performance cost because the compiler generates a check before each static method or instance constructor invocation."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3963",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3966",
              "shortDescription": {
                "text": "Objects should not be disposed more than once"
              },
              "fullDescription": {
                "text": "Disposing an object twice, either with the using keyword or by calling Dispose directly, in the same method is at best confusing and at worst error-prone. The next developer might see only one of the Dispose/using and try to use an already-disposed object."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3966",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3967",
              "shortDescription": {
                "text": "Multidimensional arrays should not be used"
              },
              "fullDescription": {
                "text": "A jagged array is an array whose elements are arrays. It is recommended over a multidimensional array because the arrays that make up the elements can be of different sizes, which avoids wasting memory space."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3967",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3971",
              "shortDescription": {
                "text": "\"GC.SuppressFinalize\" should not be called"
              },
              "fullDescription": {
                "text": "GC.SuppressFinalize requests that the system not call the finalizer for the specified object. This should only be done when implementing Dispose as part of the Dispose Pattern."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3971",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3972",
              "shortDescription": {
                "text": "Conditionals should start on new lines"
              },
              "fullDescription": {
                "text": "Code is clearest when each statement has its own line. Nonetheless, it is a common pattern to combine on the same line an if and its resulting then statement. However, when an if is placed on the same line as the closing } from a preceding then, else or else if part, it is either an error - else is missing - or the invitation to a future error as maintainers fail to understand that the two statements are unconnected."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3972",
              "properties": {
                "category": "Critical Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3973",
              "shortDescription": {
                "text": "A conditionally executed single line should be denoted by indentation"
              },
              "fullDescription": {
                "text": "In the absence of enclosing curly braces, the line immediately after a conditional is the one that is conditionally executed. By both convention and good practice, such lines are indented. In the absence of both curly braces and indentation the intent of the original programmer is entirely unclear and perhaps not actually what is executed. Additionally, such code is highly likely to be confusing to maintainers."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3973",
              "properties": {
                "category": "Critical Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3981",
              "shortDescription": {
                "text": "Collection sizes and array length comparisons should make sense"
              },
              "fullDescription": {
                "text": "The size of a collection and the length of an array are always greater than or equal to zero. So testing that a size or length is greater than or equal to zero doesn’t make sense, since the result is always true. Similarly testing that it is less than zero will always return false. Perhaps the intent was to check the non-emptiness of the collection or array instead."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3981",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3984",
              "shortDescription": {
                "text": "Exceptions should not be created without being thrown"
              },
              "fullDescription": {
                "text": "Creating a new Exception without actually throwing it is useless and is probably due to a mistake."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3984",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3990",
              "shortDescription": {
                "text": "Assemblies should be marked as CLS compliant"
              },
              "fullDescription": {
                "text": "Assemblies should conform with the Common Language Specification (CLS) in order to be usable across programming languages. To be compliant an assembly has to indicate it with System.CLSCompliantAttribute."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3990",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3992",
              "shortDescription": {
                "text": "Assemblies should explicitly specify COM visibility"
              },
              "fullDescription": {
                "text": "Assemblies should explicitly indicate whether they are meant to be COM visible or not. If the ComVisibleAttribute is not present, the default is to make the content of the assembly visible to COM clients."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3992",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3993",
              "shortDescription": {
                "text": "Custom attributes should be marked with \"System.AttributeUsageAttribute\""
              },
              "fullDescription": {
                "text": "When defining custom attributes, System.AttributeUsageAttribute must be used to indicate where the attribute can be applied. This will determine its valid locations in the code."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3993",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3994",
              "shortDescription": {
                "text": "URI Parameters should not be strings"
              },
              "fullDescription": {
                "text": "String representations of URIs or URLs are prone to parsing and encoding errors which can lead to vulnerabilities. The System.Uri class is a safe alternative and should be preferred. At minimum, an overload of the method taking a System.Uri as a parameter should be provided in each class that contains a method with an apparent Uri passed as a string."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3994",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3995",
              "shortDescription": {
                "text": "URI return values should not be strings"
              },
              "fullDescription": {
                "text": "String representations of URIs or URLs are prone to parsing and encoding errors which can lead to vulnerabilities. The System.Uri class is a safe alternative and should be preferred."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3995",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3996",
              "shortDescription": {
                "text": "URI properties should not be strings"
              },
              "fullDescription": {
                "text": "String representations of URIs or URLs are prone to parsing and encoding errors which can lead to vulnerabilities. The System.Uri class is a safe alternative and should be preferred."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3996",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3997",
              "shortDescription": {
                "text": "String URI overloads should call \"System.Uri\" overloads"
              },
              "fullDescription": {
                "text": "String representations of URIs or URLs are prone to parsing and encoding errors which can lead to vulnerabilities. The System.Uri class is a safe alternative and should be preferred."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3997",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3998",
              "shortDescription": {
                "text": "Threads should not lock on objects with weak identity"
              },
              "fullDescription": {
                "text": "A thread acquiring a lock on an object that can be accessed across application domain boundaries runs the risk of being blocked by another thread in a different application domain. Objects that can be accessed across application domain boundaries are said to have weak identity. Types with weak identity are:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3998",
              "properties": {
                "category": "Critical Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4000",
              "shortDescription": {
                "text": "Pointers to unmanaged memory should not be visible"
              },
              "fullDescription": {
                "text": "Pointer and unmanaged function pointer types such as IntPtr, UIntPtr, int* etc. are used to access unmanaged memory, usually in order to use C or C++ libraries. If such a pointer is not secured by making it private, internal or readonly, it can lead to a vulnerability allowing access to arbitrary locations."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4000",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4002",
              "shortDescription": {
                "text": "Disposable types should declare finalizers"
              },
              "fullDescription": {
                "text": "This rule raises an issue when a disposable type contains fields of the following types and does not implement a finalizer:"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4002",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4004",
              "shortDescription": {
                "text": "Collection properties should be readonly"
              },
              "fullDescription": {
                "text": "A writable collection property can be replaced by a completely different collection. Making it readonly prevents that while still allowing individual members to be set. If you want to allow the replacement of the whole collection the recommended pattern is to implement a method to remove all the elements (e.g. System.Collections.List<T>.Clear) and a method to populate the collection (e.g. System.Collections.List<T>.AddRange)."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4004",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4005",
              "shortDescription": {
                "text": "\"System.Uri\" arguments should be used instead of strings"
              },
              "fullDescription": {
                "text": "String representations of URIs or URLs are prone to parsing and encoding errors which can lead to vulnerabilities. The System.Uri class is a safe alternative and should be preferred."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4005",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4015",
              "shortDescription": {
                "text": "Inherited member visibility should not be decreased"
              },
              "fullDescription": {
                "text": "Changing an inherited member to private will not prevent access to the base class implementation."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4015",
              "properties": {
                "category": "Critical Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4016",
              "shortDescription": {
                "text": "Enumeration members should not be named \"Reserved\""
              },
              "fullDescription": {
                "text": "If an enum member’s name contains the word \"reserved\" it implies it is not currently used and will be change in the future. However changing an enum member is a breaking change and can create significant problems. There is no need to reserve an enum member since a new member can be added in the future, and such an addition will usually not be a breaking change."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4016",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4017",
              "shortDescription": {
                "text": "Method signatures should not contain nested generic types"
              },
              "fullDescription": {
                "text": "A nested type is a type argument that is also a generic type. Calling a method with such a nested type argument requires complicated and confusing code. It should be avoided as much as possible."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4017",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4018",
              "shortDescription": {
                "text": "All type parameters should be used in the parameter list to enable type inference"
              },
              "fullDescription": {
                "text": "Type inference enables the call of a generic method without explicitly specifying its type arguments. This is not possible when a parameter type is missing from the argument list."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4018",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4019",
              "shortDescription": {
                "text": "Base class methods should not be hidden"
              },
              "fullDescription": {
                "text": "When a method in a derived class has the same name as a method in the base class but with a signature that only differs by types that are weakly derived (e.g. object vs string), the result is that the base method becomes hidden."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4019",
              "properties": {
                "category": "Critical Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4022",
              "shortDescription": {
                "text": "Enumerations should have \"Int32\" storage"
              },
              "fullDescription": {
                "text": "By default the storage type of an enum is Int32. In most cases it is not necessary to change this. In particular you will not achieve any performance gain by using a smaller data type (e.g. Byte) and may limit future uses."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4022",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4023",
              "shortDescription": {
                "text": "Interfaces should not be empty"
              },
              "fullDescription": {
                "text": "Empty interfaces are usually used as a marker or a way to identify groups of types. The preferred way to achieve this is to use custom attributes."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4023",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S4025",
              "shortDescription": {
                "text": "Child class fields should not differ from parent class fields only by capitalization"
              },
              "fullDescription": {
                "text": "Having a field in a child class with a name that differs from a parent class' field only by capitalization is sure to cause confusion. Such child class fields should be renamed."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4025",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4026",
              "shortDescription": {
                "text": "Assemblies should be marked with \"NeutralResourcesLanguageAttribute\""
              },
              "fullDescription": {
                "text": "It is important to inform the ResourceManager of the language used to display the resources of the neutral culture for an assembly. This improves lookup performance for the first resource loaded."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4026",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4027",
              "shortDescription": {
                "text": "Exceptions should provide standard constructors"
              },
              "fullDescription": {
                "text": "Exceptions types should provide the following constructors:"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4027",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4035",
              "shortDescription": {
                "text": "Classes implementing \"IEquatable<T>\" should be sealed"
              },
              "fullDescription": {
                "text": "When a class implements the IEquatable<T> interface, it enters a contract that, in effect, states \"I know how to compare two instances of type T or any type derived from T for equality.\". However if that class is derived, it is very unlikely that the base class will know how to make a meaningful comparison. Therefore that implicit contract is now broken."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4035",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4036",
              "shortDescription": {
                "text": "Searching OS commands in PATH is security-sensitive"
              },
              "fullDescription": {
                "text": "When executing an OS command and unless you specify the full path to the executable, then the locations in your application’s PATH environment variable will be searched for the executable. That search could leave an opening for an attacker if one of the elements in PATH is a directory under his control."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4036",
              "properties": {
                "category": "Minor Security Hotspot",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4039",
              "shortDescription": {
                "text": "Interface methods should be callable by derived types"
              },
              "fullDescription": {
                "text": "When a base type explicitly implements a public interface method, that method is only accessible in derived types through a reference to the current instance (namely this). If the derived type explicitly overrides that interface method, the base implementation becomes inaccessible."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4039",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S4040",
              "shortDescription": {
                "text": "Strings should be normalized to uppercase"
              },
              "fullDescription": {
                "text": "Certain characters, once normalized to lowercase, cannot make a round trip. That is, they can not be converted from one locale to another and then accurately restored to their original characters."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4040",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4041",
              "shortDescription": {
                "text": "Type names should not match namespaces"
              },
              "fullDescription": {
                "text": "When a type name matches the name of a publicly defined namespace, for instance one in the .NET framework class library, it leads to confusion and makes the library that much harder to use."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4041",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4047",
              "shortDescription": {
                "text": "Generics should be used when appropriate"
              },
              "fullDescription": {
                "text": "When a reference parameter (keyword ref) is used, the passed argument type must exactly match the reference parameter type. This means that to be able to pass a derived type, it must be cast and assigned to a variable of the proper type. Use of generic methods eliminates that cumbersome down casting and should therefore be preferred."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4047",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4049",
              "shortDescription": {
                "text": "Properties should be preferred"
              },
              "fullDescription": {
                "text": "Properties are accessed like fields which makes them easier to use."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4049",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S4050",
              "shortDescription": {
                "text": "Operators should be overloaded consistently"
              },
              "fullDescription": {
                "text": "When implementing operator overloads, it is very important to make sure that all related operators and methods are consistent in their implementation."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4050",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4052",
              "shortDescription": {
                "text": "Types should not extend outdated base types"
              },
              "fullDescription": {
                "text": "With the advent of .NET framework version 2, certain practices have become obsolete."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4052",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4055",
              "shortDescription": {
                "text": "Literals should not be passed as localized parameters"
              },
              "fullDescription": {
                "text": "String literals embedded in the source code will not be localized properly."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4055",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S4056",
              "shortDescription": {
                "text": "Overloads with a \"CultureInfo\" or an \"IFormatProvider\" parameter should be used"
              },
              "fullDescription": {
                "text": "When a System.Globalization.CultureInfo or IFormatProvider object is not supplied, the default value that is supplied by the overloaded member might not have the effect that you want in all locales."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4056",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4057",
              "shortDescription": {
                "text": "Locales should be set for data types"
              },
              "fullDescription": {
                "text": "When you create a DataTable or DataSet, you should set the locale explicitly. By default, the locale for these types is the current culture. For data that is stored in a database or file and is shared globally, the locale should ordinarily be set to the invariant culture (CultureInfo.InvariantCulture)."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4057",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4058",
              "shortDescription": {
                "text": "Overloads with a \"StringComparison\" parameter should be used"
              },
              "fullDescription": {
                "text": "Many string operations, the Compare and Equals methods in particular, provide an overload that accepts a StringComparison enumeration value as a parameter. Calling these overloads and explicitly providing this parameter makes your code clearer and easier to maintain."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4058",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4059",
              "shortDescription": {
                "text": "Property names should not match get methods"
              },
              "fullDescription": {
                "text": "Properties and Get method should have names that makes them clearly distinguishable."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4059",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4060",
              "shortDescription": {
                "text": "Non-abstract attributes should be sealed"
              },
              "fullDescription": {
                "text": "The .NET framework class library provides methods for retrieving custom attributes. Sealing the attribute eliminates the search through the inheritance hierarchy, and can improve performance."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4060",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S4061",
              "shortDescription": {
                "text": "\"params\" should be used instead of \"varargs\""
              },
              "fullDescription": {
                "text": "A method using the VarArgs calling convention is not Common Language Specification (CLS) compliant and might not be accessible across programming languages, while the params keyword works the same way and is CLS compliant."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4061",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4069",
              "shortDescription": {
                "text": "Operator overloads should have named alternatives"
              },
              "fullDescription": {
                "text": "Operator overloading is convenient but unfortunately not portable across languages. To be able to access the same functionality from another language you need to provide an alternate named method following the convention:"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4069",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S4070",
              "shortDescription": {
                "text": "Non-flags enums should not be marked with \"FlagsAttribute\""
              },
              "fullDescription": {
                "text": "This rule raises an issue when an externally visible enumeration is marked with FlagsAttribute and one, or more, of its values is not a power of 2 or a combination of the other defined values."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4070",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4136",
              "shortDescription": {
                "text": "Method overloads should be grouped together"
              },
              "fullDescription": {
                "text": "For clarity, all overloads of the same method should be grouped together. That lets both users and maintainers quickly understand all the current available options."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4136",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4143",
              "shortDescription": {
                "text": "Collection elements should not be replaced unconditionally"
              },
              "fullDescription": {
                "text": "It is highly suspicious when a value is saved for a key or index and then unconditionally overwritten. Such replacements are likely errors."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4143",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4144",
              "shortDescription": {
                "text": "Methods should not have identical implementations"
              },
              "fullDescription": {
                "text": "When two methods have the same implementation, either it was a mistake - something else was intended - or the duplication was intentional, but may be confusing to maintainers. In the latter case, one implementation should invoke the other."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4144",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4158",
              "shortDescription": {
                "text": "Empty collections should not be accessed or iterated"
              },
              "fullDescription": {
                "text": "When a collection is empty it makes no sense to access or iterate it. Doing so anyway is surely an error; either population was accidentally omitted or the developer doesn’t understand the situation."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4158",
              "properties": {
                "category": "Minor Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4159",
              "shortDescription": {
                "text": "Classes should implement their \"ExportAttribute\" interfaces"
              },
              "fullDescription": {
                "text": "In the Attributed Programming Model, the ExportAttribute declares that a part \"exports\", or provides to the composition container, an object that fulfills a particular contract. During composition, parts with imports that have matching contracts will have those dependencies filled by the exported object."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4159",
              "properties": {
                "category": "Blocker Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4200",
              "shortDescription": {
                "text": "Native methods should be wrapped"
              },
              "fullDescription": {
                "text": "Native methods are functions that reside in libraries outside the .NET runtime. Calling them is helpful for interoperability with applications and libraries written in other programming languages, mainly when performing platform-specific operations. However, doing so comes with additional risks since it means stepping out of the memory-safety model of the runtime. It is therefore highly recommended to take extra steps, like input validation, when invoking native methods. Making the native method private and providing a wrapper that performs these additional steps is the best way to do so."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4200",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4201",
              "shortDescription": {
                "text": "Null checks should not be used with \"is\""
              },
              "fullDescription": {
                "text": "There’s no need to null test in conjunction with an is test. null is not an instance of anything, so a null check is redundant."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4201",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4210",
              "shortDescription": {
                "text": "Windows Forms entry points should be marked with STAThread"
              },
              "fullDescription": {
                "text": "When an assembly uses Windows Forms (classes and interfaces from the System.Windows.Forms namespace) its entry point should be marked with the STAThreadAttribute to indicate that the threading model should be \"Single-Threaded Apartment\" (STA) which is the only one supported by Windows Forms."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4210",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4211",
              "shortDescription": {
                "text": "Members should not have conflicting transparency annotations"
              },
              "fullDescription": {
                "text": "Transparency attributes, SecurityCriticalAttribute and SecuritySafeCriticalAttribute are used to identify code that performs security-critical operations. The second one indicates that it is safe to call this code from transparent, while the first one does not. Since the transparency attributes of code elements with larger scope take precedence over transparency attributes of code elements that are contained in the first element a class, for instance, with a SecurityCriticalAttribute can not contain a method with a SecuritySafeCriticalAttribute."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4211",
              "properties": {
                "category": "Major Vulnerability",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4212",
              "shortDescription": {
                "text": "Serialization constructors should be secured"
              },
              "fullDescription": {
                "text": "Because serialization constructors allocate and initialize objects, security checks that are present on regular constructors must also be present on a serialization constructor. Failure to do so would allow callers that could not otherwise create an instance to use the serialization constructor to do this."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4212",
              "properties": {
                "category": "Major Vulnerability",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S4214",
              "shortDescription": {
                "text": "\"P/Invoke\" methods should not be visible"
              },
              "fullDescription": {
                "text": "Methods marked with the System.Runtime.InteropServices.DllImportAttribute attribute use Platform Invocation Services to access unmanaged code and should not be exposed. Keeping them private or internal makes sure that their access is controlled and properly managed."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4214",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S4220",
              "shortDescription": {
                "text": "Events should have proper arguments"
              },
              "fullDescription": {
                "text": "When raising an event, two arguments are expected by the EventHandler delegate: Sender and event-data. There are three guidelines regarding these parameters:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4220",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4225",
              "shortDescription": {
                "text": "Extension methods should not extend \"object\""
              },
              "fullDescription": {
                "text": "Creating an extension method that extends object is not recommended because it makes the method available on every type. Extensions should be applied at the most specialized level possible, and that is very unlikely to be object."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4225",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4226",
              "shortDescription": {
                "text": "Extensions should be in separate namespaces"
              },
              "fullDescription": {
                "text": "It makes little sense to create an extension method when it is possible to just add that method to the class itself."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4226",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4260",
              "shortDescription": {
                "text": "\"ConstructorArgument\" parameters should exist in constructors"
              },
              "fullDescription": {
                "text": "When creating a custom Markup Extension that accepts parameters in WPF, the ConstructorArgument markup must be used to identify the discrete properties that match these parameters. However since this is done via a string, the compiler will not notice if there are typos."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4260",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4261",
              "shortDescription": {
                "text": "Methods should be named according to their synchronicities"
              },
              "fullDescription": {
                "text": "According to the Task-based Asynchronous Pattern (TAP), methods returning either a System.Threading.Tasks.Task or a System.Threading.Tasks.Task<TResult> are considered \"asynchronous\". Such methods should use the Async suffix. Conversely methods which do not return such Tasks should not have an \"Async\" suffix in their names."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4261",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4275",
              "shortDescription": {
                "text": "Getters and setters should access the expected fields"
              },
              "fullDescription": {
                "text": "Properties provide a way to enforce encapsulation by providing public, protected or internal methods that give controlled access to private fields. However in classes with multiple fields it is not unusual that cut and paste is used to quickly create the needed properties, which can result in the wrong field being accessed by a getter or setter."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4275",
              "properties": {
                "category": "Critical Bug",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4277",
              "shortDescription": {
                "text": "\"Shared\" parts should not be created with \"new\""
              },
              "fullDescription": {
                "text": "Marking a class with PartCreationPolicy(CreationPolicy.Shared), which is part of Managed Extensibility Framework (MEF), means that a single, shared instance of the exported object will be created. Therefore it doesn’t make sense to create new instances using the constructor and it will most likely result in unexpected behaviours."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4277",
              "properties": {
                "category": "Critical Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4423",
              "shortDescription": {
                "text": "Weak SSL/TLS protocols should not be used"
              },
              "fullDescription": {
                "text": "Older versions of SSL/TLS protocol like \"SSLv3\" have been proven to be insecure."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4423",
              "properties": {
                "category": "Critical Vulnerability",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4426",
              "shortDescription": {
                "text": "Cryptographic keys should be robust"
              },
              "fullDescription": {
                "text": "Most of cryptographic systems require a sufficient key size to be robust against brute-force attacks."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4426",
              "properties": {
                "category": "Critical Vulnerability",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4428",
              "shortDescription": {
                "text": "\"PartCreationPolicyAttribute\" should be used with \"ExportAttribute\""
              },
              "fullDescription": {
                "text": "The PartCreationPolicyAttribute attribute, which is part of the Managed Extensibility Framework (MEF), is used to specify how the exported object will be created. Therefore it doesn’t make sense not to export this a class with this attribute using the ExportAttribute attribute."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4428",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4433",
              "shortDescription": {
                "text": "LDAP connections should be authenticated"
              },
              "fullDescription": {
                "text": "An LDAP client authenticates to an LDAP server with a \"bind request\" which provides, among other, a simple authentication method."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4433",
              "properties": {
                "category": "Critical Vulnerability",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4456",
              "shortDescription": {
                "text": "Parameter validation in yielding methods should be wrapped"
              },
              "fullDescription": {
                "text": "Because of the way yield methods are rewritten by the compiler (they become lazily evaluated state machines) any exceptions thrown during the parameters check will happen only when the collection is iterated over. That could happen far away from the source of the buggy code."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4456",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4457",
              "shortDescription": {
                "text": "Parameter validation in \"async\"/\"await\" methods should be wrapped"
              },
              "fullDescription": {
                "text": "Because of the way async/await methods are rewritten by the compiler, any exceptions thrown during the parameters check will happen only when the task is observed. That could happen far away from the source of the buggy code or never happen for fire-and-forget tasks."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4457",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4462",
              "shortDescription": {
                "text": "Calls to \"async\" methods should not be blocking"
              },
              "fullDescription": {
                "text": "Making blocking calls to async methods transforms code that was intended to be asynchronous into a blocking operation. Doing so can cause deadlocks and unexpected blocking of context threads."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4462",
              "properties": {
                "category": "Blocker Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S4487",
              "shortDescription": {
                "text": "Unread \"private\" fields should be removed"
              },
              "fullDescription": {
                "text": "Private fields only used to store values without reading them later is a case of dead store. So changing the value of such field is useless and most probably indicates a serious error in the code."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4487",
              "properties": {
                "category": "Critical Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4502",
              "shortDescription": {
                "text": "Disabling CSRF protections is security-sensitive"
              },
              "fullDescription": {
                "text": "A cross-site request forgery (CSRF) attack occurs when a trusted user of a web application can be forced, by an attacker, to perform sensitive actions that he didn’t intend, such as updating his profile or sending a message, more generally anything that can change the state of the application."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4502",
              "properties": {
                "category": "Critical Security Hotspot",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4507",
              "shortDescription": {
                "text": "Delivering code in production with debug features activated is security-sensitive"
              },
              "fullDescription": {
                "text": "Development tools and frameworks usually have options to make debugging easier for developers. Although these features are useful during development, they should never be enabled for applications deployed in production. Debug instructions or error messages can leak detailed information about the system, like the application’s path or file names."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4507",
              "properties": {
                "category": "Minor Security Hotspot",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4524",
              "shortDescription": {
                "text": "\"default\" clauses should be first or last"
              },
              "fullDescription": {
                "text": "switch can contain a default clause for various reasons: to handle unexpected values, to show that all the cases were properly considered."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4524",
              "properties": {
                "category": "Critical Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4545",
              "shortDescription": {
                "text": "\"DebuggerDisplayAttribute\" strings should reference existing members"
              },
              "fullDescription": {
                "text": "The DebuggerDisplayAttribute is used to determine how an object is displayed in the debugger window."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4545",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4564",
              "shortDescription": {
                "text": "ASP.NET HTTP request validation feature should not be disabled"
              },
              "fullDescription": {
                "text": "ASP.Net has a feature to validate HTTP requests to prevent potentially dangerous content to perform a cross-site scripting (XSS) attack. There is no reason to disable this mechanism even if other checks to prevent XXS attacks are in place."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4564",
              "properties": {
                "category": "Major Vulnerability",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S4581",
              "shortDescription": {
                "text": "\"new Guid()\" should not be used"
              },
              "fullDescription": {
                "text": "When the syntax new Guid() (i.e. parameterless instantiation) is used, it must be that one of three things is wanted:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4581",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4583",
              "shortDescription": {
                "text": "Calls to delegate's method \"BeginInvoke\" should be paired with calls to \"EndInvoke\""
              },
              "fullDescription": {
                "text": "Calling the BeginInvoke method of a delegate will allocate some resources that are only freed-up when EndInvoke is called. This is why you should always pair BeginInvoke with an EndInvoke to complete your asynchronous call."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4583",
              "properties": {
                "category": "Critical Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4586",
              "shortDescription": {
                "text": "Non-async \"Task/Task<T>\" methods should not return null"
              },
              "fullDescription": {
                "text": "Returning null from a non-async Task/Task<T> method will cause a NullReferenceException at runtime. This problem can be avoided by returning Task.FromResult<T>(null) instead."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4586",
              "properties": {
                "category": "Critical Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4635",
              "shortDescription": {
                "text": "String offset-based methods should be preferred for finding substrings from offsets"
              },
              "fullDescription": {
                "text": "Looking for a given substring starting from a specified offset can be achieved by such code: str.Substring(startIndex).IndexOf(char1). This works well, but it creates a new string for each call to the Substring method. When this is done in a loop, a lot of strings are created for nothing, which can lead to performance problems if str is large."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4635",
              "properties": {
                "category": "Critical Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4663",
              "shortDescription": {
                "text": "Comments should not be empty"
              },
              "fullDescription": {
                "text": "An empty comment is likely to be a mistake and doesn’t help to improve the readability of the code. For these reasons, it should be removed."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4663",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4784",
              "shortDescription": {
                "text": "Using regular expressions is security-sensitive"
              },
              "fullDescription": {
                "text": "Using regular expressions is security-sensitive. It has led in the past to the following vulnerabilities:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4784",
              "properties": {
                "category": "Critical Security Hotspot",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S4787",
              "shortDescription": {
                "text": "Encrypting data is security-sensitive"
              },
              "fullDescription": {
                "text": "Encrypting data is security-sensitive. It has led in the past to the following vulnerabilities:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4787",
              "properties": {
                "category": "Critical Security Hotspot",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S4790",
              "shortDescription": {
                "text": "Using weak hashing algorithms is security-sensitive"
              },
              "fullDescription": {
                "text": "Cryptographic hash algorithms such as MD2, MD4, MD5, MD6, HAVAL-128, HMAC-MD5, DSA (which uses SHA-1), RIPEMD, RIPEMD-128, RIPEMD-160, HMACRIPEMD160 and SHA-1 are no longer considered secure, because it is possible to have collisions (little computational effort is enough to find two or more different inputs that produce the same hash)."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4790",
              "properties": {
                "category": "Critical Security Hotspot",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4792",
              "shortDescription": {
                "text": "Configuring loggers is security-sensitive"
              },
              "fullDescription": {
                "text": "Configuring loggers is security-sensitive. It has led in the past to the following vulnerabilities:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4792",
              "properties": {
                "category": "Critical Security Hotspot",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4818",
              "shortDescription": {
                "text": "Using Sockets is security-sensitive"
              },
              "fullDescription": {
                "text": "Using sockets is security-sensitive. It has led in the past to the following vulnerabilities:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4818",
              "properties": {
                "category": "Critical Security Hotspot",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S4823",
              "shortDescription": {
                "text": "Using command line arguments is security-sensitive"
              },
              "fullDescription": {
                "text": "Using command line arguments is security-sensitive. It has led in the past to the following vulnerabilities:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4823",
              "properties": {
                "category": "Critical Security Hotspot",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S4829",
              "shortDescription": {
                "text": "Reading the Standard Input is security-sensitive"
              },
              "fullDescription": {
                "text": "Reading Standard Input is security-sensitive. It has led in the past to the following vulnerabilities:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4829",
              "properties": {
                "category": "Critical Security Hotspot",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S4830",
              "shortDescription": {
                "text": "Server certificates should be verified during SSL/TLS connections"
              },
              "fullDescription": {
                "text": "Validation of X.509 certificates is essential to create secure SSL/TLS sessions not vulnerable to man-in-the-middle attacks."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4830",
              "properties": {
                "category": "Critical Vulnerability",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4834",
              "shortDescription": {
                "text": "Controlling permissions is security-sensitive"
              },
              "fullDescription": {
                "text": "The access control of an application must be properly implemented in order to restrict access to resources to authorized entities otherwise this could lead to vulnerabilities:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4834",
              "properties": {
                "category": "Minor Security Hotspot",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S5034",
              "shortDescription": {
                "text": "\"ValueTask\" should be consumed correctly"
              },
              "fullDescription": {
                "text": "ValueTask<TResult> was introduced in .NET Core 2.0 to optimize memory allocation when functions return their results synchronously."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-5034",
              "properties": {
                "category": "Critical Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S5042",
              "shortDescription": {
                "text": "Expanding archive files without controlling resource consumption is security-sensitive"
              },
              "fullDescription": {
                "text": "Successful Zip Bomb attacks occur when an application expands untrusted archive files without controlling the size of the expanded data, which can lead to denial of service. A Zip bomb is usually a malicious archive file of a few kilobytes of compressed data but turned into gigabytes of uncompressed data. To achieve this extreme compression ratio, attackers will compress irrelevant data (eg: a long string of repeated bytes)."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-5042",
              "properties": {
                "category": "Critical Security Hotspot",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S5122",
              "shortDescription": {
                "text": "Having a permissive Cross-Origin Resource Sharing policy is security-sensitive"
              },
              "fullDescription": {
                "text": "Having a permissive Cross-Origin Resource Sharing policy is security-sensitive. It has led in the past to the following vulnerabilities:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-5122",
              "properties": {
                "category": "Minor Security Hotspot",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S5332",
              "shortDescription": {
                "text": "Using clear-text protocols is security-sensitive"
              },
              "fullDescription": {
                "text": "Clear-text protocols such as ftp, telnet, or http lack encryption of transported data, as well as the capability to build an authenticated connection. It means that an attacker able to sniff traffic from the network can read, modify, or corrupt the transported content. These protocols are not secure as they expose applications to an extensive range of risks:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-5332",
              "properties": {
                "category": "Critical Security Hotspot",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S5443",
              "shortDescription": {
                "text": "Using publicly writable directories is security-sensitive"
              },
              "fullDescription": {
                "text": "Operating systems have global directories where any user has write access. Those folders are mostly used as temporary storage areas like /tmp in Linux based systems. An application manipulating files from these folders is exposed to race conditions on filenames: a malicious user can try to create a file with a predictable name before the application does. A successful attack can result in other files being accessed, modified, corrupted or deleted. This risk is even higher if the application runs with elevated permissions."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-5443",
              "properties": {
                "category": "Critical Security Hotspot",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S5445",
              "shortDescription": {
                "text": "Insecure temporary file creation methods should not be used"
              },
              "fullDescription": {
                "text": "Creating temporary files using insecure methods exposes the application to race conditions on filenames: a malicious user can try to create a file with a predictable name before the application does. A successful attack can result in other files being accessed, modified, corrupted or deleted. This risk is even higher if the application run with elevated permissions."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-5445",
              "properties": {
                "category": "Critical Vulnerability",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S5542",
              "shortDescription": {
                "text": "Encryption algorithms should be used with secure mode and padding scheme"
              },
              "fullDescription": {
                "text": "Encryption algorithms should use secure modes and padding schemes where appropriate to guarantee data confidentiality and integrity."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-5542",
              "properties": {
                "category": "Critical Vulnerability",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S5547",
              "shortDescription": {
                "text": "Cipher algorithms should be robust"
              },
              "fullDescription": {
                "text": "Strong cipher algorithms are cryptographic systems resistant to cryptanalysis, they are not vulnerable to well-known attacks like brute force attacks for example."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-5547",
              "properties": {
                "category": "Critical Vulnerability",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S5659",
              "shortDescription": {
                "text": "JWT should be signed and verified with strong cipher algorithms"
              },
              "fullDescription": {
                "text": "If a JSON Web Token (JWT) is not signed with a strong cipher algorithm (or not signed at all) an attacker can forge it and impersonate user identities."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-5659",
              "properties": {
                "category": "Critical Vulnerability",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S5693",
              "shortDescription": {
                "text": "Allowing requests with excessive content length is security-sensitive"
              },
              "fullDescription": {
                "text": "Rejecting requests with significant content length is a good practice to control the network traffic intensity and thus resource consumption in order to prevents DoS attacks."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-5693",
              "properties": {
                "category": "Major Security Hotspot",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S5753",
              "shortDescription": {
                "text": "Disabling ASP.NET \"Request Validation\" feature is security-sensitive"
              },
              "fullDescription": {
                "text": "ASP.NET 1.1+ comes with a feature called Request Validation, preventing the server to accept content containing un-encoded HTML. This feature comes as a first protection layer against Cross-Site Scripting (XSS) attacks and act as a simple Web Application Firewall (WAF) rejecting requests potentially containing malicious content."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-5753",
              "properties": {
                "category": "Major Security Hotspot",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S5766",
              "shortDescription": {
                "text": "Deserializing objects without performing data validation is security-sensitive"
              },
              "fullDescription": {
                "text": "Deserialization process extracts data from the serialized representation of an object and reconstruct it directly, without calling constructors. Thus, data validation implemented in constructors can be bypassed if serialized objects are controlled by an attacker."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-5766",
              "properties": {
                "category": "Major Security Hotspot",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S5773",
              "shortDescription": {
                "text": "Types allowed to be deserialized should be restricted"
              },
              "fullDescription": {
                "text": "During the deserialization process, the state of an object will be reconstructed from the serialized data stream which can contain dangerous operations."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-5773",
              "properties": {
                "category": "Major Vulnerability",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S5856",
              "shortDescription": {
                "text": "Regular expressions should be syntactically valid"
              },
              "fullDescription": {
                "text": "Regular expressions have their own syntax that is understood by regular expression engines. Those engines will throw an exception at runtime if they are given a regular expression that does not conform to that syntax."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-5856",
              "properties": {
                "category": "Critical Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6354",
              "shortDescription": {
                "text": "Use a testable date/time provider"
              },
              "fullDescription": {
                "text": "One of the principles of a unit test is that it must have full control of the system under test. This is problematic when production code includes calls to static methods, which cannot be changed or controlled. Date/time functions are usually provided by system libraries as static methods."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6354",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S6419",
              "shortDescription": {
                "text": "Azure Functions should be stateless"
              },
              "fullDescription": {
                "text": "An Azure Function should be stateless as there’s no control over where and when function instances are provisioned and de-provisioned. Managing and storing data/state between requests can lead to inconsistencies. If, for any reason, you need to have a stateful function, consider using the Durable Functions extension of Azure Functions."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6419",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6420",
              "shortDescription": {
                "text": "Client instances should not be recreated on each Azure Function invocation"
              },
              "fullDescription": {
                "text": "To avoid holding more connections than necessary and to avoid potentially exhausting the number of available sockets when using HttpClient, DocumentClient, QueueClient, ConnectionMultiplexer or Azure Storage clients, consider:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6420",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6421",
              "shortDescription": {
                "text": "Azure Functions should use Structured Error Handling"
              },
              "fullDescription": {
                "text": "The top-most level of an Azure Function code should include a try/catch block to capture and log all errors so you can monitor the health of the application effectively. In case a retry policy has been defined for your Azure Function, you should rethrow any errors that should result in a retry."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6421",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S6422",
              "shortDescription": {
                "text": "Calls to \"async\" methods should not be blocking in Azure Functions"
              },
              "fullDescription": {
                "text": "Making blocking calls to async methods transforms code that was intended to be asynchronous into a blocking operation. Doing so inside an Azure Function can lead to thread exhaustion."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6422",
              "properties": {
                "category": "Blocker Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6423",
              "shortDescription": {
                "text": "Azure Functions should log all failures"
              },
              "fullDescription": {
                "text": "Capturing and logging errors is critical to monitoring the health of your Azure Functions application."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6423",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S6424",
              "shortDescription": {
                "text": "Interfaces for durable entities should satisfy the restrictions"
              },
              "fullDescription": {
                "text": "The recommended way to access Azure Durable Entities is Interfaces via generated proxy objects."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6424",
              "properties": {
                "category": "Blocker Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6444",
              "shortDescription": {
                "text": "Not specifying a timeout for regular expressions is security-sensitive"
              },
              "fullDescription": {
                "text": "Not specifying a timeout for regular expressions can lead to a Denial-of-Service attack. Pass a timeout when using System.Text.RegularExpressions to process untrusted input because a malicious user might craft a value for which the evaluation lasts excessively long."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6444",
              "properties": {
                "category": "Major Security Hotspot",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6507",
              "shortDescription": {
                "text": "Blocks should not be synchronized on local variables"
              },
              "fullDescription": {
                "text": "Locking on a local variable can undermine synchronization because two different threads running the same method in parallel will potentially lock on different instances of the same object, allowing them to access the synchronized block at the same time."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6507",
              "properties": {
                "category": "Major Bug",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S6513",
              "shortDescription": {
                "text": "\"ExcludeFromCodeCoverage\" attributes should include a justification"
              },
              "fullDescription": {
                "text": "The ExcludeFromCodeCoverageAttribute is used to exclude portions of code from code coverage reporting. It is a bad practice to retain code that is not covered by unit tests. In .Net 5, the Justification property was added to the ExcludeFromCodeCoverageAttribute as an opportunity to document the rationale for the exclusion. This rule raises an issue when no such justification is given."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6513",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S818",
              "shortDescription": {
                "text": "Literal suffixes should be upper case"
              },
              "fullDescription": {
                "text": "Using upper case literal suffixes removes the potential ambiguity between \"1\" (digit 1) and \"l\" (letter el) for declaring literals."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-818",
              "properties": {
                "category": "Minor Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S881",
              "shortDescription": {
                "text": "Increment (++) and decrement (--) operators should not be used in a method call or mixed with other operators in an expression"
              },
              "fullDescription": {
                "text": "The use of increment and decrement operators in method calls or in combination with other arithmetic operators is not recommended, because:"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-881",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S907",
              "shortDescription": {
                "text": "\"goto\" statement should not be used"
              },
              "fullDescription": {
                "text": "goto is an unstructured control flow statement. It makes code less readable and maintainable. Structured control flow statements such as if, for, while, continue or break should be used instead."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-907",
              "properties": {
                "category": "Major Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S927",
              "shortDescription": {
                "text": "Parameter names should match base declaration and other partial definitions"
              },
              "fullDescription": {
                "text": "The name of a parameter in an externally visible. This rule raises an issue when method override does not match the name of the parameter in the base declaration of the method, or the name of the parameter in the interface declaration of the method or the name of any other partial definition."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-927",
              "properties": {
                "category": "Critical Code Smell",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S9999-cpd",
              "shortDescription": {
                "text": "Copy-paste token calculator"
              },
              "properties": {
                "tags": [
                  "MainSourceScope",
                  "TestSourceScope",
                  "Utility",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "S9999-log",
              "shortDescription": {
                "text": "Log generator"
              },
              "properties": {
                "tags": [
                  "MainSourceScope",
                  "TestSourceScope",
                  "Utility",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "S9999-metadata",
              "shortDescription": {
                "text": "File metadata generator"
              },
              "properties": {
                "tags": [
                  "MainSourceScope",
                  "TestSourceScope",
                  "Utility",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "S9999-metrics",
              "shortDescription": {
                "text": "Metrics calculator"
              },
              "properties": {
                "tags": [
                  "MainSourceScope",
                  "TestSourceScope",
                  "Utility",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "S9999-symbolRef",
              "shortDescription": {
                "text": "Symbol reference calculator"
              },
              "properties": {
                "tags": [
                  "MainSourceScope",
                  "TestSourceScope",
                  "Utility",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "S9999-token-type",
              "shortDescription": {
                "text": "Token type calculator"
              },
              "properties": {
                "tags": [
                  "MainSourceScope",
                  "TestSourceScope",
                  "Utility",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "S9999-warning",
              "shortDescription": {
                "text": "Analysis Warning generator"
              },
              "properties": {
                "tags": [
                  "MainSourceScope",
                  "TestSourceScope",
                  "Utility",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "SCS0000",
              "shortDescription": {
                "text": "Compilation analysis completed for {0}."
              },
              "fullDescription": {
                "text": "This a fake warning you may enable in configuration just to have a proof in a log that analyzer did run."
              },
              "helpUri": "https://security-code-scan.github.io/#SCS0000",
              "properties": {
                "category": "Security"
              }
            },
            {
              "id": "SCS0001",
              "shortDescription": {
                "text": "Potential Command Injection vulnerability was found where '{0}' in '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'."
              },
              "fullDescription": {
                "text": "The untrusted value passed to the command execution should be validated."
              },
              "helpUri": "https://security-code-scan.github.io/#SCS0001",
              "properties": {
                "category": "Security"
              }
            },
            {
              "id": "SCS0002",
              "shortDescription": {
                "text": "Potential SQL injection vulnerability was found where '{0}' in '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'."
              },
              "fullDescription": {
                "text": "The untrusted value passed to the SQL query should be validated."
              },
              "helpUri": "https://security-code-scan.github.io/#SCS0002",
              "properties": {
                "category": "Security"
              }
            },
            {
              "id": "SCS0003",
              "shortDescription": {
                "text": "Potential XPath injection vulnerability was found where '{0}' in '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'."
              },
              "fullDescription": {
                "text": "The untrusted value passed to the XPath query should be validated."
              },
              "helpUri": "https://security-code-scan.github.io/#SCS0003",
              "properties": {
                "category": "Security"
              }
            },
            {
              "id": "SCS0004",
              "shortDescription": {
                "text": "Certificate Validation has been disabled."
              },
              "fullDescription": {
                "text": "Disabled certificate validation may lead to Person in the Middle attack."
              },
              "helpUri": "https://security-code-scan.github.io/#SCS0004",
              "properties": {
                "category": "Security"
              }
            },
            {
              "id": "SCS0005",
              "shortDescription": {
                "text": "Weak random number generator."
              },
              "fullDescription": {
                "text": "It is possible to predict the next numbers of a pseudo random generator. Use a cryptographically strong generator for security sensitive purposes."
              },
              "helpUri": "https://security-code-scan.github.io/#SCS0005",
              "properties": {
                "category": "Security"
              }
            },
            {
              "id": "SCS0006",
              "shortDescription": {
                "text": "Weak hashing function."
              },
              "fullDescription": {
                "text": "MD5 is no longer considered as a strong hashing algorithm."
              },
              "helpUri": "https://security-code-scan.github.io/#SCS0006",
              "properties": {
                "category": "Security"
              }
            },
            {
              "id": "SCS0007",
              "shortDescription": {
                "text": "Potential XML eXternal Entity (XXE) vulnerability."
              },
              "fullDescription": {
                "text": "Unsafe configuration of the XML parser may lead to XML eXternal Entity (XXE) processing vulnerability."
              },
              "helpUri": "https://security-code-scan.github.io/#SCS0007",
              "properties": {
                "category": "Security"
              }
            },
            {
              "id": "SCS0008",
              "shortDescription": {
                "text": "The cookie is missing 'Secure' flag."
              },
              "fullDescription": {
                "text": "Cookies without 'Secure' flag may be transmitted over unencrypted connection."
              },
              "helpUri": "https://security-code-scan.github.io/#SCS0008",
              "properties": {
                "category": "Security"
              }
            },
            {
              "id": "SCS0009",
              "shortDescription": {
                "text": "The cookie is missing 'HttpOnly' flag."
              },
              "fullDescription": {
                "text": "Cookies without 'HttpOnly' may be stolen in case of JavaScript injection (XSS)."
              },
              "helpUri": "https://security-code-scan.github.io/#SCS0009",
              "properties": {
                "category": "Security"
              }
            },
            {
              "id": "SCS0010",
              "shortDescription": {
                "text": "Weak cipher algorithm."
              },
              "fullDescription": {
                "text": "{0} is not considered as a strong modern cipher."
              },
              "helpUri": "https://security-code-scan.github.io/#SCS0010",
              "properties": {
                "category": "Security"
              }
            },
            {
              "id": "SCS0011",
              "shortDescription": {
                "text": "Unsafe XSLT setting used."
              },
              "fullDescription": {
                "text": "XSLT scripting should be enabled only if you require script support and you are working in a fully trusted environment."
              },
              "helpUri": "https://security-code-scan.github.io/#SCS0011",
              "properties": {
                "category": "Security"
              }
            },
            {
              "id": "SCS0012",
              "shortDescription": {
                "text": "Controller method is potentially vulnerable to authorization bypass."
              },
              "fullDescription": {
                "text": "Neither the annotation [Authorize] nor [AllowAnonymous] is present. The warning may be ignored/suppressed if the application is using other authorization checks."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://security-code-scan.github.io/#SCS0012",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "SCS0013",
              "shortDescription": {
                "text": "Potential usage of weak CipherMode."
              },
              "fullDescription": {
                "text": "This specific mode is susceptible to a cryptographic attack."
              },
              "helpUri": "https://security-code-scan.github.io/#SCS0013",
              "properties": {
                "category": "Security"
              }
            },
            {
              "id": "SCS0015",
              "shortDescription": {
                "text": "Hardcoded value in '{0}'."
              },
              "fullDescription": {
                "text": "The secret value to this API appears to be hardcoded. Consider moving the value to externalized configuration to avoid leakage of secret information."
              },
              "helpUri": "https://security-code-scan.github.io/#SCS0015",
              "properties": {
                "category": "Security"
              }
            },
            {
              "id": "SCS0016",
              "shortDescription": {
                "text": "Controller method is potentially vulnerable to Cross Site Request Forgery (CSRF)."
              },
              "fullDescription": {
                "text": "The annotation [ValidateAntiForgeryToken] is missing. The warning may be ignored/suppressed if .NET Core AutoValidateAntiforgeryToken is set up globally."
              },
              "helpUri": "https://security-code-scan.github.io/#SCS0016",
              "properties": {
                "category": "Security"
              }
            },
            {
              "id": "SCS0017",
              "shortDescription": {
                "text": "Request validation is disabled."
              },
              "fullDescription": {
                "text": "Request validation is disabled. Request validation allows the filtering of some XSS patterns submitted to the application."
              },
              "helpUri": "https://security-code-scan.github.io/#SCS0017",
              "properties": {
                "category": "Security"
              }
            },
            {
              "id": "SCS0018",
              "shortDescription": {
                "text": "Potential Path Traversal vulnerability was found where '{0}' in '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'."
              },
              "fullDescription": {
                "text": "The untrusted value passed to the redirect should be validated."
              },
              "helpUri": "https://security-code-scan.github.io/#SCS0018",
              "properties": {
                "category": "Security"
              }
            },
            {
              "id": "SCS0019",
              "shortDescription": {
                "text": "OutputCache annotation is disabling authorization checks."
              },
              "fullDescription": {
                "text": "Having the annotation [OutputCache] will disable the annotation [Authorize] for the requests following the first one."
              },
              "helpUri": "https://security-code-scan.github.io/#SCS0019",
              "properties": {
                "category": "Security"
              }
            },
            {
              "id": "SCS0021",
              "shortDescription": {
                "text": "Request validation has been disabled in {0}({1}): {2}."
              },
              "fullDescription": {
                "text": "Request validation, which provides additional protection against Cross-Site Scripting (XSS), has been disabled."
              },
              "helpUri": "https://security-code-scan.github.io/#SCS0021",
              "properties": {
                "category": "Security"
              }
            },
            {
              "id": "SCS0022",
              "shortDescription": {
                "text": "Event validation is disabled in {0}({1}): {2}."
              },
              "fullDescription": {
                "text": "Event validation is disabled. The integrity of client-side control will not be validated on postback."
              },
              "helpUri": "https://security-code-scan.github.io/#SCS0022",
              "properties": {
                "category": "Security"
              }
            },
            {
              "id": "SCS0023",
              "shortDescription": {
                "text": "View state is not encrypted in {0}({1}): {2}."
              },
              "fullDescription": {
                "text": "View state is not encrypted. Controls may leak sensitive data that could be read client-side."
              },
              "helpUri": "https://security-code-scan.github.io/#SCS0023",
              "properties": {
                "category": "Security"
              }
            },
            {
              "id": "SCS0024",
              "shortDescription": {
                "text": "View state mac is disabled in {0}({1}): {2}."
              },
              "fullDescription": {
                "text": "View state mac is disabled. The view state could be altered by an attacker. (This feature cannot be disabled in the recent version of ASP.net)."
              },
              "helpUri": "https://security-code-scan.github.io/#SCS0024",
              "properties": {
                "category": "Security"
              }
            },
            {
              "id": "SCS0026",
              "shortDescription": {
                "text": "Potential LDAP injection vulnerability was found where '{0}' in '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'."
              },
              "fullDescription": {
                "text": "The untrusted value passed to the LDAP query should be validated."
              },
              "helpUri": "https://security-code-scan.github.io/#SCS0026",
              "properties": {
                "category": "Security"
              }
            },
            {
              "id": "SCS0027",
              "shortDescription": {
                "text": "Potential Open Redirect vulnerability was found where '{0}' in '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'."
              },
              "fullDescription": {
                "text": "The untrusted value passed to the redirect should be validated."
              },
              "helpUri": "https://security-code-scan.github.io/#SCS0027",
              "properties": {
                "category": "Security"
              }
            },
            {
              "id": "SCS0028",
              "shortDescription": {
                "text": "Potential unsafe deserialization vulnerability was found where '{0}' in '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'."
              },
              "fullDescription": {
                "text": "Deserialization of untrusted data is unsafe."
              },
              "helpUri": "https://security-code-scan.github.io/#SCS0028",
              "properties": {
                "category": "Security"
              }
            },
            {
              "id": "SCS0029",
              "shortDescription": {
                "text": "Potential Cross-Site Scripting (XSS) vulnerability was found where '{0}' in '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'."
              },
              "fullDescription": {
                "text": "The untrusted value used to create a HTML should be validated or properly encoded."
              },
              "helpUri": "https://security-code-scan.github.io/#SCS0029",
              "properties": {
                "category": "Security"
              }
            },
            {
              "id": "SCS0030",
              "shortDescription": {
                "text": "Request validation is enabled only for pages, not for all HTTP requests in {0}({1}): {2}."
              },
              "fullDescription": {
                "text": "The RequestValidationMode property specifies which ASP.NET approach to validation will be used."
              },
              "helpUri": "https://security-code-scan.github.io/#SCS0030",
              "properties": {
                "category": "Security"
              }
            },
            {
              "id": "SCS0031",
              "shortDescription": {
                "text": "Potential LDAP injection vulnerability was found where '{0}' in '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'."
              },
              "fullDescription": {
                "text": "The untrusted value passed in the LDAP query should be validated."
              },
              "helpUri": "https://security-code-scan.github.io/#SCS0031",
              "properties": {
                "category": "Security"
              }
            },
            {
              "id": "SCS0032",
              "shortDescription": {
                "text": "The RequiredLength property of PasswordValidator should be set to at least {0}."
              },
              "fullDescription": {
                "text": "The minimal length of a passwords is too short."
              },
              "helpUri": "https://security-code-scan.github.io/#SCS0032",
              "properties": {
                "category": "Security"
              }
            },
            {
              "id": "SCS0033",
              "shortDescription": {
                "text": "Less than {0} properties set in PasswordValidator declaration."
              },
              "fullDescription": {
                "text": "Password requirements are weak. PasswordValidator should have more properties set (RequiredLength, RequireDigit, RequireLowercase, RequireUppercase and/or RequireNonLetterOrDigit)."
              },
              "helpUri": "https://security-code-scan.github.io/#SCS0033",
              "properties": {
                "category": "Security"
              }
            },
            {
              "id": "SCS0034",
              "shortDescription": {
                "text": "The {0} property must be set."
              },
              "fullDescription": {
                "text": "This property must be set to increase password requirements strength."
              },
              "helpUri": "https://security-code-scan.github.io/#SCS0034",
              "properties": {
                "category": "Security"
              }
            },
            {
              "id": "StringFormatArgumentImplicitToStringAnalyzer",
              "shortDescription": {
                "text": "Suspicious conversion to string"
              },
              "fullDescription": {
                "text": "Prevents calling .ToString() on a type which does not provide an override"
              },
              "properties": {
                "category": "Naming"
              }
            },
            {
              "id": "SYSLIB1045",
              "shortDescription": {
                "text": "Convert to 'GeneratedRegexAttribute'."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "GeneratedRegex"
              }
            },
            {
              "id": "SYSLIB1054",
              "shortDescription": {
                "text": "Use 'LibraryImportAttribute' instead of 'DllImportAttribute' to generate P/Invoke marshalling code at compile time"
              },
              "fullDescription": {
                "text": "Use 'LibraryImportAttribute' instead of 'DllImportAttribute' to generate P/Invoke marshalling code at compile time"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Interoperability"
              }
            },
            {
              "id": "SYSLIB1055",
              "shortDescription": {
                "text": "Invalid 'CustomMarshallerAttribute' usage"
              },
              "fullDescription": {
                "text": "A type with a 'System.Runtime.InteropServices.CustomMarshallerAttribute' must specify a non-'null' managed type"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "SYSLIB1056",
              "shortDescription": {
                "text": "Specified marshaller type is invalid"
              },
              "fullDescription": {
                "text": "The unmanaged type for a custom marshaller must be a C# unmanaged type."
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "SYSLIB1057",
              "shortDescription": {
                "text": "Marshaller type does not have the required shape"
              },
              "fullDescription": {
                "text": "A stateless value marshaller that supports marshalling from managed to unmanaged must provide a one-parameter 'ConvertToUnmanaged' method that takes the managed value as the parameter and returns a value of the 'unmanaged' type."
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "SYSLIB1058",
              "shortDescription": {
                "text": "Invalid 'NativeMarshallingAttribute' usage"
              },
              "fullDescription": {
                "text": "An entry-point type for marshalling a given type must have a 'System.Runtime.InteropServices.CustomMarshallerAttribute' that specifies this type as the managed type."
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "SYSLIB1060",
              "shortDescription": {
                "text": "Specified marshaller type is invalid"
              },
              "fullDescription": {
                "text": "A marshaller type must either be a stateless static class or a stateful value type. A non-static class is not allowed."
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "SYSLIB1061",
              "shortDescription": {
                "text": "Marshaller type has incompatible method signatures"
              },
              "fullDescription": {
                "text": "The return type of 'GetPinnableReference' (after accounting for 'ref') must be blittable."
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "VSTHRD001",
              "shortDescription": {
                "text": "Avoid legacy thread switching APIs"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD001.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "VSTHRD002",
              "shortDescription": {
                "text": "Avoid problematic synchronous waits"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD002.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "VSTHRD003",
              "shortDescription": {
                "text": "Avoid awaiting foreign Tasks"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD003.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "VSTHRD004",
              "shortDescription": {
                "text": "Await SwitchToMainThreadAsync"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD004.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "VSTHRD010",
              "shortDescription": {
                "text": "Invoke single-threaded types on Main thread"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD010.md",
              "properties": {
                "category": "Usage",
                "tags": [
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "VSTHRD011",
              "shortDescription": {
                "text": "Use AsyncLazy<T>"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD011.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "VSTHRD012",
              "shortDescription": {
                "text": "Provide JoinableTaskFactory where allowed"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD012.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "VSTHRD100",
              "shortDescription": {
                "text": "Avoid async void methods"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD100.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "VSTHRD101",
              "shortDescription": {
                "text": "Avoid unsupported async delegates"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD101.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "VSTHRD102",
              "shortDescription": {
                "text": "Implement internal logic asynchronously"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD102.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "VSTHRD103",
              "shortDescription": {
                "text": "Call async methods when in an async method"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD103.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "VSTHRD104",
              "shortDescription": {
                "text": "Offer async methods"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD104.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "VSTHRD105",
              "shortDescription": {
                "text": "Avoid method overloads that assume TaskScheduler.Current"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD105.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "VSTHRD106",
              "shortDescription": {
                "text": "Use InvokeAsync to raise async events"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD106.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "VSTHRD107",
              "shortDescription": {
                "text": "Await Task within using expression"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD107.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "VSTHRD108",
              "shortDescription": {
                "text": "Assert thread affinity unconditionally"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD108.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "VSTHRD109",
              "shortDescription": {
                "text": "Switch instead of assert in async methods"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD109.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "VSTHRD110",
              "shortDescription": {
                "text": "Observe result of async calls"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD110.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "VSTHRD111",
              "shortDescription": {
                "text": "Use ConfigureAwait(bool)"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD111.md",
              "properties": {
                "category": "Usage",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ]
              }
            },
            {
              "id": "VSTHRD112",
              "shortDescription": {
                "text": "Implement System.IAsyncDisposable"
              },
              "fullDescription": {
                "text": "The System.IAsyncDisposable interface is defined in the Microsoft.Bcl.AsyncInterfaces NuGet package."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD112.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "VSTHRD113",
              "shortDescription": {
                "text": "Check for System.IAsyncDisposable"
              },
              "fullDescription": {
                "text": "The System.IAsyncDisposable interface is defined in the Microsoft.Bcl.AsyncInterfaces NuGet package."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD113.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "VSTHRD114",
              "shortDescription": {
                "text": "Avoid returning a null Task"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD114.md",
              "properties": {
                "category": "Usage"
              }
            },
            {
              "id": "VSTHRD200",
              "shortDescription": {
                "text": "Use \"Async\" suffix for async methods"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD200.md",
              "properties": {
                "category": "Style"
              }
            }
          ]
        }
      },
      "columnKind": "utf16CodeUnits"
    }
  ]
}